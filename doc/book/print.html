<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SwissArmyHammer Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Complete guide to using SwissArmyHammer - the MCP server for managing prompts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SwissArmyHammer Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wballard/swissarmyhammer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="swissarmyhammer"><a class="header" href="#swissarmyhammer">SwissArmyHammer</a></h1>
<p><strong>The MCP server for managing prompts as markdown files</strong></p>
<p>SwissArmyHammer is a powerful Model Context Protocol (MCP) server that lets you manage AI prompts as simple markdown files. It seamlessly integrates with Claude Code and other MCP-compatible tools, providing a flexible and organized way to work with AI prompts.</p>
<h2 id="what-is-swissarmyhammer"><a class="header" href="#what-is-swissarmyhammer">What is SwissArmyHammer?</a></h2>
<p>SwissArmyHammer transforms how you work with AI prompts by:</p>
<ul>
<li><strong>ğŸ“ File-based prompt management</strong> - Store prompts as markdown files with YAML front matter</li>
<li><strong>ğŸ”„ Live reloading</strong> - Changes to prompt files are automatically detected and reloaded</li>
<li><strong>ğŸ¯ Template variables</strong> - Use <code>{{variable}}</code> syntax for dynamic prompt customization</li>
<li><strong>âš¡ MCP integration</strong> - Works seamlessly with Claude Code and other MCP clients</li>
<li><strong>ğŸ—‚ï¸ Organized hierarchy</strong> - Support for built-in, user, and local prompt directories</li>
<li><strong>ğŸ› ï¸ Developer-friendly</strong> - Rich CLI with diagnostics and shell completions</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="-quick-setup"><a class="header" href="#-quick-setup">ğŸš€ Quick Setup</a></h3>
<p>Get started by installing with Cargo:</p>
<pre><code class="language-bash">cargo install --git https://github.com/wballard/swissarmyhammer.git swissarmyhammer-cli
</code></pre>
<p>This requires Rust 1.70+ to be installed. Get Rust from <a href="https://rustup.rs/">rustup.rs</a>.</p>
<h3 id="-simple-prompt-format"><a class="header" href="#-simple-prompt-format">ğŸ“ Simple Prompt Format</a></h3>
<p>Create prompts using familiar markdown with YAML front matter:</p>
<pre><code class="language-markdown">---
title: Code Review Helper
description: Helps review code for best practices and potential issues
arguments:
  - name: code
    description: The code to review
    required: true
  - name: language
    description: Programming language
    required: false
    default: "auto-detect"
---

# Code Review

Please review the following {{language}} code:

</code></pre>
<p>{{code}}</p>
<pre><code>
Focus on:
- Code quality and readability
- Potential bugs or security issues
- Performance considerations
- Best practices adherence
</code></pre>
<h3 id="-template-variables"><a class="header" href="#-template-variables">ğŸ¯ Template Variables</a></h3>
<p>Use template variables to make prompts dynamic and reusable:</p>
<ul>
<li><code>{{variable}}</code> - Required variables</li>
<li><code>{{variable:default}}</code> - Optional variables with defaults</li>
<li>Support for strings, numbers, booleans, and JSON objects</li>
</ul>
<h3 id="-built-in-diagnostics"><a class="header" href="#-built-in-diagnostics">ğŸ”§ Built-in Diagnostics</a></h3>
<p>The <code>doctor</code> command helps troubleshoot setup issues:</p>
<pre><code class="language-bash">swissarmyhammer doctor
</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>SwissArmyHammer is perfect for:</p>
<ul>
<li><strong>Development Teams</strong> - Share and standardize AI prompts across your team</li>
<li><strong>Individual Developers</strong> - Organize your personal prompt library</li>
<li><strong>Content Creators</strong> - Manage writing and editing prompts</li>
<li><strong>Researchers</strong> - Organize domain-specific prompts and templates</li>
<li><strong>Students</strong> - Build a learning-focused prompt collection</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>SwissArmyHammer follows a simple but powerful architecture:</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Claude Code   â”‚â—„â”€â”€â–ºâ”‚ SwissArmyHammer  â”‚â—„â”€â”€â–ºâ”‚ Prompt Files    â”‚
â”‚   (MCP Client)  â”‚    â”‚   (MCP Server)   â”‚    â”‚ (.md files)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚  File Watcher    â”‚
                       â”‚ (Auto-reload)    â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Ready to get started? Check out our <a href="./installation.html">Installation Guide</a> or jump straight to creating <a href="./first-prompt.html">Your First Prompt</a>.</p>
<p>For integration with Claude Code, see our <a href="./claude-code-integration.html">Claude Code Integration</a> guide.</p>
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/wballard/swissarmyhammer">github.com/wballard/swissarmyhammer</a></li>
<li><strong>Issues</strong>: Report bugs and request features</li>
<li><strong>Discussions</strong>: Community Q&amp;A and sharing</li>
<li><strong>Contributing</strong>: See our <a href="./contributing.html">Contributing Guide</a></li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>SwissArmyHammer is open source software licensed under the MIT License. See the <a href="./license.html">License</a> page for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="quick-install-recommended"><a class="header" href="#quick-install-recommended">Quick Install (Recommended)</a></h2>
<h3 id="unix-like-systems-linuxmacos"><a class="header" href="#unix-like-systems-linuxmacos">Unix-like Systems (Linux/macOS)</a></h3>
<pre><code class="language-bash">curl -fsSL https://raw.githubusercontent.com/swissarmyhammer/swissarmyhammer/main/install.sh | sh
</code></pre>
<p>This script will:</p>
<ul>
<li>Detect your platform automatically</li>
<li>Download the latest release</li>
<li>Install to <code>/usr/local/bin</code></li>
<li>Verify the installation</li>
</ul>
<h2 id="clone-and-build"><a class="header" href="#clone-and-build">Clone and Build</a></h2>
<p>If you are installing from source:</p>
<ul>
<li><strong>Rust 1.70 or later</strong> - Install from <a href="https://rustup.rs/">rustup.rs</a></li>
<li><strong>Git</strong> - For cloning the repository</li>
</ul>
<p>If you want to build from source or contribute to development:</p>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/wballard/swissarmyhammer.git
cd swissarmyhammer

# Build the CLI (debug mode for development)
cargo build

# Build optimized release version
cargo build --release

# Install from the local source
cargo install --path swissarmyhammer-cli

# Or run directly without installing
cargo run --bin swissarmyhammer -- --help
</code></pre>
<h2 id="future-installation-methods"><a class="header" href="#future-installation-methods">Future Installation Methods</a></h2>
<p>Pre-built binaries and package manager support are planned for future releases:</p>
<ul>
<li><strong>macOS</strong>: Homebrew formula</li>
<li><strong>Linux</strong>: DEB and RPM packages</li>
<li><strong>Windows</strong>: MSI installer and Chocolatey package</li>
<li><strong>crates.io</strong>: Published crate for <code>cargo install swissarmyhammer-cli</code></li>
</ul>
<p>Check the <a href="https://github.com/wballard/swissarmyhammer/releases">releases page</a> for updates.</p>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>After installation, verify that SwissArmyHammer is working correctly:</p>
<pre><code class="language-bash"># Check version
swissarmyhammer --version

# Run diagnostics
swissarmyhammer doctor

# Show help
swissarmyhammer --help

# List available commands
swissarmyhammer list
</code></pre>
<p>The <code>doctor</code> command will check your installation and provide helpful diagnostics if anything needs attention.</p>
<h2 id="shell-completions"><a class="header" href="#shell-completions">Shell Completions</a></h2>
<p>Generate and install shell completions for better CLI experience:</p>
<pre><code class="language-bash"># Bash
swissarmyhammer completion bash &gt; ~/.local/share/bash-completion/completions/swissarmyhammer

# Zsh (add to fpath)
swissarmyhammer completion zsh &gt; ~/.zfunc/_swissarmyhammer

# Fish
swissarmyhammer completion fish &gt; ~/.config/fish/completions/swissarmyhammer.fish

# PowerShell
swissarmyhammer completion powershell &gt;&gt; $PROFILE
</code></pre>
<p>Remember to reload your shell or start a new terminal session for completions to take effect.</p>
<h2 id="updating"><a class="header" href="#updating">Updating</a></h2>
<p>To update SwissArmyHammer to the latest version:</p>
<pre><code class="language-bash"># Update from git repository
cargo install --git https://github.com/wballard/swissarmyhammer.git swissarmyhammer-cli --force
</code></pre>
<p>The <code>--force</code> flag will overwrite the existing installation.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Once installed, continue to the <a href="./quick-start.html">Quick Start</a> guide to set up SwissArmyHammer with Claude Code and create your first prompt.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Command not found</strong>: Make sure <code>~/.cargo/bin</code> is in your PATH.</p>
<p><strong>Build failures</strong>: Ensure you have Rust 1.70+ installed and try updating Rust:</p>
<pre><code class="language-bash">rustup update
</code></pre>
<p><strong>Permission errors</strong>: Donâ€™t use <code>sudo</code> with cargo install - it installs to your user directory.</p>
<p>For more help, check the <a href="./troubleshooting.html">Troubleshooting</a> guide or run:</p>
<pre><code class="language-bash">swissarmyhammer doctor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Get up and running with SwissArmyHammer in just a few minutes.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before you begin, make sure you have:</p>
<ul>
<li>SwissArmyHammer installed (see <a href="./installation.html">Installation</a>)</li>
<li>Claude Code (or another MCP-compatible client)</li>
</ul>
<h2 id="step-1-verify-installation"><a class="header" href="#step-1-verify-installation">Step 1: Verify Installation</a></h2>
<p>First, check that SwissArmyHammer is properly installed:</p>
<pre><code class="language-bash">swissarmyhammer --version
</code></pre>
<p>Run the doctor command to check your setup:</p>
<pre><code class="language-bash">swissarmyhammer doctor
</code></pre>
<p>This will check your system and provide recommendations if anything needs attention.</p>
<h2 id="step-2-configure-claude-code"><a class="header" href="#step-2-configure-claude-code">Step 2: Configure Claude Code</a></h2>
<p>Add SwissArmyHammer to your Claude Code MCP configuration:</p>
<h3 id="find-your-config-file"><a class="header" href="#find-your-config-file">Find Your Config File</a></h3>
<p>The Claude Code configuration file is located at:</p>
<ul>
<li><strong>macOS</strong>: <code>~/Library/Application Support/Claude/claude_desktop_config.json</code></li>
<li><strong>Windows</strong>: <code>%APPDATA%\Claude\claude_desktop_config.json</code></li>
<li><strong>Linux</strong>: <code>~/.config/Claude/claude_desktop_config.json</code></li>
</ul>
<h3 id="add-the-configuration"><a class="header" href="#add-the-configuration">Add the Configuration</a></h3>
<p>Create or edit the configuration file with the following content:</p>
<pre><code class="language-json">{
  "mcpServers": {
    "swissarmyhammer": {
      "command": "swissarmyhammer",
      "args": ["serve"]
    }
  }
}
</code></pre>
<p>If you already have other MCP servers configured, just add the <code>swissarmyhammer</code> entry to your existing <code>mcpServers</code> object.</p>
<h2 id="step-3-create-your-prompt-directory"><a class="header" href="#step-3-create-your-prompt-directory">Step 3: Create Your Prompt Directory</a></h2>
<p>Create a directory for your prompts:</p>
<pre><code class="language-bash">mkdir -p ~/.swissarmyhammer/prompts
</code></pre>
<p>This is where youâ€™ll store your custom prompts. SwissArmyHammer will automatically watch this directory for changes.</p>
<h2 id="step-4-create-your-first-prompt"><a class="header" href="#step-4-create-your-first-prompt">Step 4: Create Your First Prompt</a></h2>
<p>Create a simple prompt file:</p>
<pre><code class="language-bash">cat &gt; ~/.swissarmyhammer/prompts/helper.md &lt;&lt; 'EOF'
---
title: General Helper
description: A helpful assistant for various tasks
arguments:
  - name: task
    description: What you need help with
    required: true
  - name: style
    description: How to approach the task
    required: false
    default: "friendly and concise"
---

# Task Helper

Please help me with: {{task}}

Approach this in a {{style}} manner. Provide clear, actionable advice.
EOF
</code></pre>
<h2 id="step-5-test-the-setup"><a class="header" href="#step-5-test-the-setup">Step 5: Test the Setup</a></h2>
<ol>
<li>
<p><strong>Restart Claude Code</strong> to pick up the new MCP server configuration.</p>
</li>
<li>
<p><strong>Open Claude Code</strong> and start a new conversation.</p>
</li>
<li>
<p><strong>Try using your prompt</strong>: In Claude Code, you should now see SwissArmyHammer prompts available in the prompt picker.</p>
</li>
<li>
<p><strong>Use the built-in prompts</strong>: SwissArmyHammer comes with several built-in prompts you can try right away:</p>
<ul>
<li><code>help</code> - Get help with using SwissArmyHammer</li>
<li><code>debug-error</code> - Debug error messages</li>
<li><code>code-review</code> - Review code for issues</li>
<li><code>docs-readme</code> - Generate README files</li>
</ul>
</li>
</ol>
<h2 id="step-6-verify-everything-works"><a class="header" href="#step-6-verify-everything-works">Step 6: Verify Everything Works</a></h2>
<p>Test that SwissArmyHammer is working correctly:</p>
<pre><code class="language-bash"># Check if Claude Code can connect (this will show server info)
swissarmyhammer serve --help

# Run diagnostics again to see the updated status
swissarmyhammer doctor
</code></pre>
<p>The doctor command should now show that Claude Code configuration is found and prompts are loading correctly.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">Whatâ€™s Next?</a></h2>
<p>Now that you have SwissArmyHammer set up, you can:</p>
<ol>
<li><strong>Explore built-in prompts</strong> - See whatâ€™s available out of the box</li>
<li><strong>Create more prompts</strong> - Build your own prompt library</li>
<li><strong>Learn advanced features</strong> - Template variables, prompt organization, etc.</li>
</ol>
<h3 id="recommended-next-steps"><a class="header" href="#recommended-next-steps">Recommended Next Steps</a></h3>
<ul>
<li><a href="./first-prompt.html">Create Your First Custom Prompt</a></li>
<li><a href="./template-variables.html">Learn about Template Variables</a></li>
<li><a href="./builtin-prompts.html">Explore Built-in Prompts</a></li>
<li><a href="./advanced-prompts.html">Advanced Prompt Techniques</a></li>
</ul>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<p>If something isnâ€™t working:</p>
<ol>
<li><strong>Run the doctor</strong>: <code>swissarmyhammer doctor</code></li>
<li><strong>Check Claude Code logs</strong>: Look for any error messages</li>
<li><strong>Verify file permissions</strong>: Make sure SwissArmyHammer can read your prompt files</li>
<li><strong>Restart Claude Code</strong>: Sometimes a restart is needed after configuration changes</li>
</ol>
<p>For more detailed troubleshooting, see the <a href="./troubleshooting.html">Troubleshooting</a> guide.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you need help:</p>
<ul>
<li>Check the <a href="./troubleshooting.html">Troubleshooting</a> guide</li>
<li>Look at <a href="./examples.html">Examples</a> for inspiration</li>
<li>Ask questions in <a href="https://github.com/wballard/swissarmyhammer/discussions">GitHub Discussions</a></li>
<li>Report bugs in <a href="https://github.com/wballard/swissarmyhammer/issues">GitHub Issues</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-prompt"><a class="header" href="#your-first-prompt">Your First Prompt</a></h1>
<p>Letâ€™s create your first custom prompt with SwissArmyHammer! This guide will walk you through creating a useful code review prompt.</p>
<h2 id="understanding-prompt-structure"><a class="header" href="#understanding-prompt-structure">Understanding Prompt Structure</a></h2>
<p>SwissArmyHammer prompts are markdown files with YAML front matter. Hereâ€™s the basic structure:</p>
<pre><code class="language-markdown">---
title: Your Prompt Title
description: What this prompt does
arguments:
  - name: argument_name
    description: What this argument is for
    required: true/false
    default: "optional default value"
---

# Your Prompt Content

Use {{argument_name}} to insert variables into your prompt.
</code></pre>
<h2 id="creating-a-code-review-prompt"><a class="header" href="#creating-a-code-review-prompt">Creating a Code Review Prompt</a></h2>
<p>Letâ€™s create a practical code review prompt step by step.</p>
<h3 id="step-1-create-the-file"><a class="header" href="#step-1-create-the-file">Step 1: Create the File</a></h3>
<p>First, create a new prompt file in your prompts directory:</p>
<pre><code class="language-bash"># Create the file
touch ~/.swissarmyhammer/prompts/code-review.md

# Or create a category directory
mkdir -p ~/.swissarmyhammer/prompts/development
touch ~/.swissarmyhammer/prompts/development/code-review.md
</code></pre>
<h3 id="step-2-add-the-yaml-front-matter"><a class="header" href="#step-2-add-the-yaml-front-matter">Step 2: Add the YAML Front Matter</a></h3>
<p>Open the file in your favorite editor and add the front matter:</p>
<pre><code class="language-yaml">---
title: Code Review Assistant
description: Comprehensive code review with focus on best practices, security, and performance
arguments:
  - name: code
    description: The code to review (can be a function, class, or entire file)
    required: true
  - name: language
    description: Programming language (helps with language-specific advice)
    required: false
    default: "auto-detect"
  - name: focus
    description: Areas to focus on (security, performance, readability, etc.)
    required: false
    default: "general best practices"
---
</code></pre>
<h3 id="step-3-write-the-prompt-content"><a class="header" href="#step-3-write-the-prompt-content">Step 3: Write the Prompt Content</a></h3>
<p>Below the front matter, add the prompt content:</p>
<pre><code class="language-markdown"># Code Review

I need a thorough code review for the following {{language}} code.

## Code to Review

```{{language}}
{{code}}
</code></pre>
<h2 id="review-focus"><a class="header" href="#review-focus">Review Focus</a></h2>
<p>Please focus on: {{focus}}</p>
<h2 id="review-criteria"><a class="header" href="#review-criteria">Review Criteria</a></h2>
<p>Please analyze the code for:</p>
<h3 id="-security"><a class="header" href="#-security">ğŸ”’ Security</a></h3>
<ul>
<li>Potential security vulnerabilities</li>
<li>Input validation issues</li>
<li>Authentication/authorization concerns</li>
</ul>
<h3 id="-performance"><a class="header" href="#-performance">ğŸš€ Performance</a></h3>
<ul>
<li>Inefficient algorithms or operations</li>
<li>Memory usage concerns</li>
<li>Potential bottlenecks</li>
</ul>
<h3 id="-readability--maintainability"><a class="header" href="#-readability--maintainability">ğŸ“– Readability &amp; Maintainability</a></h3>
<ul>
<li>Code clarity and organization</li>
<li>Naming conventions</li>
<li>Documentation needs</li>
</ul>
<h3 id="-testing--reliability"><a class="header" href="#-testing--reliability">ğŸ§ª Testing &amp; Reliability</a></h3>
<ul>
<li>Error handling</li>
<li>Edge cases</li>
<li>Testability</li>
</ul>
<h3 id="-architecture--design"><a class="header" href="#-architecture--design">ğŸ—ï¸ Architecture &amp; Design</a></h3>
<ul>
<li>SOLID principles adherence</li>
<li>Design patterns usage</li>
<li>Code structure</li>
</ul>
<h2 id="output-format"><a class="header" href="#output-format">Output Format</a></h2>
<p>Please provide:</p>
<ol>
<li><strong>Overall Assessment</strong> - Brief summary of code quality</li>
<li><strong>Specific Issues</strong> - List each issue with:
<ul>
<li>Severity (High/Medium/Low)</li>
<li>Location (line numbers if applicable)</li>
<li>Explanation of the problem</li>
<li>Suggested fix</li>
</ul>
</li>
<li><strong>Positive Aspects</strong> - Whatâ€™s done well</li>
<li><strong>Recommendations</strong> - Broader suggestions for improvement</li>
</ol>
<p>Focus especially on {{focus}} in your analysis.</p>
<pre><code>
### Step 4: Complete File Example

Here's the complete prompt file:

```markdown
---
title: Code Review Assistant
description: Comprehensive code review with focus on best practices, security, and performance
arguments:
  - name: code
    description: The code to review (can be a function, class, or entire file)
    required: true
  - name: language
    description: Programming language (helps with language-specific advice)
    required: false
    default: "auto-detect"
  - name: focus
    description: Areas to focus on (security, performance, readability, etc.)
    required: false
    default: "general best practices"
---

# Code Review

I need a thorough code review for the following {{language}} code.

## Code to Review

```{{language}}
{{code}}
</code></pre>
<h2 id="review-focus-1"><a class="header" href="#review-focus-1">Review Focus</a></h2>
<p>Please focus on: {{focus}}</p>
<h2 id="review-criteria-1"><a class="header" href="#review-criteria-1">Review Criteria</a></h2>
<p>Please analyze the code for:</p>
<h3 id="-security-1"><a class="header" href="#-security-1">ğŸ”’ Security</a></h3>
<ul>
<li>Potential security vulnerabilities</li>
<li>Input validation issues</li>
<li>Authentication/authorization concerns</li>
</ul>
<h3 id="-performance-1"><a class="header" href="#-performance-1">ğŸš€ Performance</a></h3>
<ul>
<li>Inefficient algorithms or operations</li>
<li>Memory usage concerns</li>
<li>Potential bottlenecks</li>
</ul>
<h3 id="-readability--maintainability-1"><a class="header" href="#-readability--maintainability-1">ğŸ“– Readability &amp; Maintainability</a></h3>
<ul>
<li>Code clarity and organization</li>
<li>Naming conventions</li>
<li>Documentation needs</li>
</ul>
<h3 id="-testing--reliability-1"><a class="header" href="#-testing--reliability-1">ğŸ§ª Testing &amp; Reliability</a></h3>
<ul>
<li>Error handling</li>
<li>Edge cases</li>
<li>Testability</li>
</ul>
<h3 id="-architecture--design-1"><a class="header" href="#-architecture--design-1">ğŸ—ï¸ Architecture &amp; Design</a></h3>
<ul>
<li>SOLID principles adherence</li>
<li>Design patterns usage</li>
<li>Code structure</li>
</ul>
<h2 id="output-format-1"><a class="header" href="#output-format-1">Output Format</a></h2>
<p>Please provide:</p>
<ol>
<li><strong>Overall Assessment</strong> - Brief summary of code quality</li>
<li><strong>Specific Issues</strong> - List each issue with:
<ul>
<li>Severity (High/Medium/Low)</li>
<li>Location (line numbers if applicable)</li>
<li>Explanation of the problem</li>
<li>Suggested fix</li>
</ul>
</li>
<li><strong>Positive Aspects</strong> - Whatâ€™s done well</li>
<li><strong>Recommendations</strong> - Broader suggestions for improvement</li>
</ol>
<p>Focus especially on {{focus}} in your analysis.</p>
<pre><code>
## Step 5: Test Your Prompt

Save the file and test that SwissArmyHammer can load it:

```bash
# Check if your prompt loads correctly
swissarmyhammer doctor
</code></pre>
<p>The doctor command will validate your YAML syntax and confirm the prompt is loaded.</p>
<h2 id="step-6-use-your-prompt"><a class="header" href="#step-6-use-your-prompt">Step 6: Use Your Prompt</a></h2>
<ol>
<li><strong>Open Claude Code</strong></li>
<li><strong>Start a new conversation</strong></li>
<li><strong>Look for your prompt</strong> in the prompt picker - it should appear as â€œCode Review Assistantâ€</li>
<li><strong>Fill in the parameters</strong>:
<ul>
<li><code>code</code>: Paste some code you want reviewed</li>
<li><code>language</code>: Specify the programming language (optional)</li>
<li><code>focus</code>: Specify what to focus on (optional)</li>
</ul>
</li>
</ol>
<h2 id="understanding-what-happened"><a class="header" href="#understanding-what-happened">Understanding What Happened</a></h2>
<p>When you created this prompt, SwissArmyHammer:</p>
<ol>
<li><strong>Detected the new file</strong> using its file watcher</li>
<li><strong>Parsed the YAML front matter</strong> to understand the prompt structure</li>
<li><strong>Made it available</strong> to Claude Code via the MCP protocol</li>
<li><strong>Prepared for template substitution</strong> when the prompt is used</li>
</ol>
<h2 id="best-practices-for-your-first-prompt"><a class="header" href="#best-practices-for-your-first-prompt">Best Practices for Your First Prompt</a></h2>
<h3 id="-dos"><a class="header" href="#-dos">âœ… Doâ€™s</a></h3>
<ul>
<li><strong>Use descriptive titles and descriptions</strong></li>
<li><strong>Document your arguments clearly</strong></li>
<li><strong>Provide sensible defaults</strong> for optional arguments</li>
<li><strong>Structure your prompt content</strong> with clear sections</li>
<li><strong>Use template variables</strong> to make prompts flexible</li>
</ul>
<h3 id="-donts"><a class="header" href="#-donts">âŒ Donâ€™ts</a></h3>
<ul>
<li><strong>Donâ€™t use required arguments unless necessary</strong></li>
<li><strong>Donâ€™t make prompts too rigid</strong> - allow for flexibility</li>
<li><strong>Donâ€™t forget to test</strong> your YAML syntax</li>
<li><strong>Donâ€™t use overly complex template logic</strong> in your first prompts</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that youâ€™ve created your first prompt, you can:</p>
<ol>
<li><strong>Create more prompts</strong> for different use cases</li>
<li><strong>Organize prompts</strong> into directories by category</li>
<li><strong>Learn advanced template features</strong> like conditionals and loops</li>
<li><strong>Share prompts</strong> with your team or the community</li>
</ol>
<h3 id="recommended-reading"><a class="header" href="#recommended-reading">Recommended Reading</a></h3>
<ul>
<li><a href="./creating-prompts.html">Creating Prompts</a> - Comprehensive guide to prompt creation</li>
<li><a href="./template-variables.html">Template Variables</a> - Advanced template features</li>
<li><a href="./prompt-organization.html">Prompt Organization</a> - How to organize your prompt library</li>
<li><a href="./builtin-prompts.html">Built-in Prompts</a> - Examples from the built-in library</li>
</ul>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<p>If your prompt isnâ€™t working:</p>
<ol>
<li><strong>Check YAML syntax</strong> - Make sure your front matter is valid YAML</li>
<li><strong>Run doctor</strong> - <code>swissarmyhammer doctor</code> will catch common issues</li>
<li><strong>Check file permissions</strong> - Make sure SwissArmyHammer can read the file</li>
<li><strong>Restart Claude Code</strong> - Sometimes needed after creating new prompts</li>
</ol>
<p>Common issues:</p>
<ul>
<li><strong>YAML indentation errors</strong> - Use spaces, not tabs</li>
<li><strong>Missing required fields</strong> - Title and description are required</li>
<li><strong>Invalid argument structure</strong> - Check the argument format</li>
<li><strong>File encoding</strong> - Use UTF-8 encoding for your markdown files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-prompts"><a class="header" href="#creating-prompts">Creating Prompts</a></h1>
<p>SwissArmyHammer prompts are markdown files with YAML front matter that define reusable AI prompts. This guide walks you through creating effective prompts.</p>
<h2 id="basic-structure"><a class="header" href="#basic-structure">Basic Structure</a></h2>
<p>Every prompt file has two parts:</p>
<ol>
<li><strong>YAML Front Matter</strong> - Metadata about the prompt</li>
<li><strong>Markdown Content</strong> - The actual prompt template</li>
</ol>
<pre><code class="language-markdown">---
name: my-prompt
title: My Awesome Prompt
description: Does something useful
arguments:
  - name: input
    description: What to process
    required: true
---

# My Prompt

Please help me with {{input}}.

Provide a detailed response.
</code></pre>
<h2 id="yaml-front-matter"><a class="header" href="#yaml-front-matter">YAML Front Matter</a></h2>
<p>The YAML front matter defines the promptâ€™s metadata:</p>
<h3 id="required-fields"><a class="header" href="#required-fields">Required Fields</a></h3>
<ul>
<li><code>name</code> - Unique identifier for the prompt</li>
<li><code>title</code> - Human-readable name</li>
<li><code>description</code> - What the prompt does</li>
</ul>
<h3 id="optional-fields"><a class="header" href="#optional-fields">Optional Fields</a></h3>
<ul>
<li><code>category</code> - Group related prompts (e.g., â€œdevelopmentâ€, â€œwritingâ€)</li>
<li><code>tags</code> - List of keywords for discovery</li>
<li><code>arguments</code> - Input parameters (see <a href="creating-prompts.html#arguments">Arguments</a>)</li>
<li><code>author</code> - Prompt creator</li>
<li><code>version</code> - Version number</li>
<li><code>license</code> - License information</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-yaml">---
name: code-review
title: Code Review Assistant
description: Reviews code for best practices, bugs, and improvements
category: development
tags: ["code", "review", "quality", "best-practices"]
author: SwissArmyHammer Team
version: 1.0.0
arguments:
  - name: code
    description: The code to review
    required: true
  - name: language
    description: Programming language
    required: false
    default: auto-detect
  - name: focus
    description: Specific areas to focus on
    required: false
    default: all aspects
---
</code></pre>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<p>Arguments define the inputs your prompt accepts. Each argument has:</p>
<h3 id="argument-properties"><a class="header" href="#argument-properties">Argument Properties</a></h3>
<ul>
<li><code>name</code> - Parameter name (used in template as <code>{{name}}</code>)</li>
<li><code>description</code> - What this parameter is for</li>
<li><code>required</code> - Whether the argument is mandatory</li>
<li><code>default</code> - Default value if not provided</li>
<li><code>type_hint</code> - Expected data type (documentation only)</li>
</ul>
<h3 id="example-arguments"><a class="header" href="#example-arguments">Example Arguments</a></h3>
<pre><code class="language-yaml">arguments:
  - name: text
    description: Text to analyze
    required: true
    type_hint: string
  
  - name: format
    description: Output format
    required: false
    default: markdown
    type_hint: string
  
  - name: max_length
    description: Maximum response length
    required: false
    default: 500
    type_hint: integer
  
  - name: include_examples
    description: Include code examples
    required: false
    default: true
    type_hint: boolean
</code></pre>
<h2 id="template-content"><a class="header" href="#template-content">Template Content</a></h2>
<p>The markdown content is your prompt template using <a href="./template-variables.html">Liquid templating</a>.</p>
<h3 id="basic-variables"><a class="header" href="#basic-variables">Basic Variables</a></h3>
<p>Use <code>{{variable}}</code> to insert argument values:</p>
<pre><code class="language-markdown">Please review this {{language}} code:

```{{code}}```

Focus on {{focus}}.
</code></pre>
<h3 id="conditional-logic"><a class="header" href="#conditional-logic">Conditional Logic</a></h3>
<p>Use <code>{% if %}</code> blocks for conditional content:</p>
<pre><code class="language-markdown">{% if language == "python" %}
Pay special attention to:
- PEP 8 style guidelines
- Type hints
- Error handling
{% elsif language == "javascript" %}
Pay special attention to:
- ESLint rules
- Async/await usage
- Error handling
{% endif %}
</code></pre>
<h3 id="loops"><a class="header" href="#loops">Loops</a></h3>
<p>Use <code>{% for %}</code> to iterate over lists:</p>
<pre><code class="language-markdown">{% if tags %}
Tags: {% for tag in tags %}#{{tag}}{% unless forloop.last %}, {% endunless %}{% endfor %}
{% endif %}
</code></pre>
<h3 id="filters"><a class="header" href="#filters">Filters</a></h3>
<p>Apply filters to transform data:</p>
<pre><code class="language-markdown">Language: {{language | capitalize}}
Code length: {{code | length}} characters
Summary: {{description | truncate: 100}}
</code></pre>
<h2 id="organization"><a class="header" href="#organization">Organization</a></h2>
<h3 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h3>
<p>Organize prompts in logical directories:</p>
<pre><code>prompts/
â”œâ”€â”€ development/
â”‚   â”œâ”€â”€ code-review.md
â”‚   â”œâ”€â”€ debug-helper.md
â”‚   â””â”€â”€ api-docs.md
â”œâ”€â”€ writing/
â”‚   â”œâ”€â”€ blog-post.md
â”‚   â”œâ”€â”€ email-draft.md
â”‚   â””â”€â”€ summary.md
â””â”€â”€ analysis/
    â”œâ”€â”€ data-insights.md
    â””â”€â”€ competitor-analysis.md
</code></pre>
<h3 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h3>
<ul>
<li>Use kebab-case for filenames: <code>code-review.md</code></li>
<li>Make names descriptive: <code>debug-python-errors.md</code> not <code>debug.md</code></li>
<li>Include the category in the path, not the filename</li>
</ul>
<h3 id="categories-and-tags"><a class="header" href="#categories-and-tags">Categories and Tags</a></h3>
<p>Use categories for broad groupings:</p>
<ul>
<li><code>development</code> - Code-related prompts</li>
<li><code>writing</code> - Content creation</li>
<li><code>analysis</code> - Data and research</li>
<li><code>productivity</code> - Task management</li>
</ul>
<p>Use tags for specific features:</p>
<ul>
<li><code>["python", "debugging", "error-handling"]</code></li>
<li><code>["marketing", "email", "b2b"]</code></li>
<li><code>["data", "visualization", "charts"]</code></li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-write-clear-descriptions"><a class="header" href="#1-write-clear-descriptions">1. Write Clear Descriptions</a></h3>
<pre><code class="language-yaml"># Good
description: Reviews Python code for PEP 8 compliance, type hints, and common bugs

# Bad
description: Code review
</code></pre>
<h3 id="2-provide-helpful-defaults"><a class="header" href="#2-provide-helpful-defaults">2. Provide Helpful Defaults</a></h3>
<pre><code class="language-yaml">arguments:
  - name: style_guide
    description: Coding style guide to follow
    required: false
    default: PEP 8  # Sensible default
</code></pre>
<h3 id="3-use-descriptive-variable-names"><a class="header" href="#3-use-descriptive-variable-names">3. Use Descriptive Variable Names</a></h3>
<pre><code class="language-markdown"># Good
Please analyze this {{source_code}} for {{security_vulnerabilities}}.

# Bad
Please analyze this {{input}} for {{stuff}}.
</code></pre>
<h3 id="4-include-examples-in-descriptions"><a class="header" href="#4-include-examples-in-descriptions">4. Include Examples in Descriptions</a></h3>
<pre><code class="language-yaml">arguments:
  - name: format
    description: Output format (markdown, json, html)
    required: false
    default: markdown
</code></pre>
<h3 id="5-structure-your-prompts"><a class="header" href="#5-structure-your-prompts">5. Structure Your Prompts</a></h3>
<p>Use clear sections and formatting:</p>
<pre><code class="language-markdown"># Code Review

## Overview
Please review the following {{language}} code for:

## Focus Areas
1. **Best Practices** - Follow {{style_guide}} guidelines
2. **Security** - Identify potential vulnerabilities
3. **Performance** - Suggest optimizations
4. **Maintainability** - Assess code clarity

## Code to Review

```{{code}}```

## Instructions
{{#if include_suggestions}}
Please provide specific improvement suggestions.
{{/if}}
</code></pre>
<h3 id="6-test-your-prompts"><a class="header" href="#6-test-your-prompts">6. Test Your Prompts</a></h3>
<p>Use the CLI to test prompts:</p>
<pre><code class="language-bash"># Test with required arguments
swissarmyhammer test code-review --code "def hello(): print('hi')" --language python

# Test with defaults
swissarmyhammer test code-review --code "function hello() { console.log('hi'); }"
</code></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="code-analysis"><a class="header" href="#code-analysis">Code Analysis</a></h3>
<pre><code class="language-markdown">---
name: analyze-code
title: Code Analyzer
description: Analyzes code for issues and improvements
arguments:
  - name: code
    description: Code to analyze
    required: true
  - name: language
    description: Programming language
    required: false
    default: auto-detect
---

# Code Analysis

Analyze this {{language}} code:

```{{code}}```

Provide feedback on:
- Code quality and best practices
- Potential bugs or issues
- Performance optimizations
- Readability improvements
</code></pre>
<h3 id="document-generation"><a class="header" href="#document-generation">Document Generation</a></h3>
<pre><code class="language-markdown">---
name: api-docs
title: API Documentation Generator
description: Generates API documentation from code
arguments:
  - name: code
    description: API code to document
    required: true
  - name: format
    description: Documentation format
    required: false
    default: markdown
---

# API Documentation

Generate {{format}} documentation for this API:

```{{code}}```

Include:
- Endpoint descriptions
- Parameter details
- Response examples
- Error codes
</code></pre>
<h3 id="text-processing"><a class="header" href="#text-processing">Text Processing</a></h3>
<pre><code class="language-markdown">---
name: summarize
title: Text Summarizer
description: Creates concise summaries of text
arguments:
  - name: text
    description: Text to summarize
    required: true
  - name: length
    description: Target summary length
    required: false
    default: 3 sentences
---

# Text Summary

Create a {{length}} summary of this text:

{{text}}

Focus on the key points and main ideas.
</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li>Learn about <a href="./yaml-front-matter.html">YAML Front Matter</a> in detail</li>
<li>Explore <a href="./template-variables.html">Template Variables</a> and Liquid syntax</li>
<li>Check out <a href="./custom-filters.html">Custom Filters</a> for advanced transformations</li>
<li>See <a href="./examples.html">Examples</a> for real-world prompt templates</li>
<li>Read about <a href="./prompt-organization.html">Prompt Organization</a> strategies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yaml-front-matter-1"><a class="header" href="#yaml-front-matter-1">YAML Front Matter</a></h1>
<p>YAML front matter is the metadata section at the beginning of each prompt file. It defines the promptâ€™s properties, arguments, and other configuration details.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Front matter appears between triple dashes (<code>---</code>) at the start of your markdown file:</p>
<pre><code class="language-markdown">---
name: my-prompt
title: My Prompt
description: What this prompt does
---

# Prompt content starts here
</code></pre>
<h2 id="required-fields-1"><a class="header" href="#required-fields-1">Required Fields</a></h2>
<p>Every prompt must have these fields:</p>
<h3 id="name"><a class="header" href="#name"><code>name</code></a></h3>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: Unique identifier for the prompt</li>
<li><strong>Format</strong>: kebab-case recommended</li>
<li><strong>Example</strong>: <code>code-review</code>, <code>debug-helper</code>, <code>api-docs</code></li>
</ul>
<pre><code class="language-yaml">name: code-review
</code></pre>
<h3 id="title"><a class="header" href="#title"><code>title</code></a></h3>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: Human-readable name displayed in UIs</li>
<li><strong>Format</strong>: Title Case</li>
<li><strong>Example</strong>: <code>Code Review Assistant</code>, <code>Debug Helper</code></li>
</ul>
<pre><code class="language-yaml">title: Code Review Assistant
</code></pre>
<h3 id="description"><a class="header" href="#description"><code>description</code></a></h3>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: Brief explanation of what the prompt does</li>
<li><strong>Format</strong>: Sentence or short paragraph</li>
<li><strong>Example</strong>: Clear, actionable description</li>
</ul>
<pre><code class="language-yaml">description: Reviews code for best practices, bugs, and potential improvements
</code></pre>
<h2 id="optional-fields-1"><a class="header" href="#optional-fields-1">Optional Fields</a></h2>
<h3 id="category"><a class="header" href="#category"><code>category</code></a></h3>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: Groups related prompts together</li>
<li><strong>Common Values</strong>: <code>development</code>, <code>writing</code>, <code>analysis</code>, <code>productivity</code></li>
</ul>
<pre><code class="language-yaml">category: development
</code></pre>
<h3 id="tags"><a class="header" href="#tags"><code>tags</code></a></h3>
<ul>
<li><strong>Type</strong>: Array of strings</li>
<li><strong>Description</strong>: Keywords for discovery and filtering</li>
<li><strong>Format</strong>: Lowercase, descriptive terms</li>
</ul>
<pre><code class="language-yaml">tags: ["python", "debugging", "error-handling"]
</code></pre>
<h3 id="arguments-1"><a class="header" href="#arguments-1"><code>arguments</code></a></h3>
<ul>
<li><strong>Type</strong>: Array of argument objects</li>
<li><strong>Description</strong>: Input parameters the prompt accepts</li>
<li><strong>See</strong>: <a href="yaml-front-matter.html#arguments">Arguments section</a> below</li>
</ul>
<pre><code class="language-yaml">arguments:
  - name: code
    description: Code to review
    required: true
</code></pre>
<h3 id="author"><a class="header" href="#author"><code>author</code></a></h3>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: Creator of the prompt</li>
<li><strong>Format</strong>: Name or organization</li>
</ul>
<pre><code class="language-yaml">author: SwissArmyHammer Team
</code></pre>
<h3 id="version"><a class="header" href="#version"><code>version</code></a></h3>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: Version number for tracking changes</li>
<li><strong>Format</strong>: Semantic versioning recommended</li>
</ul>
<pre><code class="language-yaml">version: 1.2.0
</code></pre>
<h3 id="license-1"><a class="header" href="#license-1"><code>license</code></a></h3>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: License for the prompt</li>
<li><strong>Common Values</strong>: <code>MIT</code>, <code>Apache-2.0</code>, <code>GPL-3.0</code></li>
</ul>
<pre><code class="language-yaml">license: MIT
</code></pre>
<h3 id="created"><a class="header" href="#created"><code>created</code></a></h3>
<ul>
<li><strong>Type</strong>: Date string</li>
<li><strong>Description</strong>: When the prompt was created</li>
<li><strong>Format</strong>: ISO 8601 date</li>
</ul>
<pre><code class="language-yaml">created: 2024-01-15
</code></pre>
<h3 id="updated"><a class="header" href="#updated"><code>updated</code></a></h3>
<ul>
<li><strong>Type</strong>: Date string</li>
<li><strong>Description</strong>: Last modification date</li>
<li><strong>Format</strong>: ISO 8601 date</li>
</ul>
<pre><code class="language-yaml">updated: 2024-03-20
</code></pre>
<h3 id="keywords"><a class="header" href="#keywords"><code>keywords</code></a></h3>
<ul>
<li><strong>Type</strong>: Array of strings</li>
<li><strong>Description</strong>: Alternative to tags for SEO/discovery</li>
<li><strong>Note</strong>: Similar to tags but more formal</li>
</ul>
<pre><code class="language-yaml">keywords: ["code quality", "static analysis", "best practices"]
</code></pre>
<h2 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h2>
<p>Arguments define the inputs your prompt can accept. Each argument is an object with these properties:</p>
<h3 id="argument-properties-1"><a class="header" href="#argument-properties-1">Argument Properties</a></h3>
<h4 id="name-required"><a class="header" href="#name-required"><code>name</code> (required)</a></h4>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: Parameter name used in template</li>
<li><strong>Format</strong>: snake_case or kebab-case</li>
<li><strong>Usage</strong>: Referenced as <code>{{name}}</code> in template</li>
</ul>
<pre><code class="language-yaml">arguments:
  - name: source_code
    # Used as {{source_code}} in template
</code></pre>
<h4 id="description-required"><a class="header" href="#description-required"><code>description</code> (required)</a></h4>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: What this argument is for</li>
<li><strong>Format</strong>: Clear, helpful explanation</li>
</ul>
<pre><code class="language-yaml">arguments:
  - name: language
    description: Programming language of the code
</code></pre>
<h4 id="required-optional-default-false"><a class="header" href="#required-optional-default-false"><code>required</code> (optional, default: false)</a></h4>
<ul>
<li><strong>Type</strong>: Boolean</li>
<li><strong>Description</strong>: Whether this argument must be provided</li>
<li><strong>Default</strong>: <code>false</code></li>
</ul>
<pre><code class="language-yaml">arguments:
  - name: code
    description: Code to analyze
    required: true  # Must be provided
  - name: style_guide
    description: Coding style to follow
    required: false  # Optional
</code></pre>
<h4 id="default-optional"><a class="header" href="#default-optional"><code>default</code> (optional)</a></h4>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: Default value if not provided</li>
<li><strong>Note</strong>: Only used when <code>required: false</code></li>
</ul>
<pre><code class="language-yaml">arguments:
  - name: format
    description: Output format
    required: false
    default: markdown
</code></pre>
<h4 id="type_hint-optional"><a class="header" href="#type_hint-optional"><code>type_hint</code> (optional)</a></h4>
<ul>
<li><strong>Type</strong>: String</li>
<li><strong>Description</strong>: Expected data type (documentation only)</li>
<li><strong>Common Values</strong>: <code>string</code>, <code>integer</code>, <code>boolean</code>, <code>array</code>, <code>object</code></li>
</ul>
<pre><code class="language-yaml">arguments:
  - name: max_length
    description: Maximum output length
    required: false
    default: 500
    type_hint: integer
</code></pre>
<h3 id="argument-examples"><a class="header" href="#argument-examples">Argument Examples</a></h3>
<h4 id="simple-text-input"><a class="header" href="#simple-text-input">Simple Text Input</a></h4>
<pre><code class="language-yaml">arguments:
  - name: text
    description: Text to process
    required: true
    type_hint: string
</code></pre>
<h4 id="optional-with-default"><a class="header" href="#optional-with-default">Optional with Default</a></h4>
<pre><code class="language-yaml">arguments:
  - name: format
    description: Output format (markdown, json, html)
    required: false
    default: markdown
    type_hint: string
</code></pre>
<h4 id="boolean-flag"><a class="header" href="#boolean-flag">Boolean Flag</a></h4>
<pre><code class="language-yaml">arguments:
  - name: include_examples
    description: Include code examples in output
    required: false
    default: true
    type_hint: boolean
</code></pre>
<h4 id="multiple-arguments"><a class="header" href="#multiple-arguments">Multiple Arguments</a></h4>
<pre><code class="language-yaml">arguments:
  - name: code
    description: Source code to review
    required: true
    type_hint: string
  
  - name: language
    description: Programming language
    required: false
    default: auto-detect
    type_hint: string
    
  - name: severity
    description: Minimum issue severity to report
    required: false
    default: medium
    type_hint: string
    
  - name: include_suggestions
    description: Include improvement suggestions
    required: false
    default: true
    type_hint: boolean
</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Hereâ€™s a comprehensive example showing all available fields:</p>
<pre><code class="language-yaml">---
name: comprehensive-code-review
title: Comprehensive Code Review Assistant
description: Performs detailed code review focusing on best practices, security, and performance
category: development
tags: ["code-review", "security", "performance", "best-practices"]
author: SwissArmyHammer Team
version: 2.1.0
license: MIT
created: 2024-01-15
updated: 2024-03-20
keywords: ["static analysis", "code quality", "security audit"]

arguments:
  - name: code
    description: Source code to review
    required: true
    type_hint: string
    
  - name: language
    description: Programming language (python, javascript, rust, etc.)
    required: false
    default: auto-detect
    type_hint: string
    
  - name: focus_areas
    description: Specific areas to focus on (security, performance, style)
    required: false
    default: all
    type_hint: string
    
  - name: severity_threshold
    description: Minimum severity level to report (low, medium, high)
    required: false
    default: medium
    type_hint: string
    
  - name: include_examples
    description: Include code examples in suggestions
    required: false
    default: true
    type_hint: boolean
    
  - name: max_suggestions
    description: Maximum number of suggestions to provide
    required: false
    default: 10
    type_hint: integer
---

# Comprehensive Code Review

I'll perform a detailed review of your {{language}} code, focusing on {{focus_areas}}.

## Code Analysis

```{{code}}```

## Review Criteria

I'll evaluate the code for:

{% if focus_areas contains "security" or focus_areas == "all" %}
- **Security vulnerabilities** and best practices
{% endif %}

{% if focus_areas contains "performance" or focus_areas == "all" %}
- **Performance optimizations** and efficiency
{% endif %}

{% if focus_areas contains "style" or focus_areas == "all" %}
- **Code style** and formatting consistency
{% endif %}

{% if language != "auto-detect" %}
- **{{language | capitalize}}-specific** best practices and idioms
{% endif %}

## Reporting

- Minimum severity: {{severity_threshold}}
- Maximum suggestions: {{max_suggestions}}
{% if include_examples %}
- Including code examples and fixes
{% endif %}

Please provide detailed feedback with specific line references where applicable.
</code></pre>
<h2 id="validation-rules"><a class="header" href="#validation-rules">Validation Rules</a></h2>
<p>SwissArmyHammer validates your YAML front matter:</p>
<h3 id="required-field-validation"><a class="header" href="#required-field-validation">Required Field Validation</a></h3>
<ul>
<li><code>name</code>, <code>title</code>, and <code>description</code> must be present</li>
<li><code>name</code> must be unique within the prompt library</li>
<li><code>name</code> must not contain spaces or special characters</li>
</ul>
<h3 id="argument-validation"><a class="header" href="#argument-validation">Argument Validation</a></h3>
<ul>
<li>Each argument must have <code>name</code> and <code>description</code></li>
<li>Argument names must be valid template variables</li>
<li>Required arguments cannot have default values</li>
<li>Argument names must be unique within the prompt</li>
</ul>
<h3 id="type-validation"><a class="header" href="#type-validation">Type Validation</a></h3>
<ul>
<li>Arrays must contain valid elements</li>
<li>Dates must be in ISO format</li>
<li>Booleans must be <code>true</code> or <code>false</code></li>
</ul>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="1-use-descriptive-names"><a class="header" href="#1-use-descriptive-names">1. Use Descriptive Names</a></h3>
<pre><code class="language-yaml"># Good
name: python-code-review
title: Python Code Review Assistant

# Bad
name: review
title: Review
</code></pre>
<h3 id="2-write-clear-descriptions"><a class="header" href="#2-write-clear-descriptions">2. Write Clear Descriptions</a></h3>
<pre><code class="language-yaml"># Good
description: Analyzes Python code for PEP 8 compliance, type hints, security issues, and performance optimizations

# Bad
description: Reviews code
</code></pre>
<h3 id="3-organize-with-categories-and-tags"><a class="header" href="#3-organize-with-categories-and-tags">3. Organize with Categories and Tags</a></h3>
<pre><code class="language-yaml">category: development
tags: ["python", "pep8", "security", "performance", "code-quality"]
</code></pre>
<h3 id="4-provide-sensible-defaults"><a class="header" href="#4-provide-sensible-defaults">4. Provide Sensible Defaults</a></h3>
<pre><code class="language-yaml">arguments:
  - name: style_guide
    description: Python style guide to follow
    required: false
    default: PEP 8  # Most common choice
</code></pre>
<h3 id="5-use-type-hints"><a class="header" href="#5-use-type-hints">5. Use Type Hints</a></h3>
<pre><code class="language-yaml">arguments:
  - name: max_issues
    description: Maximum number of issues to report
    required: false
    default: 20
    type_hint: integer  # Helps users understand expected format
</code></pre>
<h3 id="6-keep-versions-updated"><a class="header" href="#6-keep-versions-updated">6. Keep Versions Updated</a></h3>
<pre><code class="language-yaml">version: 1.2.0  # Update when you make changes
updated: 2024-03-20  # Track modification date
</code></pre>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="code-processing-prompt"><a class="header" href="#code-processing-prompt">Code Processing Prompt</a></h3>
<pre><code class="language-yaml">---
name: code-processor
title: Code Processor
description: Processes and transforms code
category: development
arguments:
  - name: code
    description: Source code to process
    required: true
  - name: language
    description: Programming language
    required: false
    default: auto-detect
  - name: output_format
    description: Desired output format
    required: false
    default: markdown
---
</code></pre>
<h3 id="text-analysis-prompt"><a class="header" href="#text-analysis-prompt">Text Analysis Prompt</a></h3>
<pre><code class="language-yaml">---
name: text-analyzer
title: Text Analyzer
description: Analyzes text for various metrics
category: analysis
arguments:
  - name: text
    description: Text to analyze
    required: true
  - name: analysis_type
    description: Type of analysis to perform
    required: false
    default: comprehensive
  - name: include_stats
    description: Include statistical analysis
    required: false
    default: true
    type_hint: boolean
---
</code></pre>
<h3 id="document-generator"><a class="header" href="#document-generator">Document Generator</a></h3>
<pre><code class="language-yaml">---
name: doc-generator
title: Document Generator
description: Generates documentation from code or specifications
category: documentation
arguments:
  - name: source
    description: Source material to document
    required: true
  - name: format
    description: Output format
    required: false
    default: markdown
  - name: include_examples
    description: Include usage examples
    required: false
    default: true
    type_hint: boolean
---
</code></pre>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h3>
<h4 id="invalid-yaml-syntax"><a class="header" href="#invalid-yaml-syntax">Invalid YAML Syntax</a></h4>
<pre><code class="language-yaml"># Error: Missing quotes around string with special characters
description: This won't work: because of the colon

# Fixed: Quote strings with special characters
description: "This works: because it's quoted"
</code></pre>
<h4 id="missing-required-fields"><a class="header" href="#missing-required-fields">Missing Required Fields</a></h4>
<pre><code class="language-yaml"># Error: Missing required fields
title: My Prompt

# Fixed: Include all required fields
name: my-prompt
title: My Prompt
description: What this prompt does
</code></pre>
<h4 id="invalid-argument-structure"><a class="header" href="#invalid-argument-structure">Invalid Argument Structure</a></h4>
<pre><code class="language-yaml"># Error: Missing required argument properties
arguments:
  - name: code

# Fixed: Include required properties
arguments:
  - name: code
    description: Code to process
    required: true
</code></pre>
<h3 id="validation-tips"><a class="header" href="#validation-tips">Validation Tips</a></h3>
<ol>
<li><strong>Use a YAML validator</strong> - Many online tools can check syntax</li>
<li><strong>Test with CLI</strong> - Use <code>swissarmyhammer test</code> to validate prompts</li>
<li><strong>Check the logs</strong> - SwissArmyHammer provides detailed error messages</li>
<li><strong>Start simple</strong> - Begin with minimal front matter and add complexity</li>
</ol>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li>Learn about <a href="./template-variables.html">Template Variables</a> to use your arguments</li>
<li>Explore <a href="./custom-filters.html">Custom Filters</a> for advanced text processing</li>
<li>See <a href="./creating-prompts.html">Creating Prompts</a> for the complete workflow</li>
<li>Check <a href="./examples.html">Examples</a> for real-world YAML configurations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-variables"><a class="header" href="#template-variables">Template Variables</a></h1>
<p>SwissArmyHammer uses the <a href="https://shopify.github.io/liquid/">Liquid template engine</a> for processing prompts. This provides powerful templating features including variables, conditionals, loops, and filters.</p>
<h2 id="basic-variable-substitution"><a class="header" href="#basic-variable-substitution">Basic Variable Substitution</a></h2>
<p>Variables are inserted using double curly braces:</p>
<pre><code class="language-liquid">Hello {{ name }}!
Your email is {{ email }}.
</code></pre>
<p>For backward compatibility, variables without spaces also work:</p>
<pre><code class="language-liquid">Hello {{name}}!
</code></pre>
<h2 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h2>
<h3 id="if-statements"><a class="header" href="#if-statements">If Statements</a></h3>
<p>Use <code>if</code> statements to conditionally include content:</p>
<pre><code class="language-liquid">{% if user_type == "admin" %}
  Welcome, administrator!
{% elsif user_type == "moderator" %}
  Welcome, moderator!
{% else %}
  Welcome, user!
{% endif %}
</code></pre>
<h3 id="unless-statements"><a class="header" href="#unless-statements">Unless Statements</a></h3>
<p><code>unless</code> is the opposite of <code>if</code>:</p>
<pre><code class="language-liquid">{% unless error_count == 0 %}
  Warning: {{ error_count }} errors found.
{% endunless %}
</code></pre>
<h3 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h3>
<ul>
<li><code>==</code> - equals</li>
<li><code>!=</code> - not equals</li>
<li><code>&gt;</code> - greater than</li>
<li><code>&lt;</code> - less than</li>
<li><code>&gt;=</code> - greater or equal</li>
<li><code>&lt;=</code> - less or equal</li>
<li><code>contains</code> - string/array contains</li>
<li><code>and</code> - logical AND</li>
<li><code>or</code> - logical OR</li>
</ul>
<p>Example:</p>
<pre><code class="language-liquid">{% if age &gt;= 18 and country == "US" %}
  You are eligible to vote.
{% endif %}

{% if tags contains "urgent" %}
  ğŸš¨ This is urgent!
{% endif %}
</code></pre>
<h2 id="case-statements"><a class="header" href="#case-statements">Case Statements</a></h2>
<p>For multiple conditions, use <code>case</code>:</p>
<pre><code class="language-liquid">{% case status %}
  {% when "pending" %}
    â³ Waiting for approval
  {% when "approved" %}
    âœ… Approved and ready
  {% when "rejected" %}
    âŒ Rejected
  {% else %}
    â“ Unknown status
{% endcase %}
</code></pre>
<h2 id="loops-1"><a class="header" href="#loops-1">Loops</a></h2>
<h3 id="basic-for-loops"><a class="header" href="#basic-for-loops">Basic For Loops</a></h3>
<p>Iterate over arrays:</p>
<pre><code class="language-liquid">{% for item in items %}
  - {{ item }}
{% endfor %}
</code></pre>
<h3 id="range-loops"><a class="header" href="#range-loops">Range Loops</a></h3>
<p>Loop over a range of numbers:</p>
<pre><code class="language-liquid">{% for i in (1..5) %}
  Step {{ i }} of 5
{% endfor %}
</code></pre>
<h3 id="loop-variables"><a class="header" href="#loop-variables">Loop Variables</a></h3>
<p>Inside loops, you have access to special variables:</p>
<pre><code class="language-liquid">{% for item in items %}
  {% if forloop.first %}First item: {% endif %}
  {{ forloop.index }}. {{ item }}
  {% if forloop.last %}(last item){% endif %}
{% endfor %}
</code></pre>
<p>Available loop variables:</p>
<ul>
<li><code>forloop.index</code> - current iteration (1-based)</li>
<li><code>forloop.index0</code> - current iteration (0-based)</li>
<li><code>forloop.first</code> - true on first iteration</li>
<li><code>forloop.last</code> - true on last iteration</li>
<li><code>forloop.length</code> - total number of items</li>
</ul>
<h3 id="loop-control"><a class="header" href="#loop-control">Loop Control</a></h3>
<p>Use <code>break</code> and <code>continue</code> for flow control:</p>
<pre><code class="language-liquid">{% for item in items %}
  {% if item == "skip" %}
    {% continue %}
  {% endif %}
  {% if item == "stop" %}
    {% break %}
  {% endif %}
  Processing: {{ item }}
{% endfor %}
</code></pre>
<h3 id="cycle"><a class="header" href="#cycle">Cycle</a></h3>
<p>Alternate between values:</p>
<pre><code class="language-liquid">{% for row in data %}
  &lt;tr class="{% cycle 'odd', 'even' %}"&gt;
    &lt;td&gt;{{ row }}&lt;/td&gt;
  &lt;/tr&gt;
{% endfor %}
</code></pre>
<h2 id="filters-1"><a class="header" href="#filters-1">Filters</a></h2>
<p>Filters modify variables using the pipe (<code>|</code>) character:</p>
<h3 id="string-filters"><a class="header" href="#string-filters">String Filters</a></h3>
<pre><code class="language-liquid">{{ name | upcase }}           # ALICE
{{ name | downcase }}         # alice
{{ name | capitalize }}       # Alice
{{ text | strip }}            # removes whitespace
{{ text | truncate: 20 }}     # truncates to 20 chars
{{ text | truncate: 20, "..." }} # custom ellipsis
{{ text | append: "!" }}      # adds to end
{{ text | prepend: "Hello " }} # adds to beginning
{{ text | remove: "bad" }}    # removes all occurrences
{{ text | replace: "old", "new" }} # replaces all
{{ text | split: "," }}       # splits into array
</code></pre>
<h3 id="array-filters"><a class="header" href="#array-filters">Array Filters</a></h3>
<pre><code class="language-liquid">{{ array | first }}           # first element
{{ array | last }}            # last element
{{ array | join: ", " }}      # joins with delimiter
{{ array | sort }}            # sorts array
{{ array | reverse }}         # reverses array
{{ array | size }}            # number of elements
{{ array | uniq }}            # removes duplicates
</code></pre>
<h3 id="math-filters"><a class="header" href="#math-filters">Math Filters</a></h3>
<pre><code class="language-liquid">{{ number | plus: 5 }}        # addition
{{ number | minus: 3 }}       # subtraction
{{ number | times: 2 }}       # multiplication
{{ number | divided_by: 4 }}  # division
{{ number | modulo: 3 }}      # remainder
{{ number | ceil }}           # round up
{{ number | floor }}          # round down
{{ number | round }}          # round to nearest
{{ number | round: 2 }}       # round to 2 decimals
{{ number | abs }}            # absolute value
</code></pre>
<h3 id="default-filter"><a class="header" href="#default-filter">Default Filter</a></h3>
<p>Provide fallback values:</p>
<pre><code class="language-liquid">Hello {{ name | default: "Guest" }}!
Score: {{ score | default: 0 }}
</code></pre>
<h3 id="date-filters"><a class="header" href="#date-filters">Date Filters</a></h3>
<pre><code class="language-liquid">{{ date | date: "%Y-%m-%d" }}         # 2024-01-15
{{ date | date: "%B %d, %Y" }}        # January 15, 2024
{{ "now" | date: "%Y" }}              # current year
</code></pre>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>Comments are not rendered in output:</p>
<pre><code class="language-liquid">{% comment %}
  This is a comment that won't appear in the output.
  Useful for documentation or temporarily disabling code.
{% endcomment %}
</code></pre>
<h3 id="raw-blocks"><a class="header" href="#raw-blocks">Raw Blocks</a></h3>
<p>Prevent Liquid processing:</p>
<pre><code class="language-liquid">{% raw %}
  This {{ variable }} won't be processed.
  Useful for showing Liquid syntax examples.
{% endraw %}
</code></pre>
<h3 id="assign-variables"><a class="header" href="#assign-variables">Assign Variables</a></h3>
<p>Create new variables:</p>
<pre><code class="language-liquid">{% assign full_name = first_name | append: " " | append: last_name %}
Welcome, {{ full_name }}!

{% assign item_count = items | size %}
You have {{ item_count }} items.
</code></pre>
<h3 id="capture-blocks"><a class="header" href="#capture-blocks">Capture Blocks</a></h3>
<p>Capture content into a variable:</p>
<pre><code class="language-liquid">{% capture greeting %}
  {% if time_of_day == "morning" %}
    Good morning
  {% elsif time_of_day == "evening" %}
    Good evening
  {% else %}
    Hello
  {% endif %}
{% endcapture %}

{{ greeting }}, {{ name }}!
</code></pre>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>Access environment variables through the <code>env</code> object:</p>
<pre><code class="language-liquid">Current user: {{ env.USER }}
Home directory: {{ env.HOME }}
Custom setting: {{ env.MY_APP_CONFIG | default: "not set" }}
</code></pre>
<h2 id="object-access"><a class="header" href="#object-access">Object Access</a></h2>
<p>Access nested objects and arrays:</p>
<pre><code class="language-liquid">{{ user.name }}
{{ user.address.city }}
{{ items[0] }}
{{ items[index] }}
{{ data["dynamic_key"] }}
</code></pre>
<h2 id="truthy-and-falsy-values"><a class="header" href="#truthy-and-falsy-values">Truthy and Falsy Values</a></h2>
<p>In Liquid conditions:</p>
<ul>
<li><strong>Falsy</strong>: <code>false</code>, <code>nil</code></li>
<li><strong>Truthy</strong>: everything else (including <code>0</code>, <code>""</code>, <code>[]</code>)</li>
</ul>
<pre><code class="language-liquid">{% if value %}
  This shows unless value is false or nil
{% endif %}
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>When a variable is undefined:</p>
<ul>
<li>In backward-compatible mode: <code>{{ undefined }}</code> renders as <code>{{ undefined }}</code></li>
<li>With validation: An error is raised for missing required arguments</li>
</ul>
<p>Use the <code>default</code> filter to handle missing values gracefully:</p>
<pre><code class="language-liquid">{{ optional_var | default: "fallback value" }}
</code></pre>
<h2 id="migration-from-basic-templates"><a class="header" href="#migration-from-basic-templates">Migration from Basic Templates</a></h2>
<p>If youâ€™re migrating from basic <code>{{variable}}</code> syntax:</p>
<ol>
<li><strong>Your existing templates still work</strong> - backward compatibility is maintained</li>
<li><strong>Add spaces for clarity</strong>: <code>{{var}}</code> â†’ <code>{{ var }}</code></li>
<li><strong>Use filters for transformation</strong>: <code>{{ name | upcase }}</code> instead of post-processing</li>
<li><strong>Add conditions for dynamic content</strong>: Use <code>{% if %}</code> blocks</li>
<li><strong>Use loops for repetitive content</strong>: Replace manual duplication with <code>{% for %}</code></li>
</ol>
<h3 id="migration-examples"><a class="header" href="#migration-examples">Migration Examples</a></h3>
<h4 id="before-basic-variable-substitution"><a class="header" href="#before-basic-variable-substitution">Before: Basic Variable Substitution</a></h4>
<pre><code>Please review the {{language}} code in {{file}}.
Focus on {{focus_area}}.
</code></pre>
<h4 id="after-enhanced-with-liquid-features"><a class="header" href="#after-enhanced-with-liquid-features">After: Enhanced with Liquid Features</a></h4>
<pre><code class="language-liquid">Please review the {{ language | capitalize }} code in {{ file }}.

{% if focus_area %}
Focus on {{ focus_area }}.
{% else %}
Perform a general code review.
{% endif %}

{% if language == "python" %}
Pay special attention to PEP 8 compliance.
{% elsif language == "javascript" %}
Check for ESLint rule violations.
{% endif %}
</code></pre>
<h4 id="before-manual-list-creation"><a class="header" href="#before-manual-list-creation">Before: Manual List Creation</a></h4>
<pre><code>Files to review:
- {{file1}}
- {{file2}}
- {{file3}}
</code></pre>
<h4 id="after-dynamic-lists-with-loops"><a class="header" href="#after-dynamic-lists-with-loops">After: Dynamic Lists with Loops</a></h4>
<pre><code class="language-liquid">Files to review:
{% for file in files %}
- {{ file }}{% if forloop.last %} (final file){% endif %}
{% endfor %}

Total: {{ files | size }} files
</code></pre>
<h4 id="before-fixed-templates"><a class="header" href="#before-fixed-templates">Before: Fixed Templates</a></h4>
<pre><code>Status: {{status}}
</code></pre>
<h4 id="after-conditional-formatting"><a class="header" href="#after-conditional-formatting">After: Conditional Formatting</a></h4>
<pre><code class="language-liquid">Status: {% case status %}
  {% when "success" %}âœ… {{ status | upcase }}
  {% when "error" %}âŒ {{ status | upcase }}
  {% when "warning" %}âš ï¸ {{ status | capitalize }}
  {% else %}{{ status }}
{% endcase %}
</code></pre>
<h3 id="differences-from-handlebarsmustache"><a class="header" href="#differences-from-handlebarsmustache">Differences from Handlebars/Mustache</a></h3>
<p>If youâ€™re familiar with Handlebars or Mustache templating:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Handlebars/Mustache</th><th>Liquid</th></tr></thead><tbody>
<tr><td>Variables</td><td><code>{{variable}}</code></td><td><code>{{ variable }}</code></td></tr>
<tr><td>Conditionals</td><td><code>{{#if}}...{{/if}}</code></td><td><code>{% if %}...{% endif %}</code></td></tr>
<tr><td>Loops</td><td><code>{{#each}}...{{/each}}</code></td><td><code>{% for %}...{% endfor %}</code></td></tr>
<tr><td>Comments</td><td><code>{{! comment }}</code></td><td><code>{% comment %}...{% endcomment %}</code></td></tr>
<tr><td>Filters</td><td>Limited</td><td>Extensive built-in filters</td></tr>
<tr><td>Logic</td><td>Minimal</td><td>Full comparison operators</td></tr>
</tbody></table>
</div>
<h3 id="common-migration-patterns"><a class="header" href="#common-migration-patterns">Common Migration Patterns</a></h3>
<ol>
<li>
<p><strong>Variable with Default</strong></p>
<ul>
<li>Before: Handle missing variables in code</li>
<li>After: <code>{{ variable | default: "fallback" }}</code></li>
</ul>
</li>
<li>
<p><strong>Conditional Sections</strong></p>
<ul>
<li>Before: Generate different templates</li>
<li>After: Single template with <code>{% if %}</code> blocks</li>
</ul>
</li>
<li>
<p><strong>Repeated Content</strong></p>
<ul>
<li>Before: Manual duplication</li>
<li>After: <code>{% for %}</code> loops with <code>forloop</code> variables</li>
</ul>
</li>
<li>
<p><strong>String Transformation</strong></p>
<ul>
<li>Before: Transform in application code</li>
<li>After: Use Liquid filters directly</li>
</ul>
</li>
</ol>
<h3 id="backward-compatibility-notes"><a class="header" href="#backward-compatibility-notes">Backward Compatibility Notes</a></h3>
<ul>
<li>Simple <code>{{variable}}</code> syntax continues to work</li>
<li>Undefined variables are preserved as <code>{{ variable }}</code> in output</li>
<li>No breaking changes to existing templates</li>
<li>Gradual migration is supported - mix old and new syntax</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="dynamic-code-review"><a class="header" href="#dynamic-code-review">Dynamic Code Review</a></h3>
<pre><code class="language-liquid">{% if language == "python" %}
  Please review this Python code for PEP 8 compliance.
{% elsif language == "javascript" %}
  Please review this JavaScript code for ESLint rules.
{% else %}
  Please review this {{ language }} code for best practices.
{% endif %}

{% if include_security %}
  Also check for security vulnerabilities.
{% endif %}
</code></pre>
<h3 id="formatted-list"><a class="header" href="#formatted-list">Formatted List</a></h3>
<pre><code class="language-liquid">{% for item in tasks %}
  {{ forloop.index }}. {{ item.title }}
  {% if item.completed %}âœ“{% else %}â—‹{% endif %}
  Priority: {{ item.priority | default: "normal" }}
  {% unless item.completed %}
    Due: {{ item.due_date | date: "%B %d" }}
  {% endunless %}
{% endfor %}
</code></pre>
<h3 id="conditional-debugging"><a class="header" href="#conditional-debugging">Conditional Debugging</a></h3>
<pre><code class="language-liquid">{% if debug_mode %}
  === Debug Information ===
  Variables: {{ arguments | json }}
  Environment: {{ env.NODE_ENV | default: "development" }}
  {% for key in api_keys %}
    {{ key }}: {{ key | truncate: 8 }}...
  {% endfor %}
{% endif %}
</code></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Use meaningful variable names</strong>: <code>{{ user_email }}</code> instead of <code>{{ ue }}</code></li>
<li><strong>Provide defaults</strong>: <code>{{ value | default: "N/A" }}</code> for optional values</li>
<li><strong>Format output</strong>: Use filters to ensure consistent formatting</li>
<li><strong>Comment complex logic</strong>: Use <code>{% comment %}</code> blocks</li>
<li><strong>Test edge cases</strong>: Empty arrays, nil values, missing variables</li>
<li><strong>Keep it readable</strong>: Break complex templates into sections</li>
</ol>
<h2 id="custom-filters"><a class="header" href="#custom-filters">Custom Filters</a></h2>
<p>SwissArmyHammer includes specialized custom filters designed for prompt engineering:</p>
<h3 id="code-filters"><a class="header" href="#code-filters">Code Filters</a></h3>
<pre><code class="language-liquid">{{ code | format_lang: "rust" }}      # Format code with language
{{ code | extract_functions }}        # Extract function signatures
{{ path | basename }}                 # Get filename from path
{{ path | dirname }}                  # Get directory from path
{{ text | count_lines }}              # Count number of lines
{{ code | dedent }}                   # Remove common indentation
</code></pre>
<h3 id="text-processing-filters"><a class="header" href="#text-processing-filters">Text Processing Filters</a></h3>
<pre><code class="language-liquid">{{ text | extract_urls }}             # Extract URLs from text
{{ title | slugify }}                 # Convert to URL-friendly slug
{{ text | word_wrap: 80 }}            # Wrap text at 80 characters
{{ text | indent: 2 }}                # Indent all lines by 2 spaces
{{ items | bullet_list }}             # Convert array to bullet list
{{ text | highlight: "keyword" }}     # Highlight specific terms
</code></pre>
<h3 id="data-transformation-filters"><a class="header" href="#data-transformation-filters">Data Transformation Filters</a></h3>
<pre><code class="language-liquid">{{ json_string | from_json }}         # Parse JSON string
{{ data | to_json }}                  # Convert to JSON string
{{ csv_string | from_csv }}           # Parse CSV string
{{ array | to_csv }}                  # Convert to CSV string
{{ yaml_string | from_yaml }}         # Parse YAML string
{{ data | to_yaml }}                  # Convert to YAML string
</code></pre>
<h3 id="utility-filters"><a class="header" href="#utility-filters">Utility Filters</a></h3>
<pre><code class="language-liquid">{{ text | md5 }}                      # Generate MD5 hash
{{ text | sha1 }}                     # Generate SHA1 hash
{{ text | sha256 }}                   # Generate SHA256 hash
{{ number | ordinal }}                # Convert to ordinal (1st, 2nd, 3rd)
{{ 100 | lorem_words }}               # Generate lorem ipsum words
{{ date | format_date: "%Y-%m-%d" }}  # Advanced date formatting
</code></pre>
<p>For complete documentation of custom filters, see the <a href="./custom-filters.html">Custom Filters Reference</a>.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ol>
<li><strong>No includes</strong>: Cannot include other template files</li>
<li><strong>No custom tags</strong>: Only standard Liquid tags are supported</li>
<li><strong>Performance</strong>: Very large loops may impact performance</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="https://shopify.github.io/liquid/">Official Liquid Documentation</a></li>
<li><a href="https://liquidjs.com/playground.html">Liquid Playground</a> - Test templates online</li>
<li><a href="https://github.com/Shopify/liquid/wiki/Liquid-for-Designers">Liquid Cheat Sheet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-filters-reference"><a class="header" href="#custom-filters-reference">Custom Filters Reference</a></h1>
<p>SwissArmyHammer includes a comprehensive set of custom Liquid filters designed specifically for prompt engineering and content processing.</p>
<h2 id="code-filters-1"><a class="header" href="#code-filters-1">Code Filters</a></h2>
<h3 id="format_lang"><a class="header" href="#format_lang">format_lang</a></h3>
<p>Formats code with language-specific syntax highlighting hints.</p>
<pre><code class="language-liquid">{{ code | format_lang: "rust" }}
{{ code | format_lang: language_var }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>language</code> - Programming language identifier (e.g., â€œrustâ€, â€œpythonâ€, â€œjavascriptâ€)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "fn main() { println!(\"Hello\"); }" | format_lang: "rust" }}

&lt;!-- Output --&gt;
```rust
fn main() { println!("Hello"); }
</code></pre>
<pre><code>
### extract_functions

Extracts function signatures and definitions from code.

```liquid
{{ code | extract_functions }}
{{ code | extract_functions: "detailed" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>mode</code> (optional) - â€œsignaturesâ€ (default) or â€œdetailedâ€ for full function bodies</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ rust_code | extract_functions }}

&lt;!-- Output --&gt;
- fn main()
- fn calculate(x: i32, y: i32) -&gt; i32
- fn process_data(data: &amp;Vec&lt;String&gt;) -&gt; Result&lt;(), Error&gt;
</code></pre>
<h3 id="basename"><a class="header" href="#basename">basename</a></h3>
<p>Extracts the filename from a file path.</p>
<pre><code class="language-liquid">{{ path | basename }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "/usr/local/bin/swissarmyhammer" | basename }}

&lt;!-- Output --&gt;
swissarmyhammer
</code></pre>
<h3 id="dirname"><a class="header" href="#dirname">dirname</a></h3>
<p>Extracts the directory path from a file path.</p>
<pre><code class="language-liquid">{{ path | dirname }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "/usr/local/bin/swissarmyhammer" | dirname }}

&lt;!-- Output --&gt;
/usr/local/bin
</code></pre>
<h3 id="count_lines"><a class="header" href="#count_lines">count_lines</a></h3>
<p>Counts the number of lines in text.</p>
<pre><code class="language-liquid">{{ text | count_lines }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "line 1\nline 2\nline 3" | count_lines }}

&lt;!-- Output --&gt;
3
</code></pre>
<h3 id="dedent"><a class="header" href="#dedent">dedent</a></h3>
<p>Removes common leading whitespace from all lines.</p>
<pre><code class="language-liquid">{{ code | dedent }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "    fn main() {\n        println!(\"Hello\");\n    }" | dedent }}

&lt;!-- Output --&gt;
fn main() {
    println!("Hello");
}
</code></pre>
<h2 id="text-processing-filters-1"><a class="header" href="#text-processing-filters-1">Text Processing Filters</a></h2>
<h3 id="extract_urls"><a class="header" href="#extract_urls">extract_urls</a></h3>
<p>Extracts all URLs from text.</p>
<pre><code class="language-liquid">{{ text | extract_urls }}
{{ text | extract_urls: "list" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>format</code> (optional) - â€œarrayâ€ (default) or â€œlistâ€ for bullet point list</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "Visit https://example.com and https://github.com" | extract_urls }}

&lt;!-- Output --&gt;
["https://example.com", "https://github.com"]

&lt;!-- With list format --&gt;
{{ "Visit https://example.com and https://github.com" | extract_urls: "list" }}

&lt;!-- Output --&gt;
- https://example.com
- https://github.com
</code></pre>
<h3 id="slugify"><a class="header" href="#slugify">slugify</a></h3>
<p>Converts text to a URL-friendly slug.</p>
<pre><code class="language-liquid">{{ title | slugify }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "Advanced Code Review Helper!" | slugify }}

&lt;!-- Output --&gt;
advanced-code-review-helper
</code></pre>
<h3 id="word_wrap"><a class="header" href="#word_wrap">word_wrap</a></h3>
<p>Wraps text at specified column width.</p>
<pre><code class="language-liquid">{{ text | word_wrap: 80 }}
{{ text | word_wrap: width_var }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>width</code> - Column width for wrapping (default: 80)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "This is a very long line that should be wrapped at a specific column width to ensure readability." | word_wrap: 30 }}

&lt;!-- Output --&gt;
This is a very long line that
should be wrapped at a specific
column width to ensure
readability.
</code></pre>
<h3 id="indent"><a class="header" href="#indent">indent</a></h3>
<p>Indents all lines by specified number of spaces.</p>
<pre><code class="language-liquid">{{ text | indent: 4 }}
{{ text | indent: spaces_var }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>spaces</code> - Number of spaces to indent (default: 2)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "line 1\nline 2" | indent: 4 }}

&lt;!-- Output --&gt;
    line 1
    line 2
</code></pre>
<h3 id="bullet_list"><a class="header" href="#bullet_list">bullet_list</a></h3>
<p>Converts an array to a bullet point list.</p>
<pre><code class="language-liquid">{{ array | bullet_list }}
{{ array | bullet_list: "*" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>bullet</code> (optional) - Bullet character (default: â€œ-â€)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ ["Item 1", "Item 2", "Item 3"] | bullet_list }}

&lt;!-- Output --&gt;
- Item 1
- Item 2
- Item 3

&lt;!-- With custom bullet --&gt;
{{ ["Item 1", "Item 2"] | bullet_list: "*" }}

&lt;!-- Output --&gt;
* Item 1
* Item 2
</code></pre>
<h3 id="highlight"><a class="header" href="#highlight">highlight</a></h3>
<p>Highlights specific terms in text.</p>
<pre><code class="language-liquid">{{ text | highlight: "keyword" }}
{{ text | highlight: term_var }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>term</code> - Term to highlight</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "This is important text with keywords" | highlight: "important" }}

&lt;!-- Output --&gt;
This is **important** text with keywords
</code></pre>
<h2 id="data-transformation-filters-1"><a class="header" href="#data-transformation-filters-1">Data Transformation Filters</a></h2>
<h3 id="from_json"><a class="header" href="#from_json">from_json</a></h3>
<p>Parses JSON string into object/array.</p>
<pre><code class="language-liquid">{{ json_string | from_json }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign data = '{"name": "John", "age": 30}' | from_json %}
Name: {{ data.name }}
Age: {{ data.age }}

&lt;!-- Output --&gt;
Name: John
Age: 30
</code></pre>
<h3 id="to_json"><a class="header" href="#to_json">to_json</a></h3>
<p>Converts object/array to JSON string.</p>
<pre><code class="language-liquid">{{ data | to_json }}
{{ data | to_json: "pretty" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>format</code> (optional) - â€œcompactâ€ (default) or â€œprettyâ€ for formatted output</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign user = { "name": "John", "age": 30 } %}
{{ user | to_json: "pretty" }}

&lt;!-- Output --&gt;
{
  "name": "John",
  "age": 30
}
</code></pre>
<h3 id="from_csv"><a class="header" href="#from_csv">from_csv</a></h3>
<p>Parses CSV string into array of objects.</p>
<pre><code class="language-liquid">{{ csv_string | from_csv }}
{{ csv_string | from_csv: ";" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>delimiter</code> (optional) - Field delimiter (default: â€œ,â€)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign data = "name,age\nJohn,30\nJane,25" | from_csv %}
{% for row in data %}
- {{ row.name }} is {{ row.age }} years old
{% endfor %}

&lt;!-- Output --&gt;
- John is 30 years old
- Jane is 25 years old
</code></pre>
<h3 id="to_csv"><a class="header" href="#to_csv">to_csv</a></h3>
<p>Converts array of objects to CSV string.</p>
<pre><code class="language-liquid">{{ array | to_csv }}
{{ array | to_csv: ";" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>delimiter</code> (optional) - Field delimiter (default: â€œ,â€)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign users = [{"name": "John", "age": 30}, {"name": "Jane", "age": 25}] %}
{{ users | to_csv }}

&lt;!-- Output --&gt;
name,age
John,30
Jane,25
</code></pre>
<h3 id="from_yaml"><a class="header" href="#from_yaml">from_yaml</a></h3>
<p>Parses YAML string into object/array.</p>
<pre><code class="language-liquid">{{ yaml_string | from_yaml }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign config = "database:\n  host: localhost\n  port: 5432" | from_yaml %}
Host: {{ config.database.host }}
Port: {{ config.database.port }}

&lt;!-- Output --&gt;
Host: localhost
Port: 5432
</code></pre>
<h3 id="to_yaml"><a class="header" href="#to_yaml">to_yaml</a></h3>
<p>Converts object/array to YAML string.</p>
<pre><code class="language-liquid">{{ data | to_yaml }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{% assign config = {"database": {"host": "localhost", "port": 5432}} %}
{{ config | to_yaml }}

&lt;!-- Output --&gt;
database:
  host: localhost
  port: 5432
</code></pre>
<h2 id="hash-filters"><a class="header" href="#hash-filters">Hash Filters</a></h2>
<h3 id="md5"><a class="header" href="#md5">md5</a></h3>
<p>Generates MD5 hash of input text.</p>
<pre><code class="language-liquid">{{ text | md5 }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "hello world" | md5 }}

&lt;!-- Output --&gt;
5d41402abc4b2a76b9719d911017c592
</code></pre>
<h3 id="sha1"><a class="header" href="#sha1">sha1</a></h3>
<p>Generates SHA1 hash of input text.</p>
<pre><code class="language-liquid">{{ text | sha1 }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "hello world" | sha1 }}

&lt;!-- Output --&gt;
2aae6c35c94fcfb415dbe95f408b9ce91ee846ed
</code></pre>
<h3 id="sha256"><a class="header" href="#sha256">sha256</a></h3>
<p>Generates SHA256 hash of input text.</p>
<pre><code class="language-liquid">{{ text | sha256 }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "hello world" | sha256 }}

&lt;!-- Output --&gt;
b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
</code></pre>
<h2 id="utility-filters-1"><a class="header" href="#utility-filters-1">Utility Filters</a></h2>
<h3 id="ordinal"><a class="header" href="#ordinal">ordinal</a></h3>
<p>Converts number to ordinal format (1st, 2nd, 3rd, etc.).</p>
<pre><code class="language-liquid">{{ number | ordinal }}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ 1 | ordinal }} item
{{ 22 | ordinal }} place
{{ 103 | ordinal }} attempt

&lt;!-- Output --&gt;
1st item
22nd place
103rd attempt
</code></pre>
<h3 id="lorem_words"><a class="header" href="#lorem_words">lorem_words</a></h3>
<p>Generates lorem ipsum text with specified number of words.</p>
<pre><code class="language-liquid">{{ count | lorem_words }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>count</code> - Number of words to generate</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ 10 | lorem_words }}

&lt;!-- Output --&gt;
Lorem ipsum dolor sit amet consectetur adipiscing elit sed do eiusmod
</code></pre>
<h3 id="format_date"><a class="header" href="#format_date">format_date</a></h3>
<p>Advanced date formatting with custom format strings.</p>
<pre><code class="language-liquid">{{ date | format_date: "%Y-%m-%d %H:%M:%S" }}
{{ "now" | format_date: "%B %d, %Y" }}
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>format</code> - Date format string (uses strftime format)</li>
</ul>
<p><strong>Common format codes:</strong></p>
<ul>
<li><code>%Y</code> - 4-digit year (2024)</li>
<li><code>%m</code> - Month as number (01-12)</li>
<li><code>%d</code> - Day of month (01-31)</li>
<li><code>%H</code> - Hour (00-23)</li>
<li><code>%M</code> - Minute (00-59)</li>
<li><code>%S</code> - Second (00-59)</li>
<li><code>%B</code> - Full month name (January)</li>
<li><code>%b</code> - Abbreviated month (Jan)</li>
<li><code>%A</code> - Full weekday name (Monday)</li>
<li><code>%a</code> - Abbreviated weekday (Mon)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-liquid">&lt;!-- Input --&gt;
{{ "2024-01-15T10:30:00Z" | format_date: "%B %d, %Y at %I:%M %p" }}
{{ "now" | format_date: "%A, %Y-%m-%d" }}

&lt;!-- Output --&gt;
January 15, 2024 at 10:30 AM
Monday, 2024-01-15
</code></pre>
<h2 id="filter-chaining"><a class="header" href="#filter-chaining">Filter Chaining</a></h2>
<p>Filters can be chained together for complex transformations:</p>
<pre><code class="language-liquid">{{ code | dedent | format_lang: "python" | highlight: "def" }}

{{ user_input | strip | truncate: 100 | capitalize }}

{{ data | to_json | indent: 2 }}

{{ filename | basename | slugify | append: ".md" }}
</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Custom filters handle errors gracefully:</p>
<ul>
<li><strong>Invalid input</strong>: Returns original value or empty string</li>
<li><strong>Missing arguments</strong>: Uses sensible defaults</li>
<li><strong>Type mismatches</strong>: Attempts conversion or returns original value</li>
</ul>
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<ul>
<li><strong>Hash filters</strong> (md5, sha1, sha256) are computationally expensive for large inputs</li>
<li><strong>Data transformation filters</strong> (JSON, CSV, YAML) may consume memory for large datasets</li>
<li><strong>Text processing filters</strong> are optimized for typical prompt content sizes</li>
<li><strong>Code filters</strong> use efficient parsing algorithms</li>
</ul>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="code-review-prompt"><a class="header" href="#code-review-prompt">Code Review Prompt</a></h3>
<pre><code class="language-liquid"># Code Review: {{ filename | basename }}

## File Information
- **Path**: {{ filepath }}
- **Lines**: {{ code | count_lines }}
- **Language**: {{ language | capitalize }}

## Code to Review
{{ code | dedent | format_lang: language }}

## Functions Found
{{ code | extract_functions | bullet_list }}

## Review Checklist
{% assign hash = code | sha256 | truncate: 8 %}
- [ ] Security review (ID: {{ hash }})
- [ ] Performance analysis
- [ ] Style compliance
</code></pre>
<h3 id="data-analysis-prompt"><a class="header" href="#data-analysis-prompt">Data Analysis Prompt</a></h3>
<pre><code class="language-liquid"># Data Analysis Report

## Dataset Summary
{% assign data = csv_data | from_csv %}
- **Records**: {{ data | size }}
- **Generated**: {{ "now" | format_date: "%Y-%m-%d %H:%M" }}

## Sample Data
{% for row in data limit:3 %}
{{ forloop.index | ordinal }} record: {{ row | to_json }}
{% endfor %}

## Field Analysis
{% assign fields = data[0] | keys %}
Available fields: {{ fields | bullet_list }}
</code></pre>
<h3 id="documentation-generator"><a class="header" href="#documentation-generator">Documentation Generator</a></h3>
<pre><code class="language-liquid"># API Documentation

## Endpoints
{% for endpoint in api_endpoints %}
### {{ endpoint.method | upcase }} {{ endpoint.path }}

{{ endpoint.description | word_wrap: 80 }}

{% if endpoint.parameters %}
**Parameters:**
{{ endpoint.parameters | to_yaml | indent: 2 }}
{% endif %}

**Example:**
```{{ endpoint.language | default: "bash" }}
{{ endpoint.example | dedent }}
</code></pre>
<p>{% endfor %}</p>
<hr />
<p><em>Generated on {{ â€œnowâ€ | format_date: â€œ%B %d, %Yâ€ }}</em></p>
<pre><code>
## See Also

- [Template Variables](./template-variables.md) - Basic Liquid syntax
- [Advanced Prompts](./advanced-prompts.md) - Using filters in complex templates
- [Testing Guide](./testing-guide.md) - Testing templates with custom filters</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prompt-organization"><a class="header" href="#prompt-organization">Prompt Organization</a></h1>
<p>Effective prompt organization is crucial for maintaining a scalable and manageable prompt library. This guide covers best practices for organizing your SwissArmyHammer prompts.</p>
<h2 id="directory-structure-1"><a class="header" href="#directory-structure-1">Directory Structure</a></h2>
<h3 id="recommended-hierarchy"><a class="header" href="#recommended-hierarchy">Recommended Hierarchy</a></h3>
<pre><code>~/.swissarmyhammer/prompts/
â”œâ”€â”€ development/
â”‚   â”œâ”€â”€ languages/
â”‚   â”‚   â”œâ”€â”€ python/
â”‚   â”‚   â”œâ”€â”€ javascript/
â”‚   â”‚   â””â”€â”€ rust/
â”‚   â”œâ”€â”€ frameworks/
â”‚   â”‚   â”œâ”€â”€ react/
â”‚   â”‚   â”œâ”€â”€ django/
â”‚   â”‚   â””â”€â”€ fastapi/
â”‚   â””â”€â”€ tools/
â”‚       â”œâ”€â”€ git/
â”‚       â”œâ”€â”€ docker/
â”‚       â””â”€â”€ ci-cd/
â”œâ”€â”€ writing/
â”‚   â”œâ”€â”€ technical/
â”‚   â”œâ”€â”€ business/
â”‚   â””â”€â”€ creative/
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ analysis/
â”‚   â”œâ”€â”€ transformation/
â”‚   â””â”€â”€ visualization/
â”œâ”€â”€ productivity/
â”‚   â”œâ”€â”€ planning/
â”‚   â”œâ”€â”€ automation/
â”‚   â””â”€â”€ workflows/
â””â”€â”€ _shared/
    â”œâ”€â”€ components/
    â”œâ”€â”€ templates/
    â””â”€â”€ utilities/
</code></pre>
<h3 id="directory-purposes"><a class="header" href="#directory-purposes">Directory Purposes</a></h3>
<ul>
<li><strong>development/</strong> - Programming and technical prompts</li>
<li><strong>writing/</strong> - Content creation and documentation</li>
<li><strong>data/</strong> - Data processing and analysis</li>
<li><strong>productivity/</strong> - Task management and workflows</li>
<li><strong>_shared/</strong> - Reusable components and utilities</li>
</ul>
<h2 id="naming-conventions-1"><a class="header" href="#naming-conventions-1">Naming Conventions</a></h2>
<h3 id="file-names"><a class="header" href="#file-names">File Names</a></h3>
<p>Use consistent, descriptive file names:</p>
<pre><code># Good examples
code-review-python.md
api-documentation-generator.md
git-commit-message.md
database-migration-planner.md

# Avoid
review.md
doc.md
prompt1.md
temp.md
</code></pre>
<h3 id="naming-rules"><a class="header" href="#naming-rules">Naming Rules</a></h3>
<ol>
<li><strong>Use kebab-case</strong> for file names</li>
<li><strong>Be descriptive</strong> - Include the purpose and context</li>
<li><strong>Add type suffix</strong> when multiple variants exist</li>
<li><strong>Keep under 40 characters</strong> for readability</li>
</ol>
<h3 id="prompt-names-in-yaml"><a class="header" href="#prompt-names-in-yaml">Prompt Names (in YAML)</a></h3>
<pre><code class="language-yaml"># Good - matches file name pattern
name: code-review-python

# Also good - hierarchical naming
name: development/code-review/python

# Avoid - too generic
name: review
</code></pre>
<h2 id="categories-and-tags-1"><a class="header" href="#categories-and-tags-1">Categories and Tags</a></h2>
<h3 id="using-categories"><a class="header" href="#using-categories">Using Categories</a></h3>
<p>Categories provide broad groupings:</p>
<pre><code class="language-yaml">---
name: api-security-scanner
title: API Security Scanner
category: development
subcategory: security
---
</code></pre>
<h3 id="effective-tagging"><a class="header" href="#effective-tagging">Effective Tagging</a></h3>
<p>Tags enable fine-grained discovery:</p>
<pre><code class="language-yaml">---
name: react-component-generator
tags:
  - react
  - javascript
  - frontend
  - component
  - generator
  - boilerplate
---
</code></pre>
<h3 id="category-vs-tags"><a class="header" href="#category-vs-tags">Category vs Tags</a></h3>
<ul>
<li><strong>Categories</strong>: Single, broad classification</li>
<li><strong>Tags</strong>: Multiple, specific attributes</li>
</ul>
<pre><code class="language-yaml"># Category for primary classification
category: development

# Tags for detailed attributes
tags:
  - python
  - testing
  - pytest
  - unit-tests
  - tdd
</code></pre>
<h2 id="modular-design"><a class="header" href="#modular-design">Modular Design</a></h2>
<h3 id="base-templates"><a class="header" href="#base-templates">Base Templates</a></h3>
<p>Create base templates in <code>_shared/templates/</code>:</p>
<pre><code class="language-markdown">&lt;!-- _shared/templates/code-review-base.md --&gt;
---
name: code-review-base
title: Base Code Review Template
abstract: true  # Indicates this is a template
---

# Code Review

## Overview
Review the following code for:
- Best practices
- Potential bugs
- Performance issues
- Security concerns

## Code
```{{language}}
{{code}}
</code></pre>
<h2 id="analysis"><a class="header" href="#analysis">Analysis</a></h2>
<p>{{analysis_content}}</p>
<pre><code>
### Extending Base Templates

```markdown
&lt;!-- development/languages/python/code-review-python.md --&gt;
---
name: code-review-python
title: Python Code Review
extends: code-review-base
---

{% capture analysis_content %}
### Python-Specific Checks
- PEP 8 compliance
- Type hints usage
- Pythonic idioms
- Import organization
{% endcapture %}

{% include "code-review-base" %}
</code></pre>
<h3 id="shared-components"><a class="header" href="#shared-components">Shared Components</a></h3>
<p>Store reusable components in <code>_shared/components/</code>:</p>
<pre><code class="language-markdown">&lt;!-- _shared/components/security-checks.md --&gt;
---
name: security-checks-component
component: true
---

### Security Analysis
- Input validation
- SQL injection risks
- XSS vulnerabilities
- Authentication flaws
- Data exposure
</code></pre>
<p>Use in prompts:</p>
<pre><code class="language-markdown">---
name: web-app-review
---

# Web Application Review

{{code}}

{% include "_shared/components/security-checks.md" %}

## Additional Checks
...
</code></pre>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<h3 id="version-in-metadata"><a class="header" href="#version-in-metadata">Version in Metadata</a></h3>
<p>Track prompt versions:</p>
<pre><code class="language-yaml">---
name: api-generator
version: 2.1.0
updated: 2024-03-20
changelog:
  - 2.1.0: Added GraphQL support
  - 2.0.0: Breaking change - new argument structure
  - 1.0.0: Initial release
---
</code></pre>
<h3 id="version-directories"><a class="header" href="#version-directories">Version Directories</a></h3>
<p>For major versions with breaking changes:</p>
<pre><code>prompts/
â”œâ”€â”€ development/
â”‚   â”œâ”€â”€ api-generator/
â”‚   â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”‚   â””â”€â”€ api-generator.md
â”‚   â”‚   â”œâ”€â”€ v2/
â”‚   â”‚   â”‚   â””â”€â”€ api-generator.md
â”‚   â”‚   â””â”€â”€ latest -&gt; v2/api-generator.md
</code></pre>
<h3 id="migration-guides"><a class="header" href="#migration-guides">Migration Guides</a></h3>
<p>Document version changes:</p>
<pre><code class="language-markdown">&lt;!-- development/api-generator/MIGRATION.md --&gt;
# API Generator Migration Guide

## v1 to v2

### Breaking Changes
- `endpoint_list` argument renamed to `endpoints`
- `auth_method` now requires specific values

### Migration Steps
1. Update argument names in your scripts
2. Validate auth_method values
3. Test with new version
</code></pre>
<h2 id="collections"><a class="header" href="#collections">Collections</a></h2>
<h3 id="prompt-collections"><a class="header" href="#prompt-collections">Prompt Collections</a></h3>
<p>Group related prompts:</p>
<pre><code class="language-markdown">&lt;!-- collections/fullstack-development.md --&gt;
---
name: fullstack-collection
title: Full-Stack Development Collection
type: collection
---

# Full-Stack Development Prompts

## Frontend
- `frontend/react-component` - React component generator
- `frontend/vue-template` - Vue.js templates
- `frontend/css-optimizer` - CSS optimization

## Backend
- `backend/api-design` - API design assistant
- `backend/database-schema` - Schema designer
- `backend/auth-implementation` - Authentication setup

## DevOps
- `devops/docker-config` - Docker configuration
- `devops/ci-pipeline` - CI/CD pipeline setup
- `devops/deployment-guide` - Deployment strategies
</code></pre>
<h3 id="collection-metadata"><a class="header" href="#collection-metadata">Collection Metadata</a></h3>
<pre><code class="language-yaml">---
name: data-science-toolkit
type: collection
prompts:
  - data/eda-assistant
  - data/feature-engineering
  - data/model-evaluation
  - data/visualization-guide
dependencies:
  - python
  - pandas
  - scikit-learn
---
</code></pre>
<h2 id="search-and-discovery"><a class="header" href="#search-and-discovery">Search and Discovery</a></h2>
<h3 id="metadata-for-search"><a class="header" href="#metadata-for-search">Metadata for Search</a></h3>
<p>Optimize prompts for discovery:</p>
<pre><code class="language-yaml">---
name: code-documenter
title: Intelligent Code Documentation Generator
description: |
  Generates comprehensive documentation for code including:
  - Function/method documentation
  - Class documentation
  - Module overview
  - Usage examples
  - API references
keywords:
  - documentation
  - docstring
  - comments
  - api docs
  - code docs
  - jsdoc
  - sphinx
  - rustdoc
search_terms:
  - "generate documentation"
  - "add comments to code"
  - "create api docs"
  - "document functions"
---
</code></pre>
<h3 id="aliases"><a class="header" href="#aliases">Aliases</a></h3>
<p>Support multiple names:</p>
<pre><code class="language-yaml">---
name: git-commit-message
aliases:
  - commit-message
  - git-message
  - commit-generator
---
</code></pre>
<h3 id="related-prompts"><a class="header" href="#related-prompts">Related Prompts</a></h3>
<p>Link related prompts:</p>
<pre><code class="language-yaml">---
name: code-review-security
related:
  - code-review-general
  - security-audit
  - vulnerability-scanner
  - penetration-test-guide
---
</code></pre>
<h2 id="team-collaboration"><a class="header" href="#team-collaboration">Team Collaboration</a></h2>
<h3 id="shared-conventions"><a class="header" href="#shared-conventions">Shared Conventions</a></h3>
<p>Document team conventions in <code>CONVENTIONS.md</code>:</p>
<pre><code class="language-markdown"># Prompt Conventions

## Naming
- Use `project-` prefix for project-specific prompts
- Use `team-` prefix for team-wide prompts
- Use `personal-` prefix for individual prompts

## Categories
- `project` - Project-specific
- `team` - Team standards
- `experimental` - Under development

## Required Metadata
All prompts must include:
- name
- title
- description
- author
- created date
- category
</code></pre>
<h3 id="ownership"><a class="header" href="#ownership">Ownership</a></h3>
<p>Track prompt ownership:</p>
<pre><code class="language-yaml">---
name: deployment-checklist
author: jane.doe@company.com
team: platform-engineering
maintainers:
  - jane.doe@company.com
  - john.smith@company.com
review_required: true
last_reviewed: 2024-03-15
---
</code></pre>
<h3 id="review-process"><a class="header" href="#review-process">Review Process</a></h3>
<p>Implement prompt review:</p>
<pre><code class="language-yaml">---
name: api-contract-generator
status: draft  # draft, review, approved, deprecated
reviewers:
  - senior-dev-team
approved_by: tech-lead@company.com
approval_date: 2024-03-10
---
</code></pre>
<h2 id="importexport-strategies"><a class="header" href="#importexport-strategies">Import/Export Strategies</a></h2>
<h3 id="partial-exports"><a class="header" href="#partial-exports">Partial Exports</a></h3>
<p>Export specific categories:</p>
<pre><code class="language-bash"># Export only development prompts
swissarmyhammer export dev-prompts.tar.gz --filter "category:development"

# Export by tags
swissarmyhammer export python-prompts.tar.gz --filter "tag:python"

# Export by date
swissarmyhammer export recent-prompts.tar.gz --filter "updated:&gt;2024-01-01"
</code></pre>
<h3 id="collection-bundles"><a class="header" href="#collection-bundles">Collection Bundles</a></h3>
<p>Create installable bundles:</p>
<pre><code class="language-yaml"># bundle.yaml
name: web-development-bundle
version: 1.0.0
description: Complete web development prompt collection
prompts:
  include:
    - category: frontend
    - category: backend
    - tag: web
  exclude:
    - tag: experimental
dependencies:
  - swissarmyhammer: "&gt;=0.1.0"
install_to: ~/.swissarmyhammer/prompts/bundles/web-dev/
</code></pre>
<h3 id="sync-strategies"><a class="header" href="#sync-strategies">Sync Strategies</a></h3>
<p>Keep prompts synchronized:</p>
<pre><code class="language-bash">#!/bin/bash
# sync-prompts.sh

# Backup local changes
swissarmyhammer export local-backup-$(date +%Y%m%d).tar.gz

# Pull team prompts
git pull origin main

# Import team updates
swissarmyhammer import team-prompts.tar.gz --merge

# Export for distribution
swissarmyhammer export team-bundle.tar.gz --filter "team:approved"
</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="1-start-simple"><a class="header" href="#1-start-simple">1. Start Simple</a></h3>
<p>Begin with basic organization:</p>
<pre><code>prompts/
â”œâ”€â”€ work/
â”œâ”€â”€ personal/
â””â”€â”€ learning/
</code></pre>
<p>Then evolve as needed.</p>
<h3 id="2-use-meaningful-hierarchies"><a class="header" href="#2-use-meaningful-hierarchies">2. Use Meaningful Hierarchies</a></h3>
<pre><code># Good - clear hierarchy
development/testing/unit-test-generator.md
development/testing/integration-test-builder.md

# Avoid - flat structure
unit-test-generator.md
integration-test-builder.md
</code></pre>
<h3 id="3-document-your-system"><a class="header" href="#3-document-your-system">3. Document Your System</a></h3>
<p>Create <code>prompts/README.md</code>:</p>
<pre><code class="language-markdown"># Prompt Library Organization

## Structure
- `development/` - Programming prompts
- `data/` - Data analysis prompts
- `writing/` - Content creation
- `_shared/` - Reusable components

## Naming Convention
- Files: `purpose-context-type.md`
- Prompts: Match file names

## How to Contribute
1. Choose appropriate category
2. Follow naming conventions
3. Include all required metadata
4. Test before committing
</code></pre>
<h3 id="4-regular-maintenance"><a class="header" href="#4-regular-maintenance">4. Regular Maintenance</a></h3>
<pre><code class="language-bash"># Find unused prompts
swissarmyhammer list --unused --days 90

# Find duplicates
swissarmyhammer list --duplicates

# Validate all prompts
swissarmyhammer doctor --check prompts
</code></pre>
<h3 id="5-progressive-enhancement"><a class="header" href="#5-progressive-enhancement">5. Progressive Enhancement</a></h3>
<p>Start with basic prompts and enhance:</p>
<pre><code class="language-yaml"># Version 1 - Basic
name: code-review
description: Reviews code

# Version 2 - Enhanced
name: code-review
description: Reviews code for quality, security, and performance
category: development
tags: [review, quality, security]
version: 2.0.0
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="enterprise-setup"><a class="header" href="#enterprise-setup">Enterprise Setup</a></h3>
<pre><code>company-prompts/
â”œâ”€â”€ departments/
â”‚   â”œâ”€â”€ engineering/
â”‚   â”‚   â”œâ”€â”€ standards/
â”‚   â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â””â”€â”€ tools/
â”‚   â”œâ”€â”€ product/
â”‚   â”‚   â”œâ”€â”€ specs/
â”‚   â”‚   â”œâ”€â”€ research/
â”‚   â”‚   â””â”€â”€ documentation/
â”‚   â””â”€â”€ data-science/
â”‚       â”œâ”€â”€ analysis/
â”‚       â”œâ”€â”€ models/
â”‚       â””â”€â”€ reporting/
â”œâ”€â”€ projects/
â”‚   â”œâ”€â”€ project-alpha/
â”‚   â”œâ”€â”€ project-beta/
â”‚   â””â”€â”€ _archived/
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ templates/
â”‚   â””â”€â”€ utilities/
â””â”€â”€ personal/
    â””â”€â”€ [username]/
</code></pre>
<h3 id="open-source-project"><a class="header" href="#open-source-project">Open Source Project</a></h3>
<pre><code>oss-prompts/
â”œâ”€â”€ contribution/
â”‚   â”œâ”€â”€ issue-templates/
â”‚   â”œâ”€â”€ pr-templates/
â”‚   â””â”€â”€ code-review/
â”œâ”€â”€ documentation/
â”‚   â”œâ”€â”€ api-docs/
â”‚   â”œâ”€â”€ user-guide/
â”‚   â””â”€â”€ examples/
â”œâ”€â”€ maintenance/
â”‚   â”œâ”€â”€ release/
â”‚   â”œâ”€â”€ changelog/
â”‚   â””â”€â”€ security/
â””â”€â”€ community/
    â”œâ”€â”€ support/
    â””â”€â”€ onboarding/
</code></pre>
<h2 id="automation"><a class="header" href="#automation">Automation</a></h2>
<h3 id="auto-organization-script"><a class="header" href="#auto-organization-script">Auto-Organization Script</a></h3>
<pre><code class="language-python">#!/usr/bin/env python3
# organize-prompts.py

import os
import yaml
from pathlib import Path

def organize_prompts(source_dir, target_dir):
    """Auto-organize prompts based on metadata."""
    for prompt_file in Path(source_dir).glob("**/*.md"):
        with open(prompt_file) as f:
            content = f.read()
            
        # Extract front matter
        if content.startswith("---"):
            _, fm, _ = content.split("---", 2)
            metadata = yaml.safe_load(fm)
            
            # Determine target path
            category = metadata.get("category", "uncategorized")
            subcategory = metadata.get("subcategory", "")
            
            target_path = Path(target_dir) / category
            if subcategory:
                target_path = target_path / subcategory
                
            # Move file
            target_path.mkdir(parents=True, exist_ok=True)
            target_file = target_path / prompt_file.name
            prompt_file.rename(target_file)
            
            print(f"Moved {prompt_file} -&gt; {target_file}")
</code></pre>
<h3 id="validation-script"><a class="header" href="#validation-script">Validation Script</a></h3>
<pre><code class="language-bash">#!/bin/bash
# validate-organization.sh

echo "Validating prompt organization..."

# Check for prompts without categories
echo "Prompts without categories:"
grep -L "category:" prompts/**/*.md

# Check for duplicate names
echo "Duplicate prompt names:"
swissarmyhammer list --format json | jq -r '.[] | .name' | sort | uniq -d

# Check naming conventions
echo "Files not following naming convention:"
find prompts -name "*.md" | grep -v "[a-z0-9-]*.md"
</code></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li>See <a href="./creating-prompts.html">Creating Prompts</a> for prompt creation guidelines</li>
<li>Learn about <a href="./advanced-prompts.html">Advanced Prompts</a> for complex scenarios</li>
<li>Explore <a href="./examples.html">Examples</a> for organization patterns</li>
<li>Read <a href="./configuration.html">Configuration</a> for system-wide settings</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="claude-code-integration"><a class="header" href="#claude-code-integration">Claude Code Integration</a></h1>
<p>SwissArmyHammer integrates seamlessly with <a href="https://docs.anthropic.com/en/docs/claude-code">Claude Code</a> through the Model Context Protocol (MCP). This guide shows you how to set up and use SwissArmyHammer with Claude Code.</p>
<h2 id="what-is-mcp"><a class="header" href="#what-is-mcp">What is MCP?</a></h2>
<p>The <a href="https://github.com/anthropics/model-context-protocol">Model Context Protocol</a> allows AI assistants like Claude to access external tools and data sources. SwissArmyHammer acts as an MCP server, providing Claude Code with access to your prompt library.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<h3 id="1-install-swissarmyhammer"><a class="header" href="#1-install-swissarmyhammer">1. Install SwissArmyHammer</a></h3>
<p>See the <a href="./installation.html">Installation Guide</a> for detailed instructions. The quickest method:</p>
<pre><code class="language-bash"># Install using the install script
curl -sSL https://raw.githubusercontent.com/wballard/swissarmyhammer/main/install.sh | bash
</code></pre>
<h3 id="2-verify-installation"><a class="header" href="#2-verify-installation">2. Verify Installation</a></h3>
<pre><code class="language-bash">swissarmyhammer --version
</code></pre>
<h3 id="3-test-the-mcp-server"><a class="header" href="#3-test-the-mcp-server">3. Test the MCP Server</a></h3>
<pre><code class="language-bash">swissarmyhammer serve --help
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="add-to-claude-code"><a class="header" href="#add-to-claude-code">Add to Claude Code</a></h3>
<p>Configure Claude Code to use SwissArmyHammer as an MCP server:</p>
<pre><code class="language-bash">claude mcp add --scope user swissarmyhammer swissarmyhammer serve
</code></pre>
<p>This command:</p>
<ul>
<li>Adds <code>swissarmyhammer</code> as an MCP server name</li>
<li>Uses <code>swissarmyhammer serve</code> as the command to start the server</li>
<li>Sets user scope (available for your user account)</li>
</ul>
<h3 id="alternative-configuration-methods"><a class="header" href="#alternative-configuration-methods">Alternative Configuration Methods</a></h3>
<h4 id="manual-configuration"><a class="header" href="#manual-configuration">Manual Configuration</a></h4>
<p>If you prefer to configure manually, add this to your Claude Code MCP configuration:</p>
<pre><code class="language-json">{
  "mcpServers": {
    "swissarmyhammer": {
      "command": "swissarmyhammer",
      "args": ["serve"]
    }
  }
}
</code></pre>
<h4 id="project-specific-configuration"><a class="header" href="#project-specific-configuration">Project-Specific Configuration</a></h4>
<p>For project-specific prompts, create a local configuration:</p>
<pre><code class="language-bash"># In your project directory
claude mcp add --scope project swissarmyhammer_local swissarmyhammer serve --prompts ./prompts
</code></pre>
<h2 id="verification-1"><a class="header" href="#verification-1">Verification</a></h2>
<h3 id="check-mcp-configuration"><a class="header" href="#check-mcp-configuration">Check MCP Configuration</a></h3>
<p>List your configured MCP servers:</p>
<pre><code class="language-bash">claude mcp list
</code></pre>
<p>You should see <code>swissarmyhammer</code> in the output.</p>
<h3 id="test-the-connection"><a class="header" href="#test-the-connection">Test the Connection</a></h3>
<p>Start Claude Code and verify SwissArmyHammer is connected:</p>
<ol>
<li>Open Claude Code</li>
<li>Look for SwissArmyHammer prompts in the available tools</li>
<li>Try using a built-in prompt like <code>help</code> or <code>plan</code></li>
</ol>
<h3 id="debug-connection-issues"><a class="header" href="#debug-connection-issues">Debug Connection Issues</a></h3>
<p>If SwissArmyHammer doesnâ€™t appear in Claude Code:</p>
<pre><code class="language-bash"># Check if the server starts correctly
swissarmyhammer serve --debug

# Verify prompts are loaded
swissarmyhammer list

# Check configuration
claude mcp list
</code></pre>
<h2 id="usage-in-claude-code"><a class="header" href="#usage-in-claude-code">Usage in Claude Code</a></h2>
<h3 id="available-features"><a class="header" href="#available-features">Available Features</a></h3>
<p>Once configured, SwissArmyHammer provides these features in Claude Code:</p>
<h4 id="1-prompt-library-access"><a class="header" href="#1-prompt-library-access">1. Prompt Library Access</a></h4>
<p>All your prompts become available as tools in Claude Code:</p>
<ul>
<li>Built-in prompts (code review, debugging, documentation)</li>
<li>User prompts (in <code>~/.swissarmyhammer/prompts/</code>)</li>
<li>Local prompts (in current project directory)</li>
</ul>
<h4 id="2-dynamic-arguments"><a class="header" href="#2-dynamic-arguments">2. Dynamic Arguments</a></h4>
<p>Prompts with arguments become interactive forms in Claude Code:</p>
<pre><code class="language-markdown">---
name: code-review
arguments:
  - name: code
    description: Code to review
    required: true
  - name: language
    description: Programming language
    required: false
    default: auto-detect
---
</code></pre>
<h4 id="3-live-reloading"><a class="header" href="#3-live-reloading">3. Live Reloading</a></h4>
<p>Changes to prompt files are automatically detected and reloaded.</p>
<h3 id="using-prompts"><a class="header" href="#using-prompts">Using Prompts</a></h3>
<h4 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h4>
<ol>
<li><strong>Select a Prompt</strong>: Choose from available SwissArmyHammer prompts</li>
<li><strong>Fill Arguments</strong>: Provide required and optional parameters</li>
<li><strong>Execute</strong>: Claude runs the prompt with your arguments</li>
</ol>
<h4 id="example-workflow"><a class="header" href="#example-workflow">Example Workflow</a></h4>
<ol>
<li>
<p><strong>Code Review</strong>:</p>
<ul>
<li>Select <code>code-review</code> prompt</li>
<li>Paste your code in the <code>code</code> field</li>
<li>Set <code>language</code> if needed</li>
<li>Execute to get detailed code analysis</li>
</ul>
</li>
<li>
<p><strong>Debug Helper</strong>:</p>
<ul>
<li>Select <code>debug</code> prompt</li>
<li>Describe your error in the <code>error</code> field</li>
<li>Get step-by-step debugging guidance</li>
</ul>
</li>
<li>
<p><strong>Documentation</strong>:</p>
<ul>
<li>Select <code>docs</code> prompt</li>
<li>Provide code or specifications</li>
<li>Generate comprehensive documentation</li>
</ul>
</li>
</ol>
<h3 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h3>
<h4 id="prompt-chaining"><a class="header" href="#prompt-chaining">Prompt Chaining</a></h4>
<p>Use multiple prompts in sequence:</p>
<pre><code class="language-markdown">1. Use `analyze-code` to understand the codebase
2. Use `plan` to create implementation strategy  
3. Use `code-review` on the new code
4. Use `docs` to generate documentation
</code></pre>
<h4 id="custom-workflows"><a class="header" href="#custom-workflows">Custom Workflows</a></h4>
<p>Create project-specific prompt workflows:</p>
<pre><code class="language-markdown"># Project prompts in ./prompts/

## development/
- project-setup.md - Initialize new features
- code-standards.md - Apply project coding standards
- deployment.md - Deploy to staging/production

## documentation/  
- api-docs.md - Generate API documentation
- user-guide.md - Create user-facing documentation
- changelog.md - Generate release notes
</code></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="server-configuration"><a class="header" href="#server-configuration">Server Configuration</a></h3>
<p>The <code>swissarmyhammer serve</code> command accepts several options:</p>
<pre><code class="language-bash">swissarmyhammer serve [OPTIONS]
</code></pre>
<h4 id="common-options"><a class="header" href="#common-options">Common Options</a></h4>
<ul>
<li><code>--port &lt;PORT&gt;</code> - Port for MCP communication (default: auto)</li>
<li><code>--host &lt;HOST&gt;</code> - Host to bind to (default: localhost)</li>
<li><code>--prompts &lt;DIR&gt;</code> - Additional prompt directories</li>
<li><code>--builtin &lt;BOOL&gt;</code> - Include built-in prompts (default: true)</li>
<li><code>--watch &lt;BOOL&gt;</code> - Enable file watching (default: true)</li>
<li><code>--debug</code> - Enable debug logging</li>
</ul>
<h4 id="examples-2"><a class="header" href="#examples-2">Examples</a></h4>
<pre><code class="language-bash"># Basic server
swissarmyhammer serve

# Custom prompt directory
swissarmyhammer serve --prompts /path/to/prompts

# Multiple prompt directories
swissarmyhammer serve --prompts ./prompts --prompts ~/.custom-prompts

# Debug mode
swissarmyhammer serve --debug

# Disable built-in prompts
swissarmyhammer serve --builtin false
</code></pre>
<h3 id="claude-code-configuration"><a class="header" href="#claude-code-configuration">Claude Code Configuration</a></h3>
<h4 id="server-arguments"><a class="header" href="#server-arguments">Server Arguments</a></h4>
<p>Pass arguments to the SwissArmyHammer server:</p>
<pre><code class="language-bash"># Add with custom options
claude mcp add swissarmyhammer_custom swissarmyhammer serve --prompts ./project-prompts --debug
</code></pre>
<h4 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h4>
<p>Configure through environment variables:</p>
<pre><code class="language-bash">export SWISSARMYHAMMER_PROMPTS_DIR=/path/to/prompts
export SWISSARMYHAMMER_DEBUG=true
claude mcp add swissarmyhammer swissarmyhammer serve
</code></pre>
<h2 id="prompt-organization-1"><a class="header" href="#prompt-organization-1">Prompt Organization</a></h2>
<h3 id="directory-structure-2"><a class="header" href="#directory-structure-2">Directory Structure</a></h3>
<p>Organize prompts for easy discovery in Claude Code:</p>
<pre><code>~/.swissarmyhammer/prompts/
â”œâ”€â”€ development/
â”‚   â”œâ”€â”€ code-review.md
â”‚   â”œâ”€â”€ debug-helper.md
â”‚   â”œâ”€â”€ refactor.md
â”‚   â””â”€â”€ testing.md
â”œâ”€â”€ writing/
â”‚   â”œâ”€â”€ blog-post.md
â”‚   â”œâ”€â”€ documentation.md
â”‚   â””â”€â”€ email.md
â”œâ”€â”€ analysis/
â”‚   â”œâ”€â”€ data-insights.md
â”‚   â””â”€â”€ research.md
â””â”€â”€ productivity/
    â”œâ”€â”€ task-planning.md
    â””â”€â”€ meeting-notes.md
</code></pre>
<h3 id="naming-conventions-2"><a class="header" href="#naming-conventions-2">Naming Conventions</a></h3>
<p>Use clear, descriptive names that work well in Claude Code:</p>
<pre><code class="language-markdown"># Good - Clear and specific
code-review-python.md
debug-javascript-async.md
documentation-api.md

# Bad - Too generic
review.md
debug.md
docs.md
</code></pre>
<h3 id="categories-and-tags-2"><a class="header" href="#categories-and-tags-2">Categories and Tags</a></h3>
<p>Use categories and tags for better organization in Claude Code:</p>
<pre><code class="language-yaml">---
name: python-code-review
title: Python Code Review
description: Reviews Python code for PEP 8, security, and performance
category: development
tags: ["python", "code-review", "pep8", "security"]
---
</code></pre>
<h2 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h2>
<h3 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h3>
<h4 id="swissarmyhammer-not-available"><a class="header" href="#swissarmyhammer-not-available">SwissArmyHammer Not Available</a></h4>
<p><strong>Symptoms</strong>: SwissArmyHammer prompts donâ€™t appear in Claude Code</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Verify installation: <code>swissarmyhammer --version</code></li>
<li>Check MCP configuration: <code>claude mcp list</code></li>
<li>Test server manually: <code>swissarmyhammer serve --debug</code></li>
<li>Restart Claude Code</li>
</ol>
<h4 id="connection-errors"><a class="header" href="#connection-errors">Connection Errors</a></h4>
<p><strong>Symptoms</strong>: Error messages about MCP connection</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Check if port is available: <code>swissarmyhammer serve --port 8080</code></li>
<li>Verify permissions: Run with <code>--debug</code> to see detailed logs</li>
<li>Check firewall settings</li>
<li>Try different host: <code>--host 127.0.0.1</code></li>
</ol>
<h4 id="prompts-not-loading"><a class="header" href="#prompts-not-loading">Prompts Not Loading</a></h4>
<p><strong>Symptoms</strong>: Some prompts missing or outdated</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Check prompt syntax: <code>swissarmyhammer test &lt;prompt-name&gt;</code></li>
<li>Verify file permissions in prompt directories</li>
<li>Check for YAML syntax errors</li>
<li>Restart the MCP server: Restart Claude Code</li>
</ol>
<h4 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h4>
<p><strong>Symptoms</strong>: Slow prompt loading or execution</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Reduce prompt directory size</li>
<li>Disable file watching: <code>--watch false</code></li>
<li>Use specific prompt directories: <code>--prompts ./specific-dir</code></li>
<li>Check system resources</li>
</ol>
<h3 id="debug-mode"><a class="header" href="#debug-mode">Debug Mode</a></h3>
<p>Enable debug mode for detailed troubleshooting:</p>
<pre><code class="language-bash">swissarmyhammer serve --debug
</code></pre>
<p>Debug mode provides:</p>
<ul>
<li>Detailed logging of MCP communication</li>
<li>Prompt loading information</li>
<li>Error stack traces</li>
<li>Performance metrics</li>
</ul>
<h3 id="logs-and-diagnostics"><a class="header" href="#logs-and-diagnostics">Logs and Diagnostics</a></h3>
<h4 id="server-logs"><a class="header" href="#server-logs">Server Logs</a></h4>
<p>SwissArmyHammer logs to standard output:</p>
<pre><code class="language-bash"># Save logs to file
swissarmyhammer serve --debug &gt; swissarmyhammer.log 2&gt;&amp;1
</code></pre>
<h4 id="claude-code-logs"><a class="header" href="#claude-code-logs">Claude Code Logs</a></h4>
<p>Check Claude Code logs for MCP-related issues:</p>
<pre><code class="language-bash"># Location varies by platform
# macOS: ~/Library/Logs/Claude Code/
# Linux: ~/.local/share/claude-code/logs/
# Windows: %APPDATA%/Claude Code/logs/
</code></pre>
<h4 id="health-check"><a class="header" href="#health-check">Health Check</a></h4>
<p>Use the doctor command to check configuration:</p>
<pre><code class="language-bash">swissarmyhammer doctor
</code></pre>
<p>This checks:</p>
<ul>
<li>Installation status</li>
<li>Configuration validity</li>
<li>Prompt directory accessibility</li>
<li>MCP server functionality</li>
</ul>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="1-organize-prompts-logically"><a class="header" href="#1-organize-prompts-logically">1. Organize Prompts Logically</a></h3>
<p>Structure prompts by workflow rather than just topic:</p>
<pre><code>prompts/
â”œâ”€â”€ workflows/
â”‚   â”œâ”€â”€ code-review-workflow.md
â”‚   â”œâ”€â”€ feature-development.md
â”‚   â””â”€â”€ bug-fixing.md
â”œâ”€â”€ utilities/
â”‚   â”œâ”€â”€ format-code.md
â”‚   â”œâ”€â”€ generate-tests.md
â”‚   â””â”€â”€ extract-docs.md
</code></pre>
<h3 id="2-use-descriptive-metadata"><a class="header" href="#2-use-descriptive-metadata">2. Use Descriptive Metadata</a></h3>
<p>Make prompts discoverable with good metadata:</p>
<pre><code class="language-yaml">---
name: comprehensive-code-review
title: Comprehensive Code Review
description: Deep analysis of code for security, performance, and maintainability
category: development
tags: ["security", "performance", "maintainability", "best-practices"]
keywords: ["static analysis", "code quality", "peer review"]
---
</code></pre>
<h3 id="3-test-prompts-regularly"><a class="header" href="#3-test-prompts-regularly">3. Test Prompts Regularly</a></h3>
<p>Validate prompts before using in Claude Code:</p>
<pre><code class="language-bash"># Test basic functionality
swissarmyhammer test code-review --code "def hello(): print('hi')"

# Test all prompts
swissarmyhammer test --all
</code></pre>
<h3 id="4-use-project-specific-configurations"><a class="header" href="#4-use-project-specific-configurations">4. Use Project-Specific Configurations</a></h3>
<p>Create project-specific prompt collections:</p>
<pre><code class="language-bash"># Per-project MCP server
cd my-project
claude mcp add project_prompts swissarmyhammer serve --prompts ./prompts
</code></pre>
<h3 id="5-keep-prompts-updated"><a class="header" href="#5-keep-prompts-updated">5. Keep Prompts Updated</a></h3>
<p>Maintain prompt quality:</p>
<pre><code class="language-yaml">---
name: my-prompt
version: 1.2.0
updated: 2024-03-20  # Track changes
---
</code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="complete-setup-example"><a class="header" href="#complete-setup-example">Complete Setup Example</a></h3>
<p>Hereâ€™s a complete example of setting up SwissArmyHammer for a development project:</p>
<pre><code class="language-bash"># 1. Install SwissArmyHammer
curl -sSL https://raw.githubusercontent.com/wballard/swissarmyhammer/main/install.sh | bash

# 2. Create project prompts
mkdir -p ./prompts/development
cat &gt; ./prompts/development/project-review.md &lt;&lt; 'EOF'
---
name: project-code-review
title: Project Code Review
description: Reviews code according to our project standards
category: development
arguments:
  - name: code
    description: Code to review
    required: true
  - name: component
    description: Which component this code belongs to
    required: false
    default: general
---

# Project Code Review

Please review this {{component}} code according to our project standards:

```{{code}}```

Check for:
- Adherence to our coding standards
- Security best practices
- Performance considerations
- Documentation completeness
- Test coverage

Provide specific, actionable feedback.
EOF

# 3. Configure Claude Code
claude mcp add project_sah swissarmyhammer serve --prompts ./prompts

# 4. Test the setup
swissarmyhammer test project-code-review --code "print('hello')" --component "utility"

# 5. Start using in Claude Code
echo "Setup complete! Restart Claude Code to use your prompts."
</code></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li>Explore <a href="./builtin-prompts.html">Built-in Prompts</a> to see whatâ€™s available</li>
<li>Learn <a href="./creating-prompts.html">Creating Prompts</a> to build custom prompts</li>
<li>Read about <a href="./prompt-organization.html">Prompt Organization</a> strategies</li>
<li>Check the <a href="./cli-reference.html">CLI Reference</a> for all available commands</li>
<li>See <a href="./troubleshooting.html">Troubleshooting</a> for additional help</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command Line Interface</a></h1>
<p>SwissArmyHammer provides a comprehensive command-line interface for managing prompts, running the MCP server, and integrating with your development workflow.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<pre><code class="language-bash"># Install from Git repository (requires Rust)
cargo install --git https://github.com/wballard/swissarmyhammer.git swissarmyhammer-cli

# Ensure ~/.cargo/bin is in your PATH
export PATH="$HOME/.cargo/bin:$PATH"
</code></pre>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<pre><code class="language-bash">swissarmyhammer [COMMAND] [OPTIONS]
</code></pre>
<h2 id="global-options"><a class="header" href="#global-options">Global Options</a></h2>
<ul>
<li><code>--help, -h</code> - Display help information</li>
<li><code>--version, -V</code> - Display version information</li>
</ul>
<h2 id="commands-overview"><a class="header" href="#commands-overview">Commands Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="./cli-serve.html"><code>serve</code></a></td><td>Run as MCP server for Claude Code integration</td></tr>
<tr><td><a href="./cli-search.html"><code>search</code></a></td><td>Search and discover prompts with powerful filtering</td></tr>
<tr><td><a href="./cli-test.html"><code>test</code></a></td><td>Interactively test prompts with arguments</td></tr>
<tr><td><a href="./cli-doctor.html"><code>doctor</code></a></td><td>Diagnose configuration and setup issues</td></tr>
<tr><td><a href="./cli-completion.html"><code>completion</code></a></td><td>Generate shell completion scripts</td></tr>
</tbody></table>
</div>
<h2 id="quick-examples"><a class="header" href="#quick-examples">Quick Examples</a></h2>
<h3 id="start-mcp-server"><a class="header" href="#start-mcp-server">Start MCP Server</a></h3>
<pre><code class="language-bash"># Run as MCP server (for Claude Code)
swissarmyhammer serve
</code></pre>
<h3 id="search-for-prompts"><a class="header" href="#search-for-prompts">Search for Prompts</a></h3>
<pre><code class="language-bash"># Search for code-related prompts
swissarmyhammer search code

# Search with regex in descriptions
swissarmyhammer search --regex "test.*unit" --in description
</code></pre>
<h3 id="test-a-prompt"><a class="header" href="#test-a-prompt">Test a Prompt</a></h3>
<pre><code class="language-bash"># Interactively test a prompt
swissarmyhammer test code-review

# Test with predefined arguments
swissarmyhammer test code-review --arg code="fn main() { println!(\"Hello\"); }"
</code></pre>
<h3 id="check-setup"><a class="header" href="#check-setup">Check Setup</a></h3>
<pre><code class="language-bash"># Diagnose any configuration issues
swissarmyhammer doctor
</code></pre>
<h3 id="generate-shell-completions"><a class="header" href="#generate-shell-completions">Generate Shell Completions</a></h3>
<pre><code class="language-bash"># Generate Bash completions
swissarmyhammer completion bash &gt; ~/.bash_completion.d/swissarmyhammer

# Generate Zsh completions
swissarmyhammer completion zsh &gt; ~/.zfunc/_swissarmyhammer
</code></pre>
<h2 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h2>
<ul>
<li><code>0</code> - Success</li>
<li><code>1</code> - General error</li>
<li><code>2</code> - Command line usage error</li>
<li><code>3</code> - Configuration error</li>
<li><code>4</code> - Prompt not found</li>
<li><code>5</code> - Template rendering error</li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>SwissArmyHammer looks for prompts in these directories (in order):</p>
<ol>
<li>Built-in prompts (embedded in the binary)</li>
<li>User prompts: <code>~/.swissarmyhammer/prompts/</code></li>
<li>Local prompts: <code>./prompts/</code> (current directory)</li>
</ol>
<p>For detailed command documentation, see the individual command pages linked in the table above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serve-command"><a class="header" href="#serve-command">serve Command</a></h1>
<p>The <code>serve</code> command starts SwissArmyHammer as a Model Context Protocol (MCP) server, making your prompts available to Claude Code and other MCP clients.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-bash">swissarmyhammer serve [OPTIONS]
</code></pre>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The serve command:</p>
<ul>
<li>Starts an MCP server that provides access to your prompt library</li>
<li>Loads prompts from various directories (built-in, user, local)</li>
<li>Watches for file changes and automatically reloads prompts</li>
<li>Provides real-time access to prompts for Claude Code integration</li>
</ul>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<h3 id="--port-port"><a class="header" href="#--port-port"><code>--port &lt;PORT&gt;</code></a></h3>
<ul>
<li><strong>Description</strong>: Port number for MCP communication</li>
<li><strong>Default</strong>: Automatically assigned by the system</li>
<li><strong>Example</strong>: <code>--port 8080</code></li>
</ul>
<pre><code class="language-bash">swissarmyhammer serve --port 8080
</code></pre>
<h3 id="--host-host"><a class="header" href="#--host-host"><code>--host &lt;HOST&gt;</code></a></h3>
<ul>
<li><strong>Description</strong>: Host address to bind the server to</li>
<li><strong>Default</strong>: <code>localhost</code></li>
<li><strong>Example</strong>: <code>--host 127.0.0.1</code></li>
</ul>
<pre><code class="language-bash">swissarmyhammer serve --host 127.0.0.1
</code></pre>
<h3 id="--prompts-directory"><a class="header" href="#--prompts-directory"><code>--prompts &lt;DIRECTORY&gt;</code></a></h3>
<ul>
<li><strong>Description</strong>: Additional directories to load prompts from</li>
<li><strong>Default</strong>: Standard locations (<code>~/.swissarmyhammer/prompts</code>, <code>./prompts</code>)</li>
<li><strong>Repeatable</strong>: Can be used multiple times</li>
<li><strong>Example</strong>: <code>--prompts ./custom-prompts</code></li>
</ul>
<pre><code class="language-bash"># Single custom directory
swissarmyhammer serve --prompts ./project-prompts

# Multiple directories
swissarmyhammer serve --prompts ./prompts --prompts ~/.custom-prompts
</code></pre>
<h3 id="--builtin-boolean"><a class="header" href="#--builtin-boolean"><code>--builtin &lt;BOOLEAN&gt;</code></a></h3>
<ul>
<li><strong>Description</strong>: Include built-in prompts in the library</li>
<li><strong>Default</strong>: <code>true</code></li>
<li><strong>Values</strong>: <code>true</code>, <code>false</code></li>
<li><strong>Example</strong>: <code>--builtin false</code></li>
</ul>
<pre><code class="language-bash"># Disable built-in prompts
swissarmyhammer serve --builtin false

# Explicitly enable built-in prompts
swissarmyhammer serve --builtin true
</code></pre>
<h3 id="--watch-boolean"><a class="header" href="#--watch-boolean"><code>--watch &lt;BOOLEAN&gt;</code></a></h3>
<ul>
<li><strong>Description</strong>: Enable file watching for automatic prompt reloading</li>
<li><strong>Default</strong>: <code>true</code></li>
<li><strong>Values</strong>: <code>true</code>, <code>false</code></li>
<li><strong>Example</strong>: <code>--watch false</code></li>
</ul>
<pre><code class="language-bash"># Disable file watching (for performance)
swissarmyhammer serve --watch false
</code></pre>
<h3 id="--debug"><a class="header" href="#--debug"><code>--debug</code></a></h3>
<ul>
<li><strong>Description</strong>: Enable debug logging for troubleshooting</li>
<li><strong>Default</strong>: Disabled</li>
<li><strong>Output</strong>: Detailed logs to stdout</li>
</ul>
<pre><code class="language-bash">swissarmyhammer serve --debug
</code></pre>
<h3 id="--config-file"><a class="header" href="#--config-file"><code>--config &lt;FILE&gt;</code></a></h3>
<ul>
<li><strong>Description</strong>: Path to configuration file</li>
<li><strong>Default</strong>: <code>~/.swissarmyhammer/config.toml</code></li>
<li><strong>Example</strong>: <code>--config ./custom-config.toml</code></li>
</ul>
<pre><code class="language-bash">swissarmyhammer serve --config ./project-config.toml
</code></pre>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="basic-server"><a class="header" href="#basic-server">Basic Server</a></h3>
<p>Start a basic MCP server with default settings:</p>
<pre><code class="language-bash">swissarmyhammer serve
</code></pre>
<p>This loads:</p>
<ul>
<li>Built-in prompts</li>
<li>User prompts from <code>~/.swissarmyhammer/prompts/</code></li>
<li>Local prompts from <code>./prompts/</code> (if exists)</li>
<li>Enables file watching</li>
</ul>
<h3 id="development-server"><a class="header" href="#development-server">Development Server</a></h3>
<p>For development with debug logging:</p>
<pre><code class="language-bash">swissarmyhammer serve --debug
</code></pre>
<p>Output includes:</p>
<ul>
<li>Prompt loading details</li>
<li>MCP protocol messages</li>
<li>File watching events</li>
<li>Error stack traces</li>
</ul>
<h3 id="custom-prompt-directory"><a class="header" href="#custom-prompt-directory">Custom Prompt Directory</a></h3>
<p>Serve prompts from a specific directory:</p>
<pre><code class="language-bash">swissarmyhammer serve --prompts /path/to/my/prompts
</code></pre>
<h3 id="multiple-directories"><a class="header" href="#multiple-directories">Multiple Directories</a></h3>
<p>Load prompts from multiple locations:</p>
<pre><code class="language-bash">swissarmyhammer serve \
  --prompts ./project-prompts \
  --prompts ~/.shared-prompts \
  --prompts /team/common-prompts
</code></pre>
<h3 id="project-only-prompts"><a class="header" href="#project-only-prompts">Project-Only Prompts</a></h3>
<p>Serve only local project prompts (no built-in or user prompts):</p>
<pre><code class="language-bash">swissarmyhammer serve \
  --prompts ./prompts \
  --builtin false
</code></pre>
<h3 id="performance-optimized"><a class="header" href="#performance-optimized">Performance-Optimized</a></h3>
<p>For large prompt collections, disable file watching:</p>
<pre><code class="language-bash">swissarmyhammer serve \
  --watch false \
  --prompts ./large-prompt-collection
</code></pre>
<h3 id="custom-port-and-host"><a class="header" href="#custom-port-and-host">Custom Port and Host</a></h3>
<p>Specify network settings:</p>
<pre><code class="language-bash">swissarmyhammer serve \
  --host 0.0.0.0 \
  --port 9000
</code></pre>
<h2 id="prompt-loading-order"><a class="header" href="#prompt-loading-order">Prompt Loading Order</a></h2>
<p>SwissArmyHammer loads prompts in this order:</p>
<ol>
<li>
<p><strong>Built-in prompts</strong> (if <code>--builtin true</code>)</p>
<ul>
<li>Located in the binary</li>
<li>Categories: development, writing, analysis, etc.</li>
</ul>
</li>
<li>
<p><strong>User prompts</strong> (always loaded)</p>
<ul>
<li>Location: <code>~/.swissarmyhammer/prompts/</code></li>
<li>Your personal prompt library</li>
</ul>
</li>
<li>
<p><strong>Custom directories</strong> (from <code>--prompts</code> flags)</p>
<ul>
<li>Processed in order specified</li>
<li>Can override earlier prompts with same name</li>
</ul>
</li>
<li>
<p><strong>Local prompts</strong> (always checked)</p>
<ul>
<li>Location: <code>./prompts/</code> in current directory</li>
<li>Project-specific prompts</li>
</ul>
</li>
</ol>
<h3 id="prompt-override-behavior"><a class="header" href="#prompt-override-behavior">Prompt Override Behavior</a></h3>
<p>When prompts have the same name:</p>
<ul>
<li><strong>Later sources override earlier ones</strong></li>
<li><strong>Local prompts have highest priority</strong></li>
<li><strong>Built-in prompts have lowest priority</strong></li>
</ul>
<p>Example hierarchy:</p>
<pre><code>./prompts/code-review.md          (highest priority)
~/.custom/code-review.md          (from --prompts ~/.custom)
~/.swissarmyhammer/prompts/code-review.md  (user prompts)
built-in:code-review              (lowest priority)
</code></pre>
<h2 id="file-watching"><a class="header" href="#file-watching">File Watching</a></h2>
<p>When file watching is enabled (<code>--watch true</code>), the server automatically:</p>
<h3 id="detects-changes"><a class="header" href="#detects-changes">Detects Changes</a></h3>
<ul>
<li>New prompt files added</li>
<li>Existing prompt files modified</li>
<li>Prompt files deleted</li>
<li>Directory structure changes</li>
</ul>
<h3 id="reloads-prompts"><a class="header" href="#reloads-prompts">Reloads Prompts</a></h3>
<ul>
<li>Parses updated files</li>
<li>Validates YAML front matter</li>
<li>Updates the prompt library</li>
<li>Notifies connected MCP clients</li>
</ul>
<h3 id="handles-errors"><a class="header" href="#handles-errors">Handles Errors</a></h3>
<ul>
<li>Invalid YAML syntax</li>
<li>Missing required fields</li>
<li>Template compilation errors</li>
<li>Logs errors without stopping the server</li>
</ul>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<p>File watching uses system resources:</p>
<ul>
<li><strong>Memory</strong>: Stores file metadata</li>
<li><strong>CPU</strong>: Processes file system events</li>
<li><strong>Disk I/O</strong>: Reads modified files</li>
</ul>
<p>For large prompt collections (1000+ files), consider:</p>
<pre><code class="language-bash"># Disable watching for better performance
swissarmyhammer serve --watch false
</code></pre>
<h2 id="mcp-protocol-details"><a class="header" href="#mcp-protocol-details">MCP Protocol Details</a></h2>
<h3 id="server-capabilities"><a class="header" href="#server-capabilities">Server Capabilities</a></h3>
<p>SwissArmyHammer advertises these MCP capabilities:</p>
<pre><code class="language-json">{
  "capabilities": {
    "prompts": {
      "listChanged": true
    },
    "tools": {
      "listChanged": false
    }
  }
}
</code></pre>
<h3 id="prompt-exposure"><a class="header" href="#prompt-exposure">Prompt Exposure</a></h3>
<p>Each prompt becomes an MCP prompt with:</p>
<ul>
<li><strong>Name</strong>: From promptâ€™s <code>name</code> field</li>
<li><strong>Description</strong>: From promptâ€™s <code>description</code> field</li>
<li><strong>Arguments</strong>: From promptâ€™s <code>arguments</code> array</li>
</ul>
<h3 id="example-mcp-prompt"><a class="header" href="#example-mcp-prompt">Example MCP Prompt</a></h3>
<p>A SwissArmyHammer prompt:</p>
<pre><code class="language-yaml">---
name: code-review
title: Code Review Assistant
description: Reviews code for best practices and issues
arguments:
  - name: code
    description: Code to review
    required: true
  - name: language
    description: Programming language
    required: false
    default: auto-detect
---
</code></pre>
<p>Becomes this MCP prompt:</p>
<pre><code class="language-json">{
  "name": "code-review",
  "description": "Reviews code for best practices and issues",
  "arguments": [
    {
      "name": "code",
      "description": "Code to review",
      "required": true
    },
    {
      "name": "language", 
      "description": "Programming language",
      "required": false
    }
  ]
}
</code></pre>
<h2 id="integration-with-claude-code"><a class="header" href="#integration-with-claude-code">Integration with Claude Code</a></h2>
<h3 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h3>
<p>Add SwissArmyHammer to Claude Codeâ€™s MCP configuration:</p>
<pre><code class="language-bash">claude mcp add swissarmyhammer swissarmyhammer serve
</code></pre>
<h3 id="custom-configuration"><a class="header" href="#custom-configuration">Custom Configuration</a></h3>
<p>Add with specific options:</p>
<pre><code class="language-bash">claude mcp add project_sah swissarmyhammer serve --prompts ./project-prompts --debug
</code></pre>
<h3 id="multiple-servers"><a class="header" href="#multiple-servers">Multiple Servers</a></h3>
<p>Run different SwissArmyHammer instances:</p>
<pre><code class="language-bash"># Global prompts
claude mcp add sah_global swissarmyhammer serve

# Project-specific prompts  
claude mcp add sah_project swissarmyhammer serve --prompts ./prompts --builtin false
</code></pre>
<h2 id="logging-and-output"><a class="header" href="#logging-and-output">Logging and Output</a></h2>
<h3 id="standard-output"><a class="header" href="#standard-output">Standard Output</a></h3>
<p>Normal operation logs:</p>
<pre><code>2024-03-20T10:30:00Z INFO SwissArmyHammer MCP Server starting
2024-03-20T10:30:00Z INFO Loaded 25 prompts from 3 directories
2024-03-20T10:30:00Z INFO Server listening on localhost:8080
2024-03-20T10:30:00Z INFO MCP client connected
</code></pre>
<h3 id="debug-output"><a class="header" href="#debug-output">Debug Output</a></h3>
<p>With <code>--debug</code> flag:</p>
<pre><code>2024-03-20T10:30:00Z DEBUG Loading prompts from: ~/.swissarmyhammer/prompts
2024-03-20T10:30:00Z DEBUG Found prompt file: code-review.md
2024-03-20T10:30:00Z DEBUG Parsed prompt: code-review (Code Review Assistant)
2024-03-20T10:30:00Z DEBUG MCP request: prompts/list
2024-03-20T10:30:00Z DEBUG MCP response: 25 prompts returned
</code></pre>
<h3 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h3>
<p>The server continues running even with errors:</p>
<pre><code>2024-03-20T10:30:00Z ERROR Failed to parse prompt: invalid-prompt.md
2024-03-20T10:30:00Z ERROR   YAML error: missing required field 'description'
2024-03-20T10:30:00Z INFO  Continuing with 24 valid prompts
</code></pre>
<h2 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h2>
<h3 id="server-wont-start"><a class="header" href="#server-wont-start">Server Wonâ€™t Start</a></h3>
<p><strong>Check port availability:</strong></p>
<pre><code class="language-bash"># Try a specific port
swissarmyhammer serve --port 8080

# Check if port is in use
lsof -i :8080  # macOS/Linux
netstat -an | findstr 8080  # Windows
</code></pre>
<p><strong>Check permissions:</strong></p>
<pre><code class="language-bash"># Run with debug to see detailed errors
swissarmyhammer serve --debug
</code></pre>
<h3 id="prompts-not-loading-1"><a class="header" href="#prompts-not-loading-1">Prompts Not Loading</a></h3>
<p><strong>Verify directories exist:</strong></p>
<pre><code class="language-bash"># Check default directories
ls -la ~/.swissarmyhammer/prompts
ls -la ./prompts

# Check custom directories
ls -la /path/to/custom/prompts
</code></pre>
<p><strong>Validate prompt syntax:</strong></p>
<pre><code class="language-bash"># Test individual prompts
swissarmyhammer test prompt-name

# Validate all prompts
swissarmyhammer doctor
</code></pre>
<h3 id="performance-issues-1"><a class="header" href="#performance-issues-1">Performance Issues</a></h3>
<p><strong>Large prompt collections:</strong></p>
<pre><code class="language-bash"># Disable file watching
swissarmyhammer serve --watch false

# Limit to specific directories
swissarmyhammer serve --prompts ./essential-prompts --builtin false
</code></pre>
<p><strong>Memory usage:</strong></p>
<pre><code class="language-bash"># Monitor memory usage
top -p $(pgrep swissarmyhammer)  # Linux
top | grep swissarmyhammer       # macOS
</code></pre>
<h3 id="connection-issues"><a class="header" href="#connection-issues">Connection Issues</a></h3>
<p><strong>MCP client canâ€™t connect:</strong></p>
<pre><code class="language-bash"># Check server is running
ps aux | grep swissarmyhammer

# Test with different host/port
swissarmyhammer serve --host 127.0.0.1 --port 8080

# Check firewall settings
</code></pre>
<p><strong>Debug MCP communication:</strong></p>
<pre><code class="language-bash"># Enable debug logging
swissarmyhammer serve --debug

# Save logs to file
swissarmyhammer serve --debug &gt; server.log 2&gt;&amp;1
</code></pre>
<h2 id="configuration-file"><a class="header" href="#configuration-file">Configuration File</a></h2>
<p>Create a configuration file for persistent settings:</p>
<pre><code class="language-toml"># ~/.swissarmyhammer/config.toml

[server]
host = "localhost"
port = 8080
debug = false

[prompts]
builtin = true
watch = true
directories = [
    "~/.swissarmyhammer/prompts",
    "./prompts",
    "/team/shared-prompts"
]
</code></pre>
<p>Use with:</p>
<pre><code class="language-bash">swissarmyhammer serve --config ~/.swissarmyhammer/config.toml
</code></pre>
<h2 id="environment-variables-2"><a class="header" href="#environment-variables-2">Environment Variables</a></h2>
<p>Configure through environment variables:</p>
<pre><code class="language-bash">export SWISSARMYHAMMER_HOST=localhost
export SWISSARMYHAMMER_PORT=8080
export SWISSARMYHAMMER_DEBUG=true
export SWISSARMYHAMMER_PROMPTS_DIR=/custom/prompts

swissarmyhammer serve
</code></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="1-use-consistent-directory-structure"><a class="header" href="#1-use-consistent-directory-structure">1. Use Consistent Directory Structure</a></h3>
<pre><code>~/.swissarmyhammer/prompts/
â”œâ”€â”€ development/
â”œâ”€â”€ writing/
â”œâ”€â”€ analysis/
â””â”€â”€ productivity/
</code></pre>
<h3 id="2-enable-debug-during-development"><a class="header" href="#2-enable-debug-during-development">2. Enable Debug During Development</a></h3>
<pre><code class="language-bash">swissarmyhammer serve --debug
</code></pre>
<h3 id="3-use-project-specific-servers"><a class="header" href="#3-use-project-specific-servers">3. Use Project-Specific Servers</a></h3>
<pre><code class="language-bash"># In each project
claude mcp add project_sah swissarmyhammer serve --prompts ./prompts
</code></pre>
<h3 id="4-monitor-performance"><a class="header" href="#4-monitor-performance">4. Monitor Performance</a></h3>
<pre><code class="language-bash"># For large collections
swissarmyhammer serve --watch false --debug
</code></pre>
<h3 id="5-version-control-integration"><a class="header" href="#5-version-control-integration">5. Version Control Integration</a></h3>
<pre><code class="language-bash"># .gitignore
.swissarmyhammer/cache/
.swissarmyhammer/logs/

# Keep prompts in version control
git add prompts/
</code></pre>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li>Learn about <a href="./claude-code-integration.html">Claude Code Integration</a> setup</li>
<li>Explore <a href="./configuration.html">Configuration</a> options</li>
<li>See <a href="./troubleshooting.html">Troubleshooting</a> for common issues</li>
<li>Check <a href="./builtin-prompts.html">Built-in Prompts</a> reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search---search-and-discover-prompts"><a class="header" href="#search---search-and-discover-prompts">search - Search and Discover Prompts</a></h1>
<p>The <code>search</code> command provides powerful functionality to find prompts in your collection using various search strategies and filters.</p>
<h2 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h2>
<pre><code class="language-bash">swissarmyhammer search [OPTIONS] [QUERY]
</code></pre>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>Search through your prompt collection using fuzzy matching, regular expressions, or exact text matching. The search can target specific fields and provides relevance-ranked results.</p>
<h2 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h2>
<ul>
<li><code>QUERY</code> - Search term or pattern (optional if using filters)</li>
</ul>
<h2 id="options-1"><a class="header" href="#options-1">Options</a></h2>
<h3 id="search-strategy"><a class="header" href="#search-strategy">Search Strategy</a></h3>
<ul>
<li><code>--case-sensitive, -c</code> - Enable case-sensitive matching</li>
<li><code>--regex, -r</code> - Use regular expressions instead of fuzzy matching</li>
<li><code>--full, -f</code> - Show full prompt content in results</li>
</ul>
<h3 id="field-targeting"><a class="header" href="#field-targeting">Field Targeting</a></h3>
<ul>
<li><code>--in FIELD</code> - Search in specific field (title, description, content, all)
<ul>
<li><code>title</code> - Search only in prompt titles</li>
<li><code>description</code> - Search only in prompt descriptions</li>
<li><code>content</code> - Search only in prompt content/body</li>
<li><code>all</code> - Search in all fields (default)</li>
</ul>
</li>
</ul>
<h3 id="filtering"><a class="header" href="#filtering">Filtering</a></h3>
<ul>
<li><code>--source SOURCE</code> - Filter by prompt source (builtin, user, local)</li>
<li><code>--has-arg ARG</code> - Show prompts that have a specific argument</li>
<li><code>--no-args</code> - Show prompts with no arguments</li>
</ul>
<h3 id="output-control"><a class="header" href="#output-control">Output Control</a></h3>
<ul>
<li><code>--limit, -l N</code> - Limit results to N prompts (default: 20)</li>
<li><code>--json</code> - Output results in JSON format</li>
</ul>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="basic-search"><a class="header" href="#basic-search">Basic Search</a></h3>
<pre><code class="language-bash"># Find prompts containing "code"
swissarmyhammer search code

# Case-sensitive search
swissarmyhammer search --case-sensitive "Code Review"
</code></pre>
<h3 id="field-specific-search"><a class="header" href="#field-specific-search">Field-Specific Search</a></h3>
<pre><code class="language-bash"># Search only in titles
swissarmyhammer search --in title "review"

# Search only in descriptions
swissarmyhammer search --in description "debugging"

# Search in content/body
swissarmyhammer search --in content "TODO"
</code></pre>
<h3 id="regular-expression-search"><a class="header" href="#regular-expression-search">Regular Expression Search</a></h3>
<pre><code class="language-bash"># Find prompts with "test" followed by any word
swissarmyhammer search --regex "test\s+\w+"

# Find prompts starting with specific pattern
swissarmyhammer search --regex "^(debug|fix|analyze)"
</code></pre>
<h3 id="advanced-filtering"><a class="header" href="#advanced-filtering">Advanced Filtering</a></h3>
<pre><code class="language-bash"># Find built-in prompts only
swissarmyhammer search --source builtin

# Find prompts with "code" argument
swissarmyhammer search --has-arg code

# Find prompts without any arguments
swissarmyhammer search --no-args

# Combine filters
swissarmyhammer search review --source user --has-arg language
</code></pre>
<h3 id="output-options"><a class="header" href="#output-options">Output Options</a></h3>
<pre><code class="language-bash"># Show full content of matching prompts
swissarmyhammer search code --full

# Limit to 5 results
swissarmyhammer search --limit 5 test

# Get JSON output for scripting
swissarmyhammer search --json "data analysis"
</code></pre>
<h2 id="output-format-2"><a class="header" href="#output-format-2">Output Format</a></h2>
<h3 id="default-output"><a class="header" href="#default-output">Default Output</a></h3>
<pre><code>Found 3 prompts matching "code":

ğŸ“ code-review (builtin)
   Review code for best practices and potential issues
   Arguments: code, language (optional)

ğŸ”§ debug-code (user)
   Help debug programming issues and errors
   Arguments: error, context (optional)

ğŸ“Š analyze-performance (local)
   Analyze code performance and suggest optimizations
   Arguments: code, language, metrics (optional)
</code></pre>
<h3 id="json-output"><a class="header" href="#json-output">JSON Output</a></h3>
<pre><code class="language-json">{
  "query": "code",
  "results": [
    {
      "id": "code-review",
      "title": "Code Review Helper",
      "description": "Review code for best practices and potential issues",
      "source": "builtin",
      "path": "/builtin/review/code.md",
      "arguments": [
        {"name": "code", "required": true},
        {"name": "language", "required": false, "default": "auto-detect"}
      ],
      "score": 0.95
    }
  ],
  "total_found": 3
}
</code></pre>
<h2 id="search-scoring"><a class="header" href="#search-scoring">Search Scoring</a></h2>
<p>Results are ranked by relevance using these factors:</p>
<ol>
<li><strong>Exact matches</strong> score higher than partial matches</li>
<li><strong>Title matches</strong> score higher than description or content matches</li>
<li><strong>Multiple field matches</strong> increase the overall score</li>
<li><strong>Argument name matches</strong> are considered for relevance</li>
</ol>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<ul>
<li>Search is optimized with an in-memory index</li>
<li>Fuzzy matching uses efficient algorithms</li>
<li>Results are cached for repeated queries</li>
<li>Large prompt collections are handled efficiently</li>
</ul>
<h2 id="integration-with-other-commands"><a class="header" href="#integration-with-other-commands">Integration with Other Commands</a></h2>
<p>Search integrates well with other SwissArmyHammer commands:</p>
<pre><code class="language-bash"># Find and test a prompt
PROMPT=$(swissarmyhammer search --json code | jq -r '.results[0].id')
swissarmyhammer test "$PROMPT"

# Export search results
swissarmyhammer search debug --limit 5 | \
  grep -o '\w\+-\w\+' | \
  xargs swissarmyhammer export
</code></pre>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="./cli-test.html"><code>test</code></a> - Test prompts found through search</li>
<li><a href="./cli-export.html"><code>export</code></a> - Export specific prompts</li>
<li><a href="./search-guide.html">Search Guide</a> - Advanced search strategies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test---interactive-prompt-testing"><a class="header" href="#test---interactive-prompt-testing">test - Interactive Prompt Testing</a></h1>
<p>The <code>test</code> command allows you to test prompts interactively, providing argument values and seeing the rendered output before using them with AI models.</p>
<h2 id="synopsis-1"><a class="header" href="#synopsis-1">Synopsis</a></h2>
<pre><code class="language-bash">swissarmyhammer test [OPTIONS] &lt;PROMPT_ID&gt;
</code></pre>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>Test prompts interactively by providing arguments and viewing the rendered output. This is essential for debugging template issues, validating arguments, and refining prompts before deployment.</p>
<h2 id="arguments-4"><a class="header" href="#arguments-4">Arguments</a></h2>
<ul>
<li><code>PROMPT_ID</code> - The ID of the prompt to test (required)</li>
</ul>
<h2 id="options-2"><a class="header" href="#options-2">Options</a></h2>
<h3 id="argument-specification"><a class="header" href="#argument-specification">Argument Specification</a></h3>
<ul>
<li><code>--arg KEY=VALUE</code> - Provide argument values directly (can be used multiple times)</li>
</ul>
<h3 id="output-control-1"><a class="header" href="#output-control-1">Output Control</a></h3>
<ul>
<li><code>--raw</code> - Show raw template without rendering</li>
<li><code>--copy</code> - Copy rendered result to clipboard</li>
<li><code>--save FILE</code> - Save rendered result to file</li>
<li><code>--debug</code> - Show detailed debug information including variable resolution</li>
</ul>
<h2 id="interactive-mode"><a class="header" href="#interactive-mode">Interactive Mode</a></h2>
<p>When no <code>--arg</code> options are provided, the command enters interactive mode:</p>
<ol>
<li><strong>Prompt Selection</strong>: If prompt ID is ambiguous, presents a fuzzy selector</li>
<li><strong>Argument Collection</strong>: Prompts for each required and optional argument</li>
<li><strong>Template Rendering</strong>: Shows the rendered output</li>
<li><strong>Actions</strong>: Offers to copy to clipboard or save to file</li>
</ol>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<h3 id="interactive-testing"><a class="header" href="#interactive-testing">Interactive Testing</a></h3>
<pre><code class="language-bash"># Test a prompt interactively
swissarmyhammer test code-review

# The command will prompt for arguments:
# ? Enter value for 'code' (required): fn main() { println!("Hello"); }
# ? Enter value for 'language' (optional, default: auto-detect): rust
# 
# [Rendered output shows here]
# 
# ? What would you like to do?
#   &gt; View output
#     Copy to clipboard
#     Save to file
#     Test with different arguments
#     Exit
</code></pre>
<h3 id="non-interactive-testing"><a class="header" href="#non-interactive-testing">Non-Interactive Testing</a></h3>
<pre><code class="language-bash"># Test with predefined arguments
swissarmyhammer test code-review \
  --arg code="fn main() { println!(\"Hello\"); }" \
  --arg language="rust"

# Test and copy to clipboard
swissarmyhammer test debug-helper \
  --arg error="compiler error" \
  --copy

# Test and save output
swissarmyhammer test api-docs \
  --arg code="$(cat src/api.rs)" \
  --save generated-docs.md
</code></pre>
<h3 id="debug-mode-1"><a class="header" href="#debug-mode-1">Debug Mode</a></h3>
<pre><code class="language-bash"># Show debug information
swissarmyhammer test template-complex --debug

# Output includes:
# Variables resolved:
#   user_input: "example text"
#   timestamp: "2024-01-15T10:30:00Z"
#   
# Template processing:
#   Line 5: Variable 'user_input' resolved to "example text"
#   Line 12: Filter 'capitalize' applied
#   Line 18: Conditional block evaluated to true
#
# Final output:
# [rendered template]
</code></pre>
<h3 id="raw-template-view"><a class="header" href="#raw-template-view">Raw Template View</a></h3>
<pre><code class="language-bash"># View the raw template without rendering
swissarmyhammer test email-template --raw

# Shows:
# ---
# title: Email Template
# arguments:
#   - name: recipient
#     required: true
# ---
# 
# Dear {{recipient | capitalize}},
# 
# {% if urgent %}
# **URGENT:** 
# {% endif %}
# {{message}}
</code></pre>
<h2 id="output-format-3"><a class="header" href="#output-format-3">Output Format</a></h2>
<h3 id="default-output-1"><a class="header" href="#default-output-1">Default Output</a></h3>
<pre><code>Testing prompt: code-review

Arguments:
  code: "fn main() { println!(\"Hello\"); }"
  language: "rust" (default: auto-detect)

Rendered Output:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ # Code Review                                               â”‚
â”‚                                                             â”‚
â”‚ Please review the following rust code:                     â”‚
â”‚                                                             â”‚
â”‚ ```rust                                                     â”‚
â”‚ fn main() { println!("Hello"); }                           â”‚
â”‚ ```                                                         â”‚
â”‚                                                             â”‚
â”‚ Focus on:                                                   â”‚
â”‚ - Code quality and readability                             â”‚
â”‚ - Potential bugs or security issues                        â”‚
â”‚ - Performance considerations                                â”‚
â”‚ - Best practices adherence                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âœ“ Template rendered successfully (247 characters)
</code></pre>
<h3 id="debug-output-1"><a class="header" href="#debug-output-1">Debug Output</a></h3>
<pre><code>Testing prompt: code-review (debug mode)

Prompt loaded from: ~/.swissarmyhammer/prompts/review/code.md
Arguments defined: 2 (1 required, 1 optional)

Argument Resolution:
âœ“ code: "fn main() { println!(\"Hello\"); }" [user provided]
âœ“ language: "rust" [user provided, overrides default "auto-detect"]

Template Processing:
â†’ Line 8: Variable 'language' resolved and capitalized
â†’ Line 12-14: Code block with 'code' variable substitution
â†’ Line 16-20: Static bullet list rendered

Filters Applied:
- capitalize: "rust" â†’ "Rust"

Rendered Output:
[... same as above ...]

Performance:
- Template parsing: 2ms
- Variable resolution: 1ms
- Rendering: 3ms
- Total: 6ms
</code></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<p>The test command provides helpful error messages for common issues:</p>
<h3 id="missing-arguments"><a class="header" href="#missing-arguments">Missing Arguments</a></h3>
<pre><code class="language-bash">$ swissarmyhammer test code-review
Error: Missing required argument 'code'

Available arguments:
  code (required) - The code to review
  language (optional) - Programming language (default: auto-detect)

Use --arg KEY=VALUE to provide arguments, or run without --arg for interactive mode.
</code></pre>
<h3 id="template-errors"><a class="header" href="#template-errors">Template Errors</a></h3>
<pre><code class="language-bash">$ swissarmyhammer test broken-template --arg data="test"
Error: Template rendering failed at line 15

  13 | {% for item in items %}
  14 |   - {{item.name}}
&gt; 15 |   - {{item.invalid_field | unknown_filter}}
     |                           ^^^^^^^^^^^^^^
  16 | {% endfor %}

Unknown filter: unknown_filter
Available filters: capitalize, lower, upper, truncate, ...

Fix the template and try again.
</code></pre>
<h2 id="integration-with-development-workflow"><a class="header" href="#integration-with-development-workflow">Integration with Development Workflow</a></h2>
<h3 id="testing-before-deployment"><a class="header" href="#testing-before-deployment">Testing Before Deployment</a></h3>
<pre><code class="language-bash"># Test a prompt before adding to Claude Code
swissarmyhammer test new-prompt --debug

# Validate all prompts in a directory
for prompt in $(ls prompts/*.md); do
  swissarmyhammer test "${prompt%.md}" --arg placeholder="test"
done
</code></pre>
<h3 id="clipboard-integration"><a class="header" href="#clipboard-integration">Clipboard Integration</a></h3>
<pre><code class="language-bash"># Test and copy for immediate use
swissarmyhammer test quick-note \
  --arg content="Meeting notes" \
  --copy

# Now paste into your editor or Claude Code
</code></pre>
<h3 id="script-integration"><a class="header" href="#script-integration">Script Integration</a></h3>
<pre><code class="language-bash">#!/bin/bash
# test-and-deploy.sh

PROMPT_ID="$1"
if swissarmyhammer test "$PROMPT_ID" --arg test="validation"; then
  echo "âœ“ Prompt test passed, deploying..."
  swissarmyhammer export "$PROMPT_ID" --format directory deployment/
else
  echo "âœ— Prompt test failed, fix issues before deploying"
  exit 1
fi
</code></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="./cli-search.html"><code>search</code></a> - Find prompts to test</li>
<li><a href="./template-variables.html">Template Variables</a> - Template syntax reference</li>
<li><a href="./testing-guide.html">Testing Guide</a> - Advanced testing strategies</li>
<li><a href="./custom-filters.html">Custom Filters</a> - Available template filters</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doctor-command"><a class="header" href="#doctor-command">doctor Command</a></h1>
<p>The <code>doctor</code> command performs comprehensive health checks on your SwissArmyHammer installation and configuration. It identifies issues and provides recommendations for optimal operation.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code class="language-bash">swissarmyhammer doctor [OPTIONS]
</code></pre>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The doctor command checks:</p>
<ul>
<li>Installation integrity and version compatibility</li>
<li>Configuration file validity</li>
<li>Prompt directory accessibility and structure</li>
<li>Prompt file syntax and metadata</li>
<li>MCP server functionality</li>
<li>System dependencies and environment</li>
</ul>
<h2 id="options-3"><a class="header" href="#options-3">Options</a></h2>
<h3 id="--verbose"><a class="header" href="#--verbose"><code>--verbose</code></a></h3>
<ul>
<li><strong>Description</strong>: Enable detailed output with additional diagnostic information</li>
<li><strong>Default</strong>: Disabled</li>
<li><strong>Example</strong>: Shows file paths, configuration details, and system information</li>
</ul>
<pre><code class="language-bash">swissarmyhammer doctor --verbose
</code></pre>
<h3 id="--json"><a class="header" href="#--json"><code>--json</code></a></h3>
<ul>
<li><strong>Description</strong>: Output results in JSON format for programmatic use</li>
<li><strong>Default</strong>: Human-readable text output</li>
<li><strong>Example</strong>: Useful for scripts and automation</li>
</ul>
<pre><code class="language-bash">swissarmyhammer doctor --json
</code></pre>
<h3 id="--fix"><a class="header" href="#--fix"><code>--fix</code></a></h3>
<ul>
<li><strong>Description</strong>: Automatically fix issues when possible</li>
<li><strong>Default</strong>: Report-only mode</li>
<li><strong>Example</strong>: Creates missing directories, fixes permissions</li>
</ul>
<pre><code class="language-bash">swissarmyhammer doctor --fix
</code></pre>
<h3 id="--check-category"><a class="header" href="#--check-category"><code>--check &lt;CATEGORY&gt;</code></a></h3>
<ul>
<li><strong>Description</strong>: Run specific check categories only</li>
<li><strong>Values</strong>: <code>installation</code>, <code>config</code>, <code>prompts</code>, <code>mcp</code>, <code>system</code></li>
<li><strong>Repeatable</strong>: Can specify multiple categories</li>
</ul>
<pre><code class="language-bash"># Check only prompt-related issues
swissarmyhammer doctor --check prompts

# Check multiple categories
swissarmyhammer doctor --check config --check prompts
</code></pre>
<h2 id="check-categories"><a class="header" href="#check-categories">Check Categories</a></h2>
<h3 id="installation-checks"><a class="header" href="#installation-checks">Installation Checks</a></h3>
<p>Verifies SwissArmyHammer installation:</p>
<h4 id="binary-location"><a class="header" href="#binary-location">Binary Location</a></h4>
<ul>
<li>Checks if <code>swissarmyhammer</code> is in PATH</li>
<li>Verifies executable permissions</li>
<li>Confirms version compatibility</li>
</ul>
<h4 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h4>
<ul>
<li>Validates system requirements</li>
<li>Checks for required libraries</li>
<li>Verifies runtime dependencies</li>
</ul>
<h4 id="example-output"><a class="header" href="#example-output">Example Output</a></h4>
<pre><code>âœ“ SwissArmyHammer binary found: /usr/local/bin/swissarmyhammer
âœ“ Version: 0.1.0 (latest)
âœ“ Executable permissions: OK
âœ“ System dependencies: All present
</code></pre>
<h3 id="configuration-checks"><a class="header" href="#configuration-checks">Configuration Checks</a></h3>
<p>Validates configuration files and settings:</p>
<h4 id="configuration-file-1"><a class="header" href="#configuration-file-1">Configuration File</a></h4>
<ul>
<li>Checks for valid TOML syntax</li>
<li>Validates configuration schema</li>
<li>Identifies deprecated settings</li>
</ul>
<h4 id="directory-structure-3"><a class="header" href="#directory-structure-3">Directory Structure</a></h4>
<ul>
<li>Verifies default directories exist</li>
<li>Checks directory permissions</li>
<li>Validates custom prompt directories</li>
</ul>
<h4 id="environment-variables-3"><a class="header" href="#environment-variables-3">Environment Variables</a></h4>
<ul>
<li>Lists relevant environment variables</li>
<li>Checks for conflicts or inconsistencies</li>
<li>Validates variable values</li>
</ul>
<h4 id="example-output-1"><a class="header" href="#example-output-1">Example Output</a></h4>
<pre><code>âœ“ Configuration file: ~/.swissarmyhammer/config.toml
âœ“ Configuration syntax: Valid TOML
âœ“ Default directories: Created and accessible
âš  Custom directory not found: /nonexistent/prompts
âœ“ Environment variables: No conflicts
</code></pre>
<h3 id="prompt-checks"><a class="header" href="#prompt-checks">Prompt Checks</a></h3>
<p>Analyzes prompt files and library structure:</p>
<h4 id="directory-scanning"><a class="header" href="#directory-scanning">Directory Scanning</a></h4>
<ul>
<li>Scans all configured prompt directories</li>
<li>Counts prompt files by category</li>
<li>Identifies orphaned or miscategorized files</li>
</ul>
<h4 id="file-validation"><a class="header" href="#file-validation">File Validation</a></h4>
<ul>
<li>Validates YAML front matter syntax</li>
<li>Checks required fields presence</li>
<li>Verifies argument specifications</li>
</ul>
<h4 id="content-analysis"><a class="header" href="#content-analysis">Content Analysis</a></h4>
<ul>
<li>Validates Liquid template syntax</li>
<li>Checks for common template errors</li>
<li>Identifies missing or broken references</li>
</ul>
<h4 id="duplicate-detection"><a class="header" href="#duplicate-detection">Duplicate Detection</a></h4>
<ul>
<li>Finds prompts with identical names</li>
<li>Shows override hierarchy</li>
<li>Warns about potential conflicts</li>
</ul>
<h4 id="example-output-2"><a class="header" href="#example-output-2">Example Output</a></h4>
<pre><code>âœ“ Prompt directories: 3 found, all accessible
âœ“ Prompt files: 47 total, 45 valid
âœ— Invalid prompts: 2 files with errors
  - debug-helper.md: Missing required field 'description'
  - code-review.md: Invalid YAML syntax on line 8
âš  Duplicate names: 1 conflict found
  - 'help' defined in both builtin and ~/.swissarmyhammer/prompts/
âœ“ Template syntax: All valid
</code></pre>
<h3 id="mcp-checks"><a class="header" href="#mcp-checks">MCP Checks</a></h3>
<p>Tests Model Context Protocol functionality:</p>
<h4 id="server-startup"><a class="header" href="#server-startup">Server Startup</a></h4>
<ul>
<li>Attempts to start MCP server</li>
<li>Tests port binding</li>
<li>Verifies server responds to requests</li>
</ul>
<h4 id="protocol-compliance"><a class="header" href="#protocol-compliance">Protocol Compliance</a></h4>
<ul>
<li>Validates MCP protocol responses</li>
<li>Checks capability advertisements</li>
<li>Tests prompt exposure format</li>
</ul>
<h4 id="integration-status"><a class="header" href="#integration-status">Integration Status</a></h4>
<ul>
<li>Checks Claude Code configuration</li>
<li>Tests end-to-end connectivity</li>
<li>Validates prompt accessibility</li>
</ul>
<h4 id="example-output-3"><a class="header" href="#example-output-3">Example Output</a></h4>
<pre><code>âœ“ MCP server startup: Success on port 8080
âœ“ Protocol compliance: All tests passed
âœ“ Prompt exposure: 45 prompts available
âš  Claude Code integration: Not configured
  Run: claude mcp add swissarmyhammer swissarmyhammer serve
</code></pre>
<h3 id="system-checks"><a class="header" href="#system-checks">System Checks</a></h3>
<p>Analyzes system environment and performance:</p>
<h4 id="operating-system"><a class="header" href="#operating-system">Operating System</a></h4>
<ul>
<li>Identifies OS and version</li>
<li>Checks compatibility</li>
<li>Validates system requirements</li>
</ul>
<h4 id="file-system"><a class="header" href="#file-system">File System</a></h4>
<ul>
<li>Tests file watching capabilities</li>
<li>Checks disk space availability</li>
<li>Validates permissions</li>
</ul>
<h4 id="performance-1"><a class="header" href="#performance-1">Performance</a></h4>
<ul>
<li>Measures prompt loading time</li>
<li>Tests file watching responsiveness</li>
<li>Checks memory usage patterns</li>
</ul>
<h4 id="example-output-4"><a class="header" href="#example-output-4">Example Output</a></h4>
<pre><code>âœ“ Operating system: macOS 14.0 (supported)
âœ“ File system: APFS with file watching support
âœ“ Disk space: 15.2 GB available
âœ“ Performance: Prompt loading &lt; 100ms
âš  Memory usage: High with 1000+ prompts (consider --watch false)
</code></pre>
<h2 id="common-issues-and-solutions"><a class="header" href="#common-issues-and-solutions">Common Issues and Solutions</a></h2>
<h3 id="installation-issues"><a class="header" href="#installation-issues">Installation Issues</a></h3>
<h4 id="swissarmyhammer-not-found"><a class="header" href="#swissarmyhammer-not-found">SwissArmyHammer Not Found</a></h4>
<pre><code>âœ— SwissArmyHammer binary: Not found in PATH
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Install SwissArmyHammer: <code>curl -sSL https://install.sh | bash</code></li>
<li>Add to PATH: <code>export PATH="$HOME/.local/bin:$PATH"</code></li>
<li>Verify installation: <code>which swissarmyhammer</code></li>
</ul>
<h4 id="permission-denied"><a class="header" href="#permission-denied">Permission Denied</a></h4>
<pre><code>âœ— Executable permissions: Permission denied
</code></pre>
<p><strong>Solutions:</strong></p>
<pre><code class="language-bash"># Fix permissions
chmod +x $(which swissarmyhammer)

# Or reinstall
curl -sSL https://install.sh | bash
</code></pre>
<h3 id="configuration-issues"><a class="header" href="#configuration-issues">Configuration Issues</a></h3>
<h4 id="invalid-configuration-file"><a class="header" href="#invalid-configuration-file">Invalid Configuration File</a></h4>
<pre><code>âœ— Configuration syntax: Invalid TOML at line 15
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Validate TOML syntax online</li>
<li>Check for missing quotes or brackets</li>
<li>Reset to defaults: <code>swissarmyhammer doctor --fix</code></li>
</ul>
<h4 id="missing-directories"><a class="header" href="#missing-directories">Missing Directories</a></h4>
<pre><code>âš  Prompt directory not accessible: /custom/prompts
</code></pre>
<p><strong>Solutions:</strong></p>
<pre><code class="language-bash"># Create missing directory
mkdir -p /custom/prompts

# Fix automatically
swissarmyhammer doctor --fix
</code></pre>
<h3 id="prompt-issues"><a class="header" href="#prompt-issues">Prompt Issues</a></h3>
<h4 id="invalid-yaml-front-matter"><a class="header" href="#invalid-yaml-front-matter">Invalid YAML Front Matter</a></h4>
<pre><code>âœ— Invalid prompts: 3 files with YAML errors
  - code-review.md: missing required field 'name'
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Add missing required fields</li>
<li>Validate YAML syntax</li>
<li>Use <code>swissarmyhammer test &lt;prompt&gt;</code> for detailed errors</li>
</ul>
<h4 id="duplicate-prompt-names"><a class="header" href="#duplicate-prompt-names">Duplicate Prompt Names</a></h4>
<pre><code>âš  Duplicate names: 'help' defined in multiple locations
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Rename one of the conflicting prompts</li>
<li>Use different directories for different contexts</li>
<li>Check prompt override hierarchy</li>
</ul>
<h4 id="template-syntax-errors"><a class="header" href="#template-syntax-errors">Template Syntax Errors</a></h4>
<pre><code>âœ— Template errors: 2 prompts with Liquid syntax issues
  - debug.md: Unknown filter 'unknownfilter'
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Fix Liquid template syntax</li>
<li>Check available filters: see <a href="./custom-filters.html">Custom Filters</a></li>
<li>Test templates: <code>swissarmyhammer test &lt;prompt&gt;</code></li>
</ul>
<h3 id="mcp-issues"><a class="header" href="#mcp-issues">MCP Issues</a></h3>
<h4 id="server-wont-start-1"><a class="header" href="#server-wont-start-1">Server Wonâ€™t Start</a></h4>
<pre><code>âœ— MCP server startup: Failed to bind to port 8080
</code></pre>
<p><strong>Solutions:</strong></p>
<pre><code class="language-bash"># Try different port
swissarmyhammer serve --port 8081

# Check what's using the port
lsof -i :8080  # macOS/Linux
netstat -an | findstr 8080  # Windows
</code></pre>
<h4 id="claude-code-not-configured"><a class="header" href="#claude-code-not-configured">Claude Code Not Configured</a></h4>
<pre><code>âš  Claude Code integration: Not configured
</code></pre>
<p><strong>Solutions:</strong></p>
<pre><code class="language-bash"># Add to Claude Code
claude mcp add swissarmyhammer swissarmyhammer serve

# Verify configuration
claude mcp list
</code></pre>
<h3 id="performance-issues-2"><a class="header" href="#performance-issues-2">Performance Issues</a></h3>
<h4 id="slow-prompt-loading"><a class="header" href="#slow-prompt-loading">Slow Prompt Loading</a></h4>
<pre><code>âš  Performance: Prompt loading &gt; 1000ms
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Reduce prompt directory size</li>
<li>Disable file watching: <code>--watch false</code></li>
<li>Use SSDs for prompt storage</li>
<li>Split large libraries into categories</li>
</ul>
<h4 id="high-memory-usage"><a class="header" href="#high-memory-usage">High Memory Usage</a></h4>
<pre><code>âš  Memory usage: 2.1 GB with file watching enabled
</code></pre>
<p><strong>Solutions:</strong></p>
<pre><code class="language-bash"># Disable file watching
swissarmyhammer serve --watch false

# Limit prompt directories
swissarmyhammer serve --prompts ./essential-prompts
</code></pre>
<h2 id="automated-fixes"><a class="header" href="#automated-fixes">Automated Fixes</a></h2>
<p>With the <code>--fix</code> flag, doctor can automatically resolve:</p>
<h3 id="directory-issues"><a class="header" href="#directory-issues">Directory Issues</a></h3>
<ul>
<li>Creates missing prompt directories</li>
<li>Sets appropriate permissions</li>
<li>Creates default configuration file</li>
</ul>
<h3 id="configuration-issues-1"><a class="header" href="#configuration-issues-1">Configuration Issues</a></h3>
<ul>
<li>Repairs malformed TOML files</li>
<li>Sets missing default values</li>
<li>Removes deprecated settings</li>
</ul>
<h3 id="permission-issues"><a class="header" href="#permission-issues">Permission Issues</a></h3>
<ul>
<li>Fixes file and directory permissions</li>
<li>Makes binaries executable</li>
<li>Sets appropriate ownership</li>
</ul>
<h3 id="example-auto-fix"><a class="header" href="#example-auto-fix">Example Auto-Fix</a></h3>
<pre><code class="language-bash">swissarmyhammer doctor --fix

# Output:
Fixed: Created missing directory ~/.swissarmyhammer/prompts
Fixed: Set executable permission on swissarmyhammer binary
Fixed: Created default configuration file
Warning: Could not fix invalid YAML in code-review.md (manual intervention required)
</code></pre>
<h2 id="output-formats"><a class="header" href="#output-formats">Output Formats</a></h2>
<h3 id="human-readable-default"><a class="header" href="#human-readable-default">Human-Readable (Default)</a></h3>
<pre><code>SwissArmyHammer Doctor Report
============================

Installation Checks:
âœ“ Binary found and executable
âœ“ Version 0.1.0 (latest)
âœ“ Dependencies satisfied

Configuration Checks:
âœ“ Configuration file valid
âš  Custom directory not found: /tmp/prompts

Prompt Checks:
âœ“ 45 prompts loaded successfully
âœ— 2 prompts with errors (see details below)

MCP Checks:
âœ“ Server starts successfully
âœ“ Protocol compliance verified

System Checks:
âœ“ OS compatibility confirmed
âš  High memory usage detected

Summary: 3 warnings, 1 error found
</code></pre>
<h3 id="json-format"><a class="header" href="#json-format">JSON Format</a></h3>
<pre><code class="language-json">{
  "timestamp": "2024-03-20T10:30:00Z",
  "version": "0.1.0",
  "checks": {
    "installation": {
      "status": "passed",
      "details": [
        {
          "check": "binary_found",
          "status": "passed",
          "message": "Binary found at /usr/local/bin/swissarmyhammer"
        }
      ]
    },
    "configuration": {
      "status": "warning",
      "details": [
        {
          "check": "custom_directory",
          "status": "warning", 
          "message": "Directory not found: /tmp/prompts",
          "fixable": true
        }
      ]
    }
  },
  "summary": {
    "total_checks": 15,
    "passed": 12,
    "warnings": 2,
    "errors": 1
  }
}
</code></pre>
<h2 id="integration-with-cicd"><a class="header" href="#integration-with-cicd">Integration with CI/CD</a></h2>
<p>Use doctor in automated workflows:</p>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<pre><code class="language-yaml">- name: Check SwissArmyHammer Health
  run: |
    swissarmyhammer doctor --json &gt; health-report.json
    if [ $(jq '.summary.errors' health-report.json) -gt 0 ]; then
      echo "Health check failed"
      exit 1
    fi
</code></pre>
<h3 id="pre-commit-hook"><a class="header" href="#pre-commit-hook">Pre-commit Hook</a></h3>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit
swissarmyhammer doctor --check prompts
if [ $? -ne 0 ]; then
  echo "Prompt validation failed. Fix issues before committing."
  exit 1
fi
</code></pre>
<h3 id="development-script"><a class="header" href="#development-script">Development Script</a></h3>
<pre><code class="language-bash">#!/bin/bash
# dev-setup.sh
echo "Setting up development environment..."
swissarmyhammer doctor --fix --verbose
echo "Health check complete. Run 'swissarmyhammer serve' to start."
</code></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="regular-health-checks"><a class="header" href="#regular-health-checks">Regular Health Checks</a></h3>
<pre><code class="language-bash"># Weekly health check
swissarmyhammer doctor --verbose

# Before important deployments
swissarmyhammer doctor --check mcp --check prompts
</code></pre>
<h3 id="monitoring-integration"><a class="header" href="#monitoring-integration">Monitoring Integration</a></h3>
<pre><code class="language-bash"># Check and alert on issues
swissarmyhammer doctor --json | jq -r '.summary.errors' | \
  xargs -I {} sh -c 'if [ {} -gt 0 ]; then echo "Alert: SwissArmyHammer errors detected"; fi'
</code></pre>
<h3 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h3>
<pre><code class="language-bash"># After making prompt changes
swissarmyhammer doctor --check prompts --fix

# Before committing
swissarmyhammer doctor --check prompts
</code></pre>
<h2 id="troubleshooting-doctor-issues"><a class="header" href="#troubleshooting-doctor-issues">Troubleshooting Doctor Issues</a></h2>
<h3 id="doctor-command-not-found"><a class="header" href="#doctor-command-not-found">Doctor Command Not Found</a></h3>
<pre><code class="language-bash"># Verify installation
which swissarmyhammer

# Reinstall if needed
curl -sSL https://install.sh | bash
</code></pre>
<h3 id="doctor-hangs-or-crashes"><a class="header" href="#doctor-hangs-or-crashes">Doctor Hangs or Crashes</a></h3>
<pre><code class="language-bash"># Run with timeout
timeout 30s swissarmyhammer doctor --verbose

# Check specific categories
swissarmyhammer doctor --check installation
</code></pre>
<h3 id="false-positives"><a class="header" href="#false-positives">False Positives</a></h3>
<pre><code class="language-bash"># Skip problematic checks
swissarmyhammer doctor --check config --check prompts

# Use verbose mode for details
swissarmyhammer doctor --verbose
</code></pre>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li>Fix any issues identified by doctor</li>
<li>Set up regular health monitoring</li>
<li>Configure automated fixes where appropriate</li>
<li>See <a href="./troubleshooting.html">Troubleshooting</a> for detailed problem resolution</li>
<li>Check <a href="./configuration.html">Configuration</a> for advanced settings</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="completion"><a class="header" href="#completion">completion</a></h1>
<p>The <code>completion</code> command generates shell completion scripts for SwissArmyHammer, enabling tab completion for commands, options, and arguments in your shell.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><code class="language-bash">swissarmyhammer completion &lt;SHELL&gt;
</code></pre>
<h3 id="arguments-5"><a class="header" href="#arguments-5">Arguments</a></h3>
<ul>
<li><code>&lt;SHELL&gt;</code> - The shell to generate completions for (<code>bash</code>, <code>zsh</code>, <code>fish</code>, <code>powershell</code>, <code>elvish</code>)</li>
</ul>
<h2 id="supported-shells"><a class="header" href="#supported-shells">Supported Shells</a></h2>
<h3 id="bash"><a class="header" href="#bash">Bash</a></h3>
<p>Generate and install Bash completions:</p>
<pre><code class="language-bash"># Generate completion script
swissarmyhammer completion bash &gt; swissarmyhammer.bash

# Install for current user
mkdir -p ~/.local/share/bash-completion/completions
swissarmyhammer completion bash &gt; ~/.local/share/bash-completion/completions/swissarmyhammer

# Or install system-wide (requires sudo)
sudo swissarmyhammer completion bash &gt; /usr/share/bash-completion/completions/swissarmyhammer

# Source in current session
source ~/.local/share/bash-completion/completions/swissarmyhammer
</code></pre>
<p>Add to <code>~/.bashrc</code> for permanent installation:</p>
<pre><code class="language-bash"># Add SwissArmyHammer completions
if [ -f ~/.local/share/bash-completion/completions/swissarmyhammer ]; then
    source ~/.local/share/bash-completion/completions/swissarmyhammer
fi
</code></pre>
<h3 id="zsh"><a class="header" href="#zsh">Zsh</a></h3>
<p>Generate and install Zsh completions:</p>
<pre><code class="language-bash"># Generate completion script
swissarmyhammer completion zsh &gt; _swissarmyhammer

# Install to Zsh completions directory
# First, add custom completion directory to fpath in ~/.zshrc:
echo 'fpath=(~/.zsh/completions $fpath)' &gt;&gt; ~/.zshrc

# Create directory and install
mkdir -p ~/.zsh/completions
swissarmyhammer completion zsh &gt; ~/.zsh/completions/_swissarmyhammer

# Reload completions
autoload -U compinit &amp;&amp; compinit
</code></pre>
<p>For Oh My Zsh users:</p>
<pre><code class="language-bash"># Install to Oh My Zsh custom plugins
swissarmyhammer completion zsh &gt; ~/.oh-my-zsh/custom/plugins/swissarmyhammer/_swissarmyhammer
</code></pre>
<h3 id="fish"><a class="header" href="#fish">Fish</a></h3>
<p>Generate and install Fish completions:</p>
<pre><code class="language-bash"># Generate and install in one command
swissarmyhammer completion fish &gt; ~/.config/fish/completions/swissarmyhammer.fish

# Completions are automatically loaded in new shells
</code></pre>
<h3 id="powershell"><a class="header" href="#powershell">PowerShell</a></h3>
<p>Generate and install PowerShell completions:</p>
<pre><code class="language-powershell"># Generate completion script
swissarmyhammer completion powershell &gt; SwissArmyHammer.ps1

# Add to PowerShell profile
Add-Content $PROFILE "`n. $(pwd)\SwissArmyHammer.ps1"

# Or install to modules directory
$modulePath = "$env:USERPROFILE\Documents\PowerShell\Modules\SwissArmyHammer"
New-Item -ItemType Directory -Force -Path $modulePath
swissarmyhammer completion powershell &gt; "$modulePath\SwissArmyHammer.psm1"
</code></pre>
<h3 id="elvish"><a class="header" href="#elvish">Elvish</a></h3>
<p>Generate and install Elvish completions:</p>
<pre><code class="language-elvish"># Generate and install
swissarmyhammer completion elvish &gt; ~/.elvish/lib/swissarmyhammer.elv

# Add to rc.elv
echo "use swissarmyhammer" &gt;&gt; ~/.elvish/rc.elv
</code></pre>
<h2 id="what-gets-completed"><a class="header" href="#what-gets-completed">What Gets Completed</a></h2>
<p>The completion system provides intelligent suggestions for:</p>
<h3 id="commands"><a class="header" href="#commands">Commands</a></h3>
<pre><code class="language-bash">swissarmyhammer &lt;TAB&gt;
# Suggests: serve, list, doctor, export, import, completion, config
</code></pre>
<h3 id="command-options"><a class="header" href="#command-options">Command Options</a></h3>
<pre><code class="language-bash">swissarmyhammer serve --&lt;TAB&gt;
# Suggests: --port, --host, --debug, --watch, --prompts, etc.
</code></pre>
<h3 id="prompt-names"><a class="header" href="#prompt-names">Prompt Names</a></h3>
<pre><code class="language-bash">swissarmyhammer get &lt;TAB&gt;
# Suggests available prompt names from your library
</code></pre>
<h3 id="file-paths"><a class="header" href="#file-paths">File Paths</a></h3>
<pre><code class="language-bash">swissarmyhammer import &lt;TAB&gt;
# Suggests .tar.gz files in current directory

swissarmyhammer export output&lt;TAB&gt;
# Suggests: output.tar.gz
</code></pre>
<h3 id="configuration-keys"><a class="header" href="#configuration-keys">Configuration Keys</a></h3>
<pre><code class="language-bash">swissarmyhammer config set &lt;TAB&gt;
# Suggests: server.port, server.host, prompts.directories, etc.
</code></pre>
<h2 id="advanced-features-1"><a class="header" href="#advanced-features-1">Advanced Features</a></h2>
<h3 id="dynamic-completions"><a class="header" href="#dynamic-completions">Dynamic Completions</a></h3>
<p>Some completions are generated dynamically based on context:</p>
<pre><code class="language-bash"># Completes with actual prompt names from your library
swissarmyhammer get code-&lt;TAB&gt;
# Suggests: code-review, code-documentation, code-optimizer

# Completes with valid categories
swissarmyhammer list --category &lt;TAB&gt;
# Suggests: development, writing, data, productivity
</code></pre>
<h3 id="nested-completions"><a class="header" href="#nested-completions">Nested Completions</a></h3>
<p>Completions work with nested commands:</p>
<pre><code class="language-bash">swissarmyhammer config &lt;TAB&gt;
# Suggests: get, set, list, validate

swissarmyhammer config set server.&lt;TAB&gt;
# Suggests: server.port, server.host, server.debug
</code></pre>
<h3 id="alias-support"><a class="header" href="#alias-support">Alias Support</a></h3>
<p>If you create shell aliases, completions still work:</p>
<pre><code class="language-bash"># In .bashrc or .zshrc
alias sah='swissarmyhammer'

# Completions work with alias
sah serve --&lt;TAB&gt;
</code></pre>
<h2 id="troubleshooting-6"><a class="header" href="#troubleshooting-6">Troubleshooting</a></h2>
<h3 id="completions-not-working"><a class="header" href="#completions-not-working">Completions Not Working</a></h3>
<ol>
<li>
<p><strong>Check Installation Location</strong></p>
<pre><code class="language-bash"># Bash
ls ~/.local/share/bash-completion/completions/

# Zsh
echo $fpath
ls ~/.zsh/completions/

# Fish
ls ~/.config/fish/completions/
</code></pre>
</li>
<li>
<p><strong>Reload Shell Configuration</strong></p>
<pre><code class="language-bash"># Bash
source ~/.bashrc

# Zsh
source ~/.zshrc

# Fish
source ~/.config/fish/config.fish
</code></pre>
</li>
<li>
<p><strong>Check Completion System</strong></p>
<pre><code class="language-bash"># Bash
complete -p | grep swissarmyhammer

# Zsh
print -l ${(ok)_comps} | grep swissarmyhammer
</code></pre>
</li>
</ol>
<h3 id="slow-completions"><a class="header" href="#slow-completions">Slow Completions</a></h3>
<p>If completions are slow:</p>
<ol>
<li>
<p><strong>Enable Caching</strong> (Zsh)</p>
<pre><code class="language-zsh"># Add to ~/.zshrc
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/cache
</code></pre>
</li>
<li>
<p><strong>Reduce Dynamic Lookups</strong></p>
<pre><code class="language-bash"># Set static prompt directory
export SWISSARMYHAMMER_PROMPTS_DIR=~/.swissarmyhammer/prompts
</code></pre>
</li>
</ol>
<h3 id="missing-completions"><a class="header" href="#missing-completions">Missing Completions</a></h3>
<p>If some completions are missing:</p>
<pre><code class="language-bash"># Regenerate completions after updates
swissarmyhammer completion bash &gt; ~/.local/share/bash-completion/completions/swissarmyhammer

# Check SwissArmyHammer version
swissarmyhammer --version
</code></pre>
<h2 id="environment-variables-4"><a class="header" href="#environment-variables-4">Environment Variables</a></h2>
<p>Completions respect environment variables:</p>
<pre><code class="language-bash"># Complete with custom prompt directories
export SWISSARMYHAMMER_PROMPTS_DIRECTORIES="/opt/prompts,~/my-prompts"
swissarmyhammer list &lt;TAB&gt;
</code></pre>
<h2 id="integration-with-tools"><a class="header" href="#integration-with-tools">Integration with Tools</a></h2>
<h3 id="fzf-integration"><a class="header" href="#fzf-integration">fzf Integration</a></h3>
<p>Combine with fzf for fuzzy completion:</p>
<pre><code class="language-bash"># Add to .bashrc/.zshrc
_swissarmyhammer_fzf_complete() {
    swissarmyhammer list --format simple | fzf
}

# Use with Ctrl+T
bind '"\C-t": "$(_swissarmyhammer_fzf_complete)\e\C-e\er"'
</code></pre>
<h3 id="ide-integration"><a class="header" href="#ide-integration">IDE Integration</a></h3>
<p>Most IDEs can use shell completions:</p>
<h4 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h4>
<pre><code class="language-json">{
    "terminal.integrated.shellIntegration.enabled": true,
    "terminal.integrated.shellIntegration.suggestEnabled": true
}
</code></pre>
<h4 id="jetbrains-ides"><a class="header" href="#jetbrains-ides">JetBrains IDEs</a></h4>
<ul>
<li>Terminal automatically sources shell configuration</li>
<li>Completions work in integrated terminal</li>
</ul>
<h2 id="custom-completions"><a class="header" href="#custom-completions">Custom Completions</a></h2>
<h3 id="adding-custom-completions"><a class="header" href="#adding-custom-completions">Adding Custom Completions</a></h3>
<p>Create wrapper scripts with additional completions:</p>
<pre><code class="language-bash">#!/bin/bash
# my-swissarmyhammer-completions.bash

# Source original completions
source ~/.local/share/bash-completion/completions/swissarmyhammer

# Add custom completions
_my_custom_prompts() {
    COMPREPLY=($(compgen -W "my-prompt-1 my-prompt-2 my-prompt-3" -- ${COMP_WORDS[COMP_CWORD]}))
}

# Override prompt name completion
complete -F _my_custom_prompts swissarmyhammer get
</code></pre>
<h3 id="project-specific-completions"><a class="header" href="#project-specific-completions">Project-Specific Completions</a></h3>
<p>Add project-specific completions:</p>
<pre><code class="language-bash"># .envrc (direnv) or project script
_project_prompts() {
    ls ./prompts/*.md 2&gt;/dev/null | xargs -n1 basename | sed 's/\.md$//'
}

# Export for use in completions
export SWISSARMYHAMMER_PROJECT_PROMPTS=$(_project_prompts)
</code></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<ol>
<li>
<p><strong>Keep Completions Updated</strong></p>
<pre><code class="language-bash"># Update completions after SwissArmyHammer updates
swissarmyhammer completion $(basename $SHELL) &gt; ~/.local/share/completions/swissarmyhammer
</code></pre>
</li>
<li>
<p><strong>Test Completions</strong></p>
<pre><code class="language-bash"># Test completion generation
swissarmyhammer completion bash | head -20
</code></pre>
</li>
<li>
<p><strong>Document Custom Completions</strong></p>
<pre><code class="language-bash"># Add comments in completion files
# Custom completions for project XYZ
# Generated: $(date)
# Version: $(swissarmyhammer --version)
</code></pre>
</li>
</ol>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<h3 id="complete-workflow"><a class="header" href="#complete-workflow">Complete Workflow</a></h3>
<pre><code class="language-bash"># Install completions
swissarmyhammer completion bash &gt; ~/.local/share/bash-completion/completions/swissarmyhammer

# Use completions
swissarmyhammer li&lt;TAB&gt;          # Completes to: list
swissarmyhammer list --for&lt;TAB&gt;   # Completes to: --format
swissarmyhammer list --format j&lt;TAB&gt; # Completes to: json

# Get specific prompt
swissarmyhammer get code-r&lt;TAB&gt;   # Completes to: code-review

# Export with completion
swissarmyhammer export my-prompts&lt;TAB&gt; # Suggests: my-prompts.tar.gz
</code></pre>
<h3 id="script-integration-1"><a class="header" href="#script-integration-1">Script Integration</a></h3>
<pre><code class="language-bash">#!/bin/bash
# setup-completions.sh

SHELL_NAME=$(basename "$SHELL")

case "$SHELL_NAME" in
    bash)
        COMPLETION_DIR="$HOME/.local/share/bash-completion/completions"
        ;;
    zsh)
        COMPLETION_DIR="$HOME/.zsh/completions"
        ;;
    fish)
        COMPLETION_DIR="$HOME/.config/fish/completions"
        ;;
    *)
        echo "Unsupported shell: $SHELL_NAME"
        exit 1
        ;;
esac

mkdir -p "$COMPLETION_DIR"
swissarmyhammer completion "$SHELL_NAME" &gt; "$COMPLETION_DIR/swissarmyhammer"
echo "Completions installed to $COMPLETION_DIR"
</code></pre>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="./cli-reference.html">CLI Reference</a> - Complete command documentation</li>
<li><a href="./configuration.html">Configuration</a> - Configuration options</li>
<li><a href="./getting-started.html">Getting Started</a> - Initial setup guide</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-library-guide"><a class="header" href="#rust-library-guide">Rust Library Guide</a></h1>
<p>SwissArmyHammer is available as a Rust library (<code>swissarmyhammer</code>) that you can integrate into your own applications. This guide covers installation, basic usage, and advanced integration patterns.</p>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<p>Add SwissArmyHammer to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
swissarmyhammer = { git = "https://github.com/wballard/swissarmyhammer", features = ["full"] }
</code></pre>
<h3 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h3>
<p>Control which functionality to include:</p>
<pre><code class="language-toml">[dependencies]
swissarmyhammer = { 
  git = "https://github.com/wballard/swissarmyhammer", 
  features = ["prompts", "templates", "search", "mcp"] 
}
</code></pre>
<p>Available features:</p>
<ul>
<li><code>prompts</code> - Core prompt management (always enabled)</li>
<li><code>templates</code> - Liquid template engine with custom filters</li>
<li><code>search</code> - Full-text search capabilities</li>
<li><code>mcp</code> - Model Context Protocol server support</li>
<li><code>storage</code> - Advanced storage backends</li>
<li><code>full</code> - All features enabled</li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h3 id="basic-prompt-library"><a class="header" href="#basic-prompt-library">Basic Prompt Library</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptLibrary, ArgumentSpec};
use std::collections::HashMap;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a new prompt library
    let mut library = PromptLibrary::new();
    
    // Add prompts from a directory
    library.add_directory("./prompts").await?;
    
    // List available prompts
    for prompt_id in library.list_prompts() {
        println!("Available prompt: {}", prompt_id);
    }
    
    // Get a specific prompt
    let prompt = library.get("code-review")?;
    println!("Title: {}", prompt.title());
    println!("Description: {}", prompt.description());
    
    // Prepare arguments
    let mut args = HashMap::new();
    args.insert("code".to_string(), "fn main() { println!(\"Hello\"); }".to_string());
    args.insert("language".to_string(), "rust".to_string());
    
    // Render the prompt
    let rendered = prompt.render(&amp;args)?;
    println!("Rendered prompt:\n{}", rendered);
    
    Ok(())
}</code></pre>
<h3 id="custom-prompt-creation"><a class="header" href="#custom-prompt-creation">Custom Prompt Creation</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{Prompt, ArgumentSpec, PromptMetadata};

fn create_custom_prompt() -&gt; Result&lt;Prompt, Box&lt;dyn std::error::Error&gt;&gt; {
    let metadata = PromptMetadata {
        title: "Custom Code Review".to_string(),
        description: "A custom code review prompt".to_string(),
        arguments: vec![
            ArgumentSpec {
                name: "code".to_string(),
                description: "Code to review".to_string(),
                required: true,
                default: None,
            },
            ArgumentSpec {
                name: "focus".to_string(),
                description: "Review focus area".to_string(),
                required: false,
                default: Some("general".to_string()),
            },
        ],
    };
    
    let template = r#"
<span class="boring">Code Review: {{ focus | capitalize }}
</span>
Please review this code:
</code></pre>
<p>{{ code }}</p>
<pre><code>
{% if focus == "security" %}
Focus specifically on security vulnerabilities and best practices.
{% elsif focus == "performance" %}
Focus on performance optimizations and efficiency.
{% else %}
Perform a general code review covering style, bugs, and maintainability.
{% endif %}
"#;
    
    Prompt::from_parts(metadata, template)
}
</code></pre>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="promptlibrary"><a class="header" href="#promptlibrary">PromptLibrary</a></h3>
<p>The main interface for managing collections of prompts.</p>
<pre><code class="language-rust">use swissarmyhammer::PromptLibrary;

let mut library = PromptLibrary::new();

// Add prompts from various sources
library.add_directory("./prompts").await?;
library.add_file("./special-prompt.md").await?;
library.add_builtin_prompts();

// Query prompts
let prompts = library.list_prompts();
let prompt = library.get("prompt-id")?;
let filtered = library.filter_by_category("review");

// Search prompts
let results = library.search("code review")?;</code></pre>
<h3 id="prompt"><a class="header" href="#prompt">Prompt</a></h3>
<p>Individual prompt with metadata and template.</p>
<pre><code class="language-rust">use swissarmyhammer::Prompt;

// Load from file
let prompt = Prompt::from_file("./prompts/review.md").await?;

// Access metadata
println!("Title: {}", prompt.title());
println!("Description: {}", prompt.description());
for arg in prompt.arguments() {
    println!("Argument: {} (required: {})", arg.name, arg.required);
}

// Render with arguments
let mut args = HashMap::new();
args.insert("code".to_string(), "example code".to_string());
let rendered = prompt.render(&amp;args)?;</code></pre>
<h3 id="template-engine"><a class="header" href="#template-engine">Template Engine</a></h3>
<p>Advanced template processing with custom filters.</p>
<pre><code class="language-rust">use swissarmyhammer::template::{TemplateEngine, TemplateContext};

let engine = TemplateEngine::new();

let template = "Hello {{ name | capitalize }}! Today is {{ 'now' | format_date: '%Y-%m-%d' }}.";

let mut context = TemplateContext::new();
context.insert("name", "alice");

let result = engine.render(template, &amp;context)?;
println!("{}", result); // "Hello Alice! Today is 2024-01-15."</code></pre>
<h2 id="advanced-usage-1"><a class="header" href="#advanced-usage-1">Advanced Usage</a></h2>
<h3 id="custom-storage-backend"><a class="header" href="#custom-storage-backend">Custom Storage Backend</a></h3>
<p>Implement your own storage for prompts:</p>
<pre><code class="language-rust">use swissarmyhammer::storage::{StorageBackend, PromptSource};
use async_trait::async_trait;

struct DatabaseStorage {
    // Your database connection
    db: Database,
}

#[async_trait]
impl StorageBackend for DatabaseStorage {
    async fn list_prompts(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;, StorageError&gt; {
        // Implement database query
        todo!()
    }
    
    async fn get_prompt(&amp;self, id: &amp;str) -&gt; Result&lt;PromptSource, StorageError&gt; {
        // Implement database retrieval
        todo!()
    }
    
    async fn save_prompt(&amp;mut self, id: &amp;str, source: &amp;PromptSource) -&gt; Result&lt;(), StorageError&gt; {
        // Implement database storage
        todo!()
    }
}

// Use custom storage
let storage = DatabaseStorage::new(db);
let mut library = PromptLibrary::with_storage(storage);</code></pre>
<h3 id="search-integration"><a class="header" href="#search-integration">Search Integration</a></h3>
<p>Advanced search capabilities:</p>
<pre><code class="language-rust">use swissarmyhammer::search::{SearchEngine, SearchQuery, SearchResult};

let mut search_engine = SearchEngine::new();

// Index prompts
search_engine.index_prompt("code-review", &amp;prompt).await?;

// Perform searches
let query = SearchQuery::new("code review")
    .with_field("title")
    .with_limit(10)
    .case_sensitive(false);

let results: Vec&lt;SearchResult&gt; = search_engine.search(&amp;query)?;

for result in results {
    println!("Found: {} (score: {:.2})", result.id, result.score);
}</code></pre>
<h3 id="mcp-server-integration"><a class="header" href="#mcp-server-integration">MCP Server Integration</a></h3>
<p>Embed MCP server functionality:</p>
<pre><code class="language-rust">use swissarmyhammer::mcp::{McpServer, McpConfig};

let config = McpConfig {
    name: "my-prompt-server".to_string(),
    version: "1.0.0".to_string(),
    // ... other config
};

let mut library = PromptLibrary::new();
library.add_directory("./prompts").await?;

let server = McpServer::new(config, library);

// Run MCP server
server.serve().await?;</code></pre>
<h3 id="event-system"><a class="header" href="#event-system">Event System</a></h3>
<p>React to library events:</p>
<pre><code class="language-rust">use swissarmyhammer::events::{EventHandler, PromptEvent};

struct MyEventHandler;

impl EventHandler for MyEventHandler {
    fn handle_prompt_added(&amp;self, id: &amp;str) {
        println!("Prompt added: {}", id);
    }
    
    fn handle_prompt_updated(&amp;self, id: &amp;str) {
        println!("Prompt updated: {}", id);
    }
    
    fn handle_prompt_removed(&amp;self, id: &amp;str) {
        println!("Prompt removed: {}", id);
    }
}

let mut library = PromptLibrary::new();
library.add_event_handler(Box::new(MyEventHandler));</code></pre>
<h3 id="file-watching-1"><a class="header" href="#file-watching-1">File Watching</a></h3>
<p>Automatically reload prompts when files change:</p>
<pre><code class="language-rust">use swissarmyhammer::watcher::FileWatcher;

let mut library = PromptLibrary::new();
library.add_directory("./prompts").await?;

// Start watching for file changes
let _watcher = FileWatcher::new("./prompts", move |event| {
    match event {
        FileEvent::Created(path) =&gt; {
            if let Err(e) = library.reload_file(&amp;path) {
                eprintln!("Failed to load {}: {}", path.display(), e);
            }
        }
        FileEvent::Modified(path) =&gt; {
            if let Err(e) = library.reload_file(&amp;path) {
                eprintln!("Failed to reload {}: {}", path.display(), e);
            }
        }
        FileEvent::Deleted(path) =&gt; {
            library.remove_file(&amp;path);
        }
    }
});

// Keep the watcher alive
std::thread::sleep(std::time::Duration::from_secs(60));</code></pre>
<h2 id="integration-examples-1"><a class="header" href="#integration-examples-1">Integration Examples</a></h2>
<h3 id="web-server-integration"><a class="header" href="#web-server-integration">Web Server Integration</a></h3>
<pre><code class="language-rust">use axum::{extract::Path, http::StatusCode, response::Json, routing::get, Router};
use swissarmyhammer::PromptLibrary;
use std::sync::Arc;
use tokio::sync::RwLock;

type SharedLibrary = Arc&lt;RwLock&lt;PromptLibrary&gt;&gt;;

async fn list_prompts(library: SharedLibrary) -&gt; Json&lt;Vec&lt;String&gt;&gt; {
    let lib = library.read().await;
    Json(lib.list_prompts())
}

async fn get_prompt(
    Path(id): Path&lt;String&gt;,
    library: SharedLibrary,
) -&gt; Result&lt;Json&lt;String&gt;, StatusCode&gt; {
    let lib = library.read().await;
    match lib.get(&amp;id) {
        Ok(prompt) =&gt; Ok(Json(prompt.title().to_string())),
        Err(_) =&gt; Err(StatusCode::NOT_FOUND),
    }
}

#[tokio::main]
async fn main() {
    let mut library = PromptLibrary::new();
    library.add_directory("./prompts").await.unwrap();
    let shared_library = Arc::new(RwLock::new(library));

    let app = Router::new()
        .route("/prompts", get({
            let lib = shared_library.clone();
            move || list_prompts(lib)
        }))
        .route("/prompts/:id", get({
            let lib = shared_library.clone();
            move |path| get_prompt(path, lib)
        }));

    axum::Server::bind(&amp;"0.0.0.0:3000".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}</code></pre>
<h3 id="cli-tool-integration"><a class="header" href="#cli-tool-integration">CLI Tool Integration</a></h3>
<pre><code class="language-rust">use clap::{Arg, Command};
use swissarmyhammer::PromptLibrary;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let matches = Command::new("my-prompt-tool")
        .arg(Arg::new("prompt")
            .help("Prompt ID to render")
            .required(true)
            .index(1))
        .arg(Arg::new("args")
            .help("Template arguments as key=value pairs")
            .multiple_values(true)
            .short('a')
            .long("arg"))
        .get_matches();

    let mut library = PromptLibrary::new();
    library.add_directory("./prompts").await?;

    let prompt_id = matches.value_of("prompt").unwrap();
    let prompt = library.get(prompt_id)?;

    let mut args = std::collections::HashMap::new();
    if let Some(arg_values) = matches.values_of("args") {
        for arg in arg_values {
            if let Some((key, value)) = arg.split_once('=') {
                args.insert(key.to_string(), value.to_string());
            }
        }
    }

    let rendered = prompt.render(&amp;args)?;
    println!("{}", rendered);

    Ok(())
}</code></pre>
<h3 id="configuration-management"><a class="header" href="#configuration-management">Configuration Management</a></h3>
<pre><code class="language-rust">use serde::{Deserialize, Serialize};
use swissarmyhammer::{PromptLibrary, storage::FileSystemStorage};

#[derive(Serialize, Deserialize)]
struct AppConfig {
    prompt_directories: Vec&lt;String&gt;,
    default_arguments: std::collections::HashMap&lt;String, String&gt;,
    search_enabled: bool,
}

impl Default for AppConfig {
    fn default() -&gt; Self {
        Self {
            prompt_directories: vec!["./prompts".to_string()],
            default_arguments: std::collections::HashMap::new(),
            search_enabled: true,
        }
    }
}

async fn setup_library(config: &amp;AppConfig) -&gt; Result&lt;PromptLibrary, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut library = PromptLibrary::new();
    
    for dir in &amp;config.prompt_directories {
        library.add_directory(dir).await?;
    }
    
    if config.search_enabled {
        library.enable_search()?;
    }
    
    Ok(library)
}</code></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<p>SwissArmyHammer uses comprehensive error types:</p>
<pre><code class="language-rust">use swissarmyhammer::error::{SwissArmyHammerError, PromptError, TemplateError};

match library.get("nonexistent") {
    Ok(prompt) =&gt; {
        // Handle success
    }
    Err(SwissArmyHammerError::PromptNotFound(id)) =&gt; {
        eprintln!("Prompt '{}' not found", id);
    }
    Err(SwissArmyHammerError::Template(TemplateError::RenderError(msg))) =&gt; {
        eprintln!("Template rendering failed: {}", msg);
    }
    Err(SwissArmyHammerError::Io(io_err)) =&gt; {
        eprintln!("I/O error: {}", io_err);
    }
    Err(e) =&gt; {
        eprintln!("Unexpected error: {}", e);
    }
}</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>SwissArmyHammer provides testing utilities:</p>
<pre><code class="language-rust">use swissarmyhammer::testing::{MockPromptLibrary, PromptTestCase};

#[tokio::test]
async fn test_prompt_rendering() {
    let mut library = MockPromptLibrary::new();
    
    let test_case = PromptTestCase::new("test-prompt")
        .with_template("Hello {{ name }}!")
        .with_argument("name", "World")
        .expect_output("Hello World!");
    
    library.add_test_prompt(test_case);
    
    let prompt = library.get("test-prompt").unwrap();
    let mut args = std::collections::HashMap::new();
    args.insert("name".to_string(), "World".to_string());
    
    let result = prompt.render(&amp;args).unwrap();
    assert_eq!(result, "Hello World!");
}</code></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<ul>
<li>Prompt libraries cache parsed templates in memory</li>
<li>Large collections may require custom storage backends</li>
<li>Use lazy loading for better memory efficiency</li>
</ul>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<ul>
<li><code>PromptLibrary</code> is <code>Send + Sync</code> when used with appropriate storage</li>
<li>Template rendering is thread-safe</li>
<li>Consider using <code>Arc&lt;RwLock&lt;PromptLibrary&gt;&gt;</code> for shared access</li>
</ul>
<h3 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h3>
<ul>
<li>Prefer batch operations for multiple prompts</li>
<li>Cache rendered templates when arguments donâ€™t change</li>
<li>Use feature flags to include only needed functionality</li>
<li>Implement proper error handling for production use</li>
</ul>
<h2 id="migration-from-cli"><a class="header" href="#migration-from-cli">Migration from CLI</a></h2>
<p>If youâ€™re migrating from using the CLI to the library:</p>
<pre><code class="language-rust">// CLI equivalent: swissarmyhammer search "code review"
let results = library.search("code review")?;

// CLI equivalent: swissarmyhammer test prompt-id --arg key=value
let prompt = library.get("prompt-id")?;
let mut args = HashMap::new();
args.insert("key".to_string(), "value".to_string());
let rendered = prompt.render(&amp;args)?;

// CLI equivalent: swissarmyhammer export --all output.tar.gz
library.export_all("output.tar.gz", ExportFormat::TarGz)?;</code></pre>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="./library-api.html">Library API Reference</a> - Complete API documentation</li>
<li><a href="./library-examples.html">Integration Examples</a> - More integration patterns</li>
<li><a href="./custom-filters.html">Custom Filters</a> - Template customization</li>
<li><a href="./advanced-prompts.html">Advanced Prompts</a> - Complex template patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-api-reference"><a class="header" href="#library-api-reference">Library API Reference</a></h1>
<p>This document provides comprehensive API documentation for the SwissArmyHammer Rust library.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="prompt-1"><a class="header" href="#prompt-1">Prompt</a></h3>
<p>The <code>Prompt</code> struct represents a single prompt with metadata and template content.</p>
<pre><code class="language-rust">pub struct Prompt {
    pub name: String,
    pub content: String,
    pub description: Option&lt;String&gt;,
    pub category: Option&lt;String&gt;,
    pub tags: Vec&lt;String&gt;,
    pub arguments: Vec&lt;ArgumentSpec&gt;,
    pub file_path: Option&lt;PathBuf&gt;,
}</code></pre>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<ul>
<li><code>new(name: &amp;str, content: &amp;str) -&gt; Self</code> - Create a new prompt</li>
<li><code>with_description(self, description: &amp;str) -&gt; Self</code> - Add a description (builder pattern)</li>
<li><code>with_category(self, category: &amp;str) -&gt; Self</code> - Add a category (builder pattern)</li>
<li><code>add_tag(self, tag: &amp;str) -&gt; Self</code> - Add a tag (builder pattern)</li>
<li><code>add_argument(self, arg: ArgumentSpec) -&gt; Self</code> - Add an argument specification</li>
<li><code>render(&amp;self, args: &amp;HashMap&lt;String, String&gt;) -&gt; Result&lt;String&gt;</code> - Render the prompt with arguments</li>
<li><code>validate_arguments(&amp;self, args: &amp;HashMap&lt;String, String&gt;) -&gt; Result&lt;()&gt;</code> - Validate provided arguments</li>
</ul>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<pre><code class="language-rust">use swissarmyhammer::{Prompt, ArgumentSpec};
use std::collections::HashMap;

let prompt = Prompt::new("greet", "Hello {{name}}!")
    .with_description("A greeting prompt")
    .add_argument(ArgumentSpec {
        name: "name".to_string(),
        description: Some("Name to greet".to_string()),
        required: true,
        default: None,
        type_hint: Some("string".to_string()),
    });

let mut args = HashMap::new();
args.insert("name".to_string(), "World".to_string());
let result = prompt.render(&amp;args)?;
// result: "Hello World!"</code></pre>
<h3 id="argumentspec"><a class="header" href="#argumentspec">ArgumentSpec</a></h3>
<p>Defines the specification for a prompt argument.</p>
<pre><code class="language-rust">pub struct ArgumentSpec {
    pub name: String,
    pub description: Option&lt;String&gt;,
    pub required: bool,
    pub default: Option&lt;String&gt;,
    pub type_hint: Option&lt;String&gt;,
}</code></pre>
<h3 id="promptlibrary-1"><a class="header" href="#promptlibrary-1">PromptLibrary</a></h3>
<p>The main interface for managing collections of prompts.</p>
<pre><code class="language-rust">pub struct PromptLibrary {
    // internal fields...
}</code></pre>
<h4 id="methods-1"><a class="header" href="#methods-1">Methods</a></h4>
<ul>
<li><code>new() -&gt; Self</code> - Create a new empty library</li>
<li><code>add_directory&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;()&gt;</code> - Load prompts from directory</li>
<li><code>add_prompt(&amp;mut self, prompt: Prompt)</code> - Add a single prompt</li>
<li><code>get(&amp;self, name: &amp;str) -&gt; Result&lt;&amp;Prompt&gt;</code> - Get a prompt by name</li>
<li><code>list_prompts(&amp;self) -&gt; Vec&lt;&amp;Prompt&gt;</code> - List all prompts</li>
<li><code>find_by_category(&amp;self, category: &amp;str) -&gt; Vec&lt;&amp;Prompt&gt;</code> - Find prompts by category</li>
<li><code>find_by_tag(&amp;self, tag: &amp;str) -&gt; Vec&lt;&amp;Prompt&gt;</code> - Find prompts by tag</li>
<li><code>remove(&amp;mut self, name: &amp;str) -&gt; Option&lt;Prompt&gt;</code> - Remove a prompt</li>
</ul>
<h4 id="example-2"><a class="header" href="#example-2">Example</a></h4>
<pre><code class="language-rust">use swissarmyhammer::PromptLibrary;

let mut library = PromptLibrary::new();
library.add_directory("./prompts")?;

let prompt = library.get("code-review")?;
let rendered = prompt.render(&amp;args)?;</code></pre>
<h3 id="promptloader"><a class="header" href="#promptloader">PromptLoader</a></h3>
<p>Handles loading prompts from various sources.</p>
<pre><code class="language-rust">pub struct PromptLoader {
    // internal fields...
}</code></pre>
<h4 id="methods-2"><a class="header" href="#methods-2">Methods</a></h4>
<ul>
<li><code>new() -&gt; Self</code> - Create a new loader</li>
<li><code>load_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; Result&lt;Prompt&gt;</code> - Load single prompt file</li>
<li><code>load_directory&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; Result&lt;Vec&lt;Prompt&gt;&gt;</code> - Load all prompts from directory</li>
<li><code>load_string(&amp;self, name: &amp;str, content: &amp;str) -&gt; Result&lt;Prompt&gt;</code> - Load prompt from string</li>
</ul>
<h2 id="template-engine-1"><a class="header" href="#template-engine-1">Template Engine</a></h2>
<h3 id="template"><a class="header" href="#template">Template</a></h3>
<p>Wrapper for Liquid templates with custom filters.</p>
<pre><code class="language-rust">pub struct Template {
    // internal fields...
}</code></pre>
<h4 id="methods-3"><a class="header" href="#methods-3">Methods</a></h4>
<ul>
<li><code>new(template_str: &amp;str) -&gt; Result&lt;Self&gt;</code> - Create template from string</li>
<li><code>render(&amp;self, args: &amp;HashMap&lt;String, String&gt;) -&gt; Result&lt;String&gt;</code> - Render with arguments</li>
<li><code>raw(&amp;self) -&gt; &amp;str</code> - Get the raw template string</li>
</ul>
<h3 id="templateengine"><a class="header" href="#templateengine">TemplateEngine</a></h3>
<p>Manages template parsing and custom filters.</p>
<pre><code class="language-rust">pub struct TemplateEngine {
    // internal fields...
}</code></pre>
<h4 id="methods-4"><a class="header" href="#methods-4">Methods</a></h4>
<ul>
<li><code>new() -&gt; Self</code> - Create new engine</li>
<li><code>default_parser() -&gt; Parser</code> - Get default Liquid parser with custom filters</li>
<li><code>register_filter&lt;F&gt;(&amp;mut self, name: &amp;str, filter: F)</code> - Register custom filter</li>
</ul>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<h3 id="promptstorage"><a class="header" href="#promptstorage">PromptStorage</a></h3>
<p>High-level storage interface for prompts.</p>
<pre><code class="language-rust">pub trait PromptStorage {
    fn store_prompt(&amp;mut self, prompt: &amp;Prompt) -&gt; Result&lt;()&gt;;
    fn load_prompt(&amp;self, name: &amp;str) -&gt; Result&lt;Prompt&gt;;
    fn list_prompts(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;&gt;;
    fn delete_prompt(&amp;mut self, name: &amp;str) -&gt; Result&lt;()&gt;;
}</code></pre>
<h3 id="storagebackend"><a class="header" href="#storagebackend">StorageBackend</a></h3>
<p>Low-level storage abstraction.</p>
<pre><code class="language-rust">pub trait StorageBackend {
    fn read(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
    fn write(&amp;mut self, key: &amp;str, data: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn delete(&amp;mut self, key: &amp;str) -&gt; Result&lt;()&gt;;
    fn list(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;&gt;;
}</code></pre>
<h2 id="search"><a class="header" href="#search">Search</a></h2>
<p><em>Available with the <code>search</code> feature</em></p>
<h3 id="searchengine"><a class="header" href="#searchengine">SearchEngine</a></h3>
<p>Full-text search functionality for prompts.</p>
<pre><code class="language-rust">pub struct SearchEngine {
    // internal fields...
}</code></pre>
<h4 id="methods-5"><a class="header" href="#methods-5">Methods</a></h4>
<ul>
<li><code>new() -&gt; Result&lt;Self&gt;</code> - Create new search engine</li>
<li><code>index_prompt(&amp;mut self, prompt: &amp;Prompt) -&gt; Result&lt;()&gt;</code> - Add prompt to search index</li>
<li><code>search(&amp;self, query: &amp;str) -&gt; Result&lt;Vec&lt;SearchResult&gt;&gt;</code> - Search for prompts</li>
</ul>
<h3 id="searchresult"><a class="header" href="#searchresult">SearchResult</a></h3>
<p>Represents a search result.</p>
<pre><code class="language-rust">pub struct SearchResult {
    pub name: String,
    pub score: f32,
    pub snippet: Option&lt;String&gt;,
}</code></pre>
<h2 id="mcp-integration"><a class="header" href="#mcp-integration">MCP Integration</a></h2>
<p><em>Available with the <code>mcp</code> feature</em></p>
<h3 id="mcpserver"><a class="header" href="#mcpserver">McpServer</a></h3>
<p>Model Context Protocol server implementation.</p>
<pre><code class="language-rust">pub struct McpServer {
    // internal fields...
}</code></pre>
<h4 id="methods-6"><a class="header" href="#methods-6">Methods</a></h4>
<ul>
<li><code>new(library: PromptLibrary) -&gt; Self</code> - Create server with prompt library</li>
<li><code>run(&amp;mut self) -&gt; Result&lt;()&gt;</code> - Start the MCP server</li>
</ul>
<h2 id="plugin-system"><a class="header" href="#plugin-system">Plugin System</a></h2>
<h3 id="swissarmyhammerplugin"><a class="header" href="#swissarmyhammerplugin">SwissArmyHammerPlugin</a></h3>
<p>Trait for creating plugins.</p>
<pre><code class="language-rust">pub trait SwissArmyHammerPlugin {
    fn name(&amp;self) -&gt; &amp;str;
    fn filters(&amp;self) -&gt; Vec&lt;Box&lt;dyn CustomLiquidFilter&gt;&gt;;
}</code></pre>
<h3 id="customliquidfilter"><a class="header" href="#customliquidfilter">CustomLiquidFilter</a></h3>
<p>Trait for custom Liquid template filters.</p>
<pre><code class="language-rust">pub trait CustomLiquidFilter {
    fn name(&amp;self) -&gt; &amp;str;
    fn filter(&amp;self, input: &amp;str, args: &amp;[&amp;str]) -&gt; Result&lt;String&gt;;
}</code></pre>
<h3 id="pluginregistry"><a class="header" href="#pluginregistry">PluginRegistry</a></h3>
<p>Manages registered plugins and filters.</p>
<pre><code class="language-rust">pub struct PluginRegistry {
    // internal fields...
}</code></pre>
<h4 id="methods-7"><a class="header" href="#methods-7">Methods</a></h4>
<ul>
<li><code>new() -&gt; Self</code> - Create new registry</li>
<li><code>register_plugin&lt;P: SwissArmyHammerPlugin&gt;(&amp;mut self, plugin: P)</code> - Register plugin</li>
<li><code>get_filters(&amp;self) -&gt; Vec&lt;&amp;dyn CustomLiquidFilter&gt;</code> - Get all registered filters</li>
</ul>
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<h3 id="swissarmyhammererror"><a class="header" href="#swissarmyhammererror">SwissArmyHammerError</a></h3>
<p>Main error type for the library.</p>
<pre><code class="language-rust">pub enum SwissArmyHammerError {
    Io(std::io::Error),
    Template(String),
    PromptNotFound(String),
    Config(String),
    Storage(String),
    Serialization(serde_yaml::Error),
    Other(String),
}</code></pre>
<h3 id="result-type"><a class="header" href="#result-type">Result Type</a></h3>
<p>Convenient result type alias.</p>
<pre><code class="language-rust">pub type Result&lt;T&gt; = std::result::Result&lt;T, SwissArmyHammerError&gt;;</code></pre>
<h2 id="feature-flags-1"><a class="header" href="#feature-flags-1">Feature Flags</a></h2>
<p>The library supports several optional features:</p>
<ul>
<li><code>search</code> - Enables full-text search functionality</li>
<li><code>mcp</code> - Enables Model Context Protocol server support</li>
</ul>
<p>Enable features in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
swissarmyhammer = { version = "0.1", features = ["search", "mcp"] }
</code></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><code class="language-rust">use swissarmyhammer::{PromptLibrary, ArgumentSpec, Result};
use std::collections::HashMap;

fn main() -&gt; Result&lt;()&gt; {
    // Create library and load prompts
    let mut library = PromptLibrary::new();
    library.add_directory("./prompts")?;
    
    // Get a prompt
    let prompt = library.get("code-review")?;
    
    // Prepare arguments
    let mut args = HashMap::new();
    args.insert("code".to_string(), "fn main() { println!(\"Hello\"); }".to_string());
    args.insert("language".to_string(), "rust".to_string());
    
    // Render the prompt
    let rendered = prompt.render(&amp;args)?;
    println!("{}", rendered);
    
    Ok(())
}</code></pre>
<h2 id="advanced-usage-2"><a class="header" href="#advanced-usage-2">Advanced Usage</a></h2>
<h3 id="custom-filters-1"><a class="header" href="#custom-filters-1">Custom Filters</a></h3>
<p>Create custom Liquid filters for domain-specific transformations:</p>
<pre><code class="language-rust">use swissarmyhammer::{CustomLiquidFilter, PluginRegistry, TemplateEngine};

struct UppercaseFilter;

impl CustomLiquidFilter for UppercaseFilter {
    fn name(&amp;self) -&gt; &amp;str { "uppercase" }
    
    fn filter(&amp;self, input: &amp;str, _args: &amp;[&amp;str]) -&gt; Result&lt;String&gt; {
        Ok(input.to_uppercase())
    }
}

let mut registry = PluginRegistry::new();
registry.register_filter("uppercase", Box::new(UppercaseFilter));</code></pre>
<h3 id="storage-backends"><a class="header" href="#storage-backends">Storage Backends</a></h3>
<p>Implement custom storage backends:</p>
<pre><code class="language-rust">use swissarmyhammer::{StorageBackend, Result};

struct DatabaseBackend {
    // database connection...
}

impl StorageBackend for DatabaseBackend {
    fn read(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        // Read from database
        todo!()
    }
    
    fn write(&amp;mut self, key: &amp;str, data: &amp;[u8]) -&gt; Result&lt;()&gt; {
        // Write to database
        todo!()
    }
    
    // ... implement other methods
}</code></pre>
<p>For more examples and advanced usage patterns, see the <a href="./library-examples.html">Library Examples</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-examples"><a class="header" href="#library-examples">Library Examples</a></h1>
<p>This guide provides practical examples of using SwissArmyHammer as a Rust library in your applications.</p>
<h2 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h2>
<h3 id="adding-to-your-project"><a class="header" href="#adding-to-your-project">Adding to Your Project</a></h3>
<p>Add SwissArmyHammer to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
swissarmyhammer = { git = "https://github.com/wballard/swissarmyhammer.git" }
tokio = { version = "1", features = ["full"] }
serde_json = "1"
</code></pre>
<h3 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, PromptArgument};
use std::collections::HashMap;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a prompt manager
    let manager = PromptManager::new()?;
    
    // Load prompts from default directories
    manager.load_prompts().await?;
    
    // Get a specific prompt
    let prompt = manager.get_prompt("code-review")?;
    
    // Prepare arguments
    let mut args = HashMap::new();
    args.insert("code".to_string(), r#"
        def calculate_sum(a, b):
            return a + b
    "#.to_string());
    args.insert("language".to_string(), "python".to_string());
    
    // Render the prompt
    let rendered = prompt.render(&amp;args)?;
    println!("Rendered prompt:\n{}", rendered);
    
    Ok(())
}</code></pre>
<h2 id="advanced-examples"><a class="header" href="#advanced-examples">Advanced Examples</a></h2>
<h3 id="custom-prompt-directories"><a class="header" href="#custom-prompt-directories">Custom Prompt Directories</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, Config};
use std::path::PathBuf;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create custom configuration
    let mut config = Config::default();
    config.prompt_directories.push(PathBuf::from("./my-prompts"));
    config.prompt_directories.push(PathBuf::from("/opt/company/prompts"));
    
    // Create manager with custom config
    let manager = PromptManager::with_config(config)?;
    
    // Load prompts from all directories
    manager.load_prompts().await?;
    
    // List all available prompts
    for prompt in manager.list_prompts() {
        println!("Found prompt: {} - {}", prompt.name, prompt.title);
    }
    
    Ok(())
}</code></pre>
<h3 id="watching-for-changes"><a class="header" href="#watching-for-changes">Watching for Changes</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, WatchEvent};
use tokio::sync::mpsc;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let manager = PromptManager::new()?;
    
    // Create a channel for watch events
    let (tx, mut rx) = mpsc::channel(100);
    
    // Start watching for changes
    manager.watch(tx).await?;
    
    // Handle watch events
    tokio::spawn(async move {
        while let Some(event) = rx.recv().await {
            match event {
                WatchEvent::PromptAdded(name) =&gt; {
                    println!("New prompt added: {}", name);
                }
                WatchEvent::PromptModified(name) =&gt; {
                    println!("Prompt modified: {}", name);
                }
                WatchEvent::PromptRemoved(name) =&gt; {
                    println!("Prompt removed: {}", name);
                }
            }
        }
    });
    
    // Keep the program running
    tokio::signal::ctrl_c().await?;
    println!("Shutting down...");
    
    Ok(())
}</code></pre>
<h3 id="mcp-server-implementation"><a class="header" href="#mcp-server-implementation">MCP Server Implementation</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, MCPServer, MCPRequest, MCPResponse};
use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create prompt manager
    let manager = PromptManager::new()?;
    manager.load_prompts().await?;
    
    // Create MCP server
    let server = MCPServer::new(manager);
    
    // Listen on TCP socket
    let listener = TcpListener::bind("127.0.0.1:3333").await?;
    println!("MCP server listening on 127.0.0.1:3333");
    
    loop {
        let (mut socket, addr) = listener.accept().await?;
        let server = server.clone();
        
        // Handle each connection
        tokio::spawn(async move {
            let mut buffer = vec![0; 1024];
            
            loop {
                let n = match socket.read(&amp;mut buffer).await {
                    Ok(n) if n == 0 =&gt; return,
                    Ok(n) =&gt; n,
                    Err(e) =&gt; {
                        eprintln!("Error reading from {}: {}", addr, e);
                        return;
                    }
                };
                
                // Parse request
                if let Ok(request) = serde_json::from_slice::&lt;MCPRequest&gt;(&amp;buffer[..n]) {
                    // Handle request
                    let response = server.handle_request(request).await;
                    
                    // Send response
                    let response_bytes = serde_json::to_vec(&amp;response).unwrap();
                    if let Err(e) = socket.write_all(&amp;response_bytes).await {
                        eprintln!("Error writing to {}: {}", addr, e);
                        return;
                    }
                }
            }
        });
    }
}</code></pre>
<h3 id="custom-template-filters"><a class="header" href="#custom-template-filters">Custom Template Filters</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, TemplateEngine, FilterFunction};
use liquid::ValueView;

fn create_custom_filters() -&gt; Vec&lt;(&amp;'static str, FilterFunction)&gt; {
    vec![
        // Custom filter to convert to snake_case
        ("snake_case", Box::new(|input: &amp;dyn ValueView, _args: &amp;[liquid::model::Value]| {
            let s = input.to_kstr().to_string();
            let snake = s.chars().fold(String::new(), |mut acc, ch| {
                if ch.is_uppercase() &amp;&amp; !acc.is_empty() {
                    acc.push('_');
                }
                acc.push(ch.to_lowercase().next().unwrap());
                acc
            });
            Ok(liquid::model::Value::scalar(snake))
        })),
        
        // Custom filter to add line numbers
        ("line_numbers", Box::new(|input: &amp;dyn ValueView, _args: &amp;[liquid::model::Value]| {
            let s = input.to_kstr().to_string();
            let numbered = s.lines()
                .enumerate()
                .map(|(i, line)| format!("{:4}: {}", i + 1, line))
                .collect::&lt;Vec&lt;_&gt;&gt;()
                .join("\n");
            Ok(liquid::model::Value::scalar(numbered))
        })),
    ]
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create template engine with custom filters
    let mut engine = TemplateEngine::new();
    for (name, filter) in create_custom_filters() {
        engine.register_filter(name, filter);
    }
    
    // Create prompt manager with custom engine
    let manager = PromptManager::with_engine(engine)?;
    
    // Use prompts with custom filters
    let template = r#"
    Function name: {{ function_name | snake_case }}
    
    Code with line numbers:
    {{ code | line_numbers }}
    "#;
    
    let mut args = HashMap::new();
    args.insert("function_name", "calculateTotalPrice");
    args.insert("code", "def hello():\n    print('Hello')\n    return True");
    
    let rendered = engine.render_str(template, &amp;args)?;
    println!("{}", rendered);
    
    Ok(())
}</code></pre>
<h3 id="prompt-validation"><a class="header" href="#prompt-validation">Prompt Validation</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, PromptValidator, ValidationRule};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create custom validation rules
    let rules = vec![
        ValidationRule::RequiredFields(vec!["name", "title", "description"]),
        ValidationRule::ArgumentTypes(HashMap::from([
            ("max_length", "integer"),
            ("temperature", "float"),
            ("enabled", "boolean"),
        ])),
        ValidationRule::TemplatePatterns(vec![
            r"\{\{[^}]+\}\}",  // Must use double braces
        ]),
    ];
    
    // Create validator
    let validator = PromptValidator::new(rules);
    
    // Create manager with validator
    let manager = PromptManager::with_validator(validator)?;
    
    // Load and validate prompts
    match manager.load_prompts().await {
        Ok(_) =&gt; println!("All prompts validated successfully"),
        Err(e) =&gt; eprintln!("Validation errors: {}", e),
    }
    
    // Validate a specific prompt file
    let prompt_content = std::fs::read_to_string("my-prompt.md")?;
    match manager.validate_prompt_content(&amp;prompt_content) {
        Ok(prompt) =&gt; println!("Prompt '{}' is valid", prompt.name),
        Err(errors) =&gt; {
            println!("Validation errors:");
            for error in errors {
                println!("  - {}", error);
            }
        }
    }
    
    Ok(())
}</code></pre>
<h3 id="batch-processing"><a class="header" href="#batch-processing">Batch Processing</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, BatchProcessor};
use futures::stream::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let manager = PromptManager::new()?;
    manager.load_prompts().await?;
    
    // Create batch processor
    let processor = BatchProcessor::new(manager, 10); // 10 concurrent tasks
    
    // Prepare batch jobs
    let jobs = vec![
        ("code-review", HashMap::from([
            ("code", "def add(a, b): return a + b"),
            ("language", "python"),
        ])),
        ("api-docs", HashMap::from([
            ("api_spec", r#"{"endpoints": ["/users", "/posts"]}"#),
            ("format", "markdown"),
        ])),
        ("test-writer", HashMap::from([
            ("code", "class Calculator { add(a, b) { return a + b; } }"),
            ("framework", "jest"),
        ])),
    ];
    
    // Process in parallel
    let results = processor.process_batch(jobs).await;
    
    // Handle results
    for (index, result) in results.iter().enumerate() {
        match result {
            Ok(rendered) =&gt; {
                println!("Job {} completed:", index + 1);
                println!("{}\n", rendered);
            }
            Err(e) =&gt; {
                eprintln!("Job {} failed: {}", index + 1, e);
            }
        }
    }
    
    Ok(())
}</code></pre>
<h3 id="integration-with-ai-services"><a class="header" href="#integration-with-ai-services">Integration with AI Services</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, AIServiceClient};
use async_trait::async_trait;

// Custom AI service implementation
struct OpenAIClient {
    api_key: String,
    client: reqwest::Client,
}

#[async_trait]
impl AIServiceClient for OpenAIClient {
    async fn complete(&amp;self, prompt: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let response = self.client
            .post("https://api.openai.com/v1/chat/completions")
            .bearer_auth(&amp;self.api_key)
            .json(&amp;serde_json::json!({
                "model": "gpt-4",
                "messages": [{"role": "user", "content": prompt}],
                "temperature": 0.7,
            }))
            .send()
            .await?;
        
        let data: serde_json::Value = response.json().await?;
        let content = data["choices"][0]["message"]["content"]
            .as_str()
            .unwrap_or("");
        
        Ok(content.to_string())
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Setup prompt manager
    let manager = PromptManager::new()?;
    manager.load_prompts().await?;
    
    // Create AI client
    let ai_client = OpenAIClient {
        api_key: std::env::var("OPENAI_API_KEY")?,
        client: reqwest::Client::new(),
    };
    
    // Get and render prompt
    let prompt = manager.get_prompt("code-review")?;
    let args = HashMap::from([
        ("code", "def factorial(n): return 1 if n &lt;= 1 else n * factorial(n-1)"),
        ("language", "python"),
    ]);
    let rendered = prompt.render(&amp;args)?;
    
    // Send to AI service
    println!("Sending prompt to AI service...");
    let response = ai_client.complete(&amp;rendered).await?;
    println!("AI Response:\n{}", response);
    
    Ok(())
}</code></pre>
<h3 id="web-server-integration-1"><a class="header" href="#web-server-integration-1">Web Server Integration</a></h3>
<pre><code class="language-rust">use swissarmyhammer::PromptManager;
use axum::{
    routing::{get, post},
    Router, Json, Extension,
    response::IntoResponse,
    http::StatusCode,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Deserialize)]
struct RenderRequest {
    prompt_name: String,
    arguments: HashMap&lt;String, String&gt;,
}

#[derive(Serialize)]
struct RenderResponse {
    rendered: String,
}

async fn list_prompts(
    Extension(manager): Extension&lt;Arc&lt;PromptManager&gt;&gt;
) -&gt; impl IntoResponse {
    let prompts = manager.list_prompts();
    Json(prompts)
}

async fn render_prompt(
    Extension(manager): Extension&lt;Arc&lt;PromptManager&gt;&gt;,
    Json(request): Json&lt;RenderRequest&gt;,
) -&gt; impl IntoResponse {
    match manager.get_prompt(&amp;request.prompt_name) {
        Ok(prompt) =&gt; match prompt.render(&amp;request.arguments) {
            Ok(rendered) =&gt; Ok(Json(RenderResponse { rendered })),
            Err(e) =&gt; Err((StatusCode::BAD_REQUEST, e.to_string())),
        },
        Err(e) =&gt; Err((StatusCode::NOT_FOUND, e.to_string())),
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Setup prompt manager
    let manager = Arc::new(PromptManager::new()?);
    manager.load_prompts().await?;
    
    // Build web app
    let app = Router::new()
        .route("/prompts", get(list_prompts))
        .route("/render", post(render_prompt))
        .layer(Extension(manager));
    
    // Start server
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await?;
    println!("Web server listening on http://0.0.0.0:8080");
    axum::serve(listener, app).await?;
    
    Ok(())
}</code></pre>
<h3 id="testing-utilities"><a class="header" href="#testing-utilities">Testing Utilities</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, TestHarness, TestCase};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let manager = PromptManager::new()?;
    manager.load_prompts().await?;
    
    // Create test harness
    let harness = TestHarness::new(manager);
    
    // Define test cases
    let test_cases = vec![
        TestCase {
            prompt_name: "code-review",
            arguments: HashMap::from([
                ("code", "def divide(a, b): return a / b"),
                ("language", "python"),
            ]),
            expected_contains: vec!["division by zero", "error handling"],
            expected_not_contains: vec!["syntax error"],
        },
        TestCase {
            prompt_name: "api-docs",
            arguments: HashMap::from([
                ("api_spec", r#"{"version": "1.0"}"#),
            ]),
            expected_contains: vec!["API Documentation", "version"],
            expected_not_contains: vec!["error", "invalid"],
        },
    ];
    
    // Run tests
    let results = harness.run_tests(test_cases).await;
    
    // Report results
    for (test, result) in results {
        match result {
            Ok(_) =&gt; println!("âœ“ {} passed", test.prompt_name),
            Err(e) =&gt; println!("âœ— {} failed: {}", test.prompt_name, e),
        }
    }
    
    Ok(())
}</code></pre>
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<h3 id="comprehensive-error-handling"><a class="header" href="#comprehensive-error-handling">Comprehensive Error Handling</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, SwissArmyHammerError};

#[tokio::main]
async fn main() {
    match run_app().await {
        Ok(_) =&gt; println!("Application completed successfully"),
        Err(e) =&gt; {
            eprintln!("Application error: {}", e);
            std::process::exit(1);
        }
    }
}

async fn run_app() -&gt; Result&lt;(), SwissArmyHammerError&gt; {
    let manager = PromptManager::new()
        .map_err(|e| SwissArmyHammerError::Initialization(e.to_string()))?;
    
    // Handle different error types
    match manager.load_prompts().await {
        Ok(_) =&gt; println!("Prompts loaded successfully"),
        Err(SwissArmyHammerError::IoError(e)) =&gt; {
            eprintln!("File system error: {}", e);
            return Err(SwissArmyHammerError::IoError(e));
        }
        Err(SwissArmyHammerError::ParseError(e)) =&gt; {
            eprintln!("Prompt parsing error: {}", e);
            // Continue with partial prompts
        }
        Err(e) =&gt; return Err(e),
    }
    
    // Safely get and render prompt
    let prompt_name = "code-review";
    let prompt = manager.get_prompt(prompt_name)
        .map_err(|_| SwissArmyHammerError::PromptNotFound(prompt_name.to_string()))?;
    
    let args = HashMap::from([("code", "print('hello')")]);
    let rendered = prompt.render(&amp;args)
        .map_err(|e| SwissArmyHammerError::RenderError(e.to_string()))?;
    
    println!("Rendered: {}", rendered);
    Ok(())
}</code></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="caching-and-pooling"><a class="header" href="#caching-and-pooling">Caching and Pooling</a></h3>
<pre><code class="language-rust">use swissarmyhammer::{PromptManager, CacheConfig, ConnectionPool};
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Configure caching
    let cache_config = CacheConfig {
        max_size: 100_000_000, // 100MB
        ttl: Duration::from_secs(3600),
        strategy: CacheStrategy::LRU,
    };
    
    // Create connection pool for MCP
    let pool = ConnectionPool::builder()
        .max_connections(100)
        .connection_timeout(Duration::from_secs(5))
        .idle_timeout(Duration::from_secs(60))
        .build()?;
    
    // Create optimized manager
    let manager = PromptManager::builder()
        .cache_config(cache_config)
        .connection_pool(pool)
        .parallel_load(true)
        .build()?;
    
    // Benchmark loading
    let start = std::time::Instant::now();
    manager.load_prompts().await?;
    println!("Loaded prompts in {:?}", start.elapsed());
    
    // Benchmark rendering with cache
    let mut total_time = Duration::ZERO;
    for i in 0..1000 {
        let start = std::time::Instant::now();
        let prompt = manager.get_prompt("code-review")?;
        let args = HashMap::from([("code", format!("test {}", i))]);
        let _ = prompt.render(&amp;args)?;
        total_time += start.elapsed();
    }
    println!("Average render time: {:?}", total_time / 1000);
    
    Ok(())
}</code></pre>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li>Review the <a href="./library-api.html">Library API</a> reference</li>
<li>Learn about <a href="./library-usage.html">Library Usage</a> patterns</li>
<li>See <a href="./examples.html">Integration Examples</a> for more use cases</li>
<li>Check the <a href="./api-reference.html">API Documentation</a> for detailed information</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rustdoc-api-documentation"><a class="header" href="#-rustdoc-api-documentation">ğŸ”— Rustdoc API Documentation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-prompt-techniques"><a class="header" href="#advanced-prompt-techniques">Advanced Prompt Techniques</a></h1>
<p>This guide covers advanced techniques for creating sophisticated and powerful prompts with SwissArmyHammer.</p>
<h2 id="composable-prompts"><a class="header" href="#composable-prompts">Composable Prompts</a></h2>
<h3 id="prompt-chaining-1"><a class="header" href="#prompt-chaining-1">Prompt Chaining</a></h3>
<p>Chain multiple prompts together for complex workflows:</p>
<pre><code class="language-markdown">---
name: full-analysis
title: Complete Code Analysis Pipeline
description: Runs multiple analysis steps on code
arguments:
  - name: file_path
    description: File to analyze
    required: true
  - name: output_format
    description: Format for results
    default: markdown
---

# Complete Analysis for {{file_path}}

## Step 1: Code Review
{% capture review_output %}
Run code review on {{file_path}} focusing on:
- Code quality
- Best practices
- Potential bugs
{% endcapture %}

## Step 2: Security Analysis
{% capture security_output %}
Analyze {{file_path}} for security vulnerabilities:
- Input validation
- Authentication issues
- Data exposure risks
{% endcapture %}

## Step 3: Performance Analysis
{% capture performance_output %}
Check {{file_path}} for performance issues:
- Algorithm complexity
- Resource usage
- Optimization opportunities
{% endcapture %}

{% if output_format == "markdown" %}
## Analysis Results

### Code Review
{{ review_output }}

### Security
{{ security_output }}

### Performance
{{ performance_output }}
{% elsif output_format == "json" %}
{
  "code_review": "{{ review_output | escape }}",
  "security": "{{ security_output | escape }}",
  "performance": "{{ performance_output | escape }}"
}
{% endif %}
</code></pre>
<h3 id="modular-prompt-components"><a class="header" href="#modular-prompt-components">Modular Prompt Components</a></h3>
<p>Create reusable prompt components:</p>
<pre><code class="language-markdown">---
name: code-analyzer-base
title: Base Code Analyzer
description: Reusable base for code analysis prompts
arguments:
  - name: code
    description: Code to analyze
    required: true
  - name: analysis_type
    description: Type of analysis
    required: true
---

{% comment %} Base analysis template {% endcomment %}
{% assign lines = code | split: "\n" %}
{% assign line_count = lines | size %}

# {{analysis_type | capitalize}} Analysis

## Code Metrics
- Lines of code: {{line_count}}
- Language: {% if code contains "def " %}Python{% elsif code contains "function" %}JavaScript{% else %}Unknown{% endif %}

## Analysis Focus
{% case analysis_type %}
{% when "security" %}
  {% include "security-checks.liquid" %}
{% when "performance" %}
  {% include "performance-checks.liquid" %}
{% when "style" %}
  {% include "style-checks.liquid" %}
{% endcase %}

## Detailed Analysis
Analyze the following code for {{analysis_type}} issues:

</code></pre>
<p>{{code}}</p>
<pre><code></code></pre>
<h2 id="advanced-templating"><a class="header" href="#advanced-templating">Advanced Templating</a></h2>
<h3 id="dynamic-content-generation"><a class="header" href="#dynamic-content-generation">Dynamic Content Generation</a></h3>
<p>Generate content based on complex conditions:</p>
<pre><code class="language-markdown">---
name: api-documentation-generator
title: Dynamic API Documentation
description: Generates API docs with dynamic sections
arguments:
  - name: api_spec
    description: API specification (JSON)
    required: true
  - name: include_examples
    description: Include code examples
    default: "true"
  - name: languages
    description: Example languages (comma-separated)
    default: "curl,python,javascript"
---

{% assign api = api_spec | parse_json %}
{% assign lang_list = languages | split: "," %}

# {{api.title}} API Documentation

{{api.description}}

Base URL: `{{api.base_url}}`
Version: {{api.version}}

## Authentication

{% if api.auth.type == "bearer" %}
This API uses Bearer token authentication. Include your API token in the Authorization header:

</code></pre>
<p>Authorization: Bearer YOUR_API_TOKEN</p>
<pre><code>{% elsif api.auth.type == "oauth2" %}
This API uses OAuth 2.0. See [Authentication Guide](#auth-guide) for details.
{% endif %}

## Endpoints

{% for endpoint in api.endpoints %}
### {{endpoint.method}} {{endpoint.path}}

{{endpoint.description}}

{% if endpoint.parameters.size &gt; 0 %}
#### Parameters

| Name | Type | Required | Description |
|------|------|----------|-------------|
{% for param in endpoint.parameters %}
| {{param.name}} | {{param.type}} | {{param.required | default: false}} | {{param.description}} |
{% endfor %}
{% endif %}

{% if include_examples == "true" %}
#### Examples

{% for lang in lang_list %}
{% case lang %}
{% when "curl" %}
```bash
curl -X {{endpoint.method}} \
  {{api.base_url}}{{endpoint.path}} \
  {% if api.auth.type == "bearer" %}-H "Authorization: Bearer $API_TOKEN" \{% endif %}
  {% for param in endpoint.parameters %}{% if param.in == "header" %}-H "{{param.name}}: value" \{% endif %}{% endfor %}
  {% if endpoint.method == "POST" or endpoint.method == "PUT" %}-H "Content-Type: application/json" \
  -d '{"key": "value"}'{% endif %}
</code></pre>
<p>{% when â€œpythonâ€ %}</p>
<pre><code class="language-python">import requests

response = requests.{{endpoint.method | downcase}}(
    "{{api.base_url}}{{endpoint.path}}",
    {% if api.auth.type == "bearer" %}headers={"Authorization": f"Bearer {api_token}"},{% endif %}
    {% if endpoint.method == "POST" or endpoint.method == "PUT" %}json={"key": "value"}{% endif %}
)
print(response.json())
</code></pre>
<p>{% when â€œjavascriptâ€ %}</p>
<pre><code class="language-javascript">const response = await fetch('{{api.base_url}}{{endpoint.path}}', {
  method: '{{endpoint.method}}',
  {% if api.auth.type == "bearer" %}headers: {
    'Authorization': `Bearer ${apiToken}`,
    {% if endpoint.method == "POST" or endpoint.method == "PUT" %}'Content-Type': 'application/json'{% endif %}
  },{% endif %}
  {% if endpoint.method == "POST" or endpoint.method == "PUT" %}body: JSON.stringify({ key: 'value' }){% endif %}
});
const data = await response.json();
</code></pre>
<p>{% endcase %}
{% endfor %}
{% endif %}</p>
<hr />
<p>{% endfor %}</p>
<pre><code>
### Complex Conditionals

Use advanced conditional logic:

```markdown
---
name: smart-optimizer
title: Smart Code Optimizer
description: Applies context-aware optimizations
arguments:
  - name: code
    description: Code to optimize
    required: true
  - name: metrics
    description: Performance metrics (JSON)
    required: false
  - name: constraints
    description: Optimization constraints
    default: "balanced"
---

{% if metrics %}
  {% assign perf = metrics | parse_json %}
  {% assign needs_memory_opt = false %}
  {% assign needs_cpu_opt = false %}
  
  {% if perf.memory_usage &gt; 80 %}
    {% assign needs_memory_opt = true %}
  {% endif %}
  
  {% if perf.cpu_usage &gt; 70 %}
    {% assign needs_cpu_opt = true %}
  {% endif %}
{% endif %}

# Optimization Analysis

{% if needs_memory_opt and needs_cpu_opt %}
## Critical: Both Memory and CPU Optimization Needed

Your code is experiencing both memory and CPU pressure. This requires careful optimization to balance both concerns.

### Recommended Strategy: Hybrid Optimization
1. Profile to identify hotspots
2. Optimize algorithms first (reduces both CPU and memory)
3. Implement caching strategically
4. Consider async processing

{% elsif needs_memory_opt %}
## Memory Optimization Required

Current memory usage: {{perf.memory_usage}}%

### Memory Optimization Strategies:
1. Reduce object allocation
2. Use object pooling
3. Implement lazy loading
4. Clear unused references

{% elsif needs_cpu_opt %}
## CPU Optimization Required

Current CPU usage: {{perf.cpu_usage}}%

### CPU Optimization Strategies:
1. Algorithm optimization
2. Parallel processing
3. Caching computed results
4. Reduce unnecessary operations

{% else %}
## Performance is Acceptable

No immediate optimization needed. Consider:
- Code maintainability improvements
- Preemptive optimization for scale
- Documentation updates
{% endif %}

## Code Analysis

</code></pre>
<p>{{code}}</p>
<pre><code>
{% case constraints %}
{% when "memory-first" %}
Focus on reducing memory footprint, even at slight CPU cost.
{% when "cpu-first" %}
Optimize for CPU performance, memory usage is secondary.
{% when "balanced" %}
Balance both memory and CPU optimizations.
{% endcase %}
</code></pre>
<h2 id="state-management"><a class="header" href="#state-management">State Management</a></h2>
<h3 id="using-captures-for-state"><a class="header" href="#using-captures-for-state">Using Captures for State</a></h3>
<p>Manage complex state across prompt sections:</p>
<pre><code class="language-markdown">---
name: migration-planner
title: Database Migration Planner
description: Plans complex database migrations
arguments:
  - name: current_schema
    description: Current database schema
    required: true
  - name: target_schema
    description: Target database schema
    required: true
  - name: strategy
    description: Migration strategy
    default: "safe"
---

{% comment %} Analyze schemas and capture findings {% endcomment %}

{% capture added_tables %}
{% assign current_tables = current_schema | parse_json | map: "name" %}
{% assign target_tables = target_schema | parse_json | map: "name" %}
{% for table in target_tables %}
  {% unless current_tables contains table %}
    - {{table}}
  {% endunless %}
{% endfor %}
{% endcapture %}

{% capture removed_tables %}
{% for table in current_tables %}
  {% unless target_tables contains table %}
    - {{table}}
  {% endunless %}
{% endfor %}
{% endcapture %}

{% capture migration_risk %}
{% if removed_tables contains "users" or removed_tables contains "auth" %}
HIGH - Critical tables being removed
{% elsif added_tables.size &gt; 5 %}
MEDIUM - Large number of new tables
{% else %}
LOW - Minimal structural changes
{% endif %}
{% endcapture %}

# Database Migration Plan

## Risk Assessment: {{migration_risk | strip}}

## Changes Summary

### New Tables
{{added_tables | default: "None"}}

### Removed Tables
{{removed_tables | default: "None"}}

## Migration Strategy: {{strategy | upcase}}

{% if strategy == "safe" %}
### Safe Migration Steps
1. Create backup
2. Add new tables first
3. Migrate data with validation
4. Update application code
5. Remove old tables after verification

{% elsif strategy == "fast" %}
### Fast Migration Steps
1. Quick backup
2. Execute all changes in transaction
3. Minimal validation
4. Quick rollback if needed

{% elsif strategy == "zero-downtime" %}
### Zero-Downtime Migration Steps
1. Create new tables alongside old
2. Implement dual-write logic
3. Backfill data progressively
4. Switch reads to new tables
5. Remove old tables after stabilization
{% endif %}

{% if migration_risk contains "HIGH" %}
## âš ï¸ High Risk Mitigation

Due to the high risk nature of this migration:
1. Schedule during maintenance window
2. Have rollback plan ready
3. Test in staging environment first
4. Monitor closely after deployment
{% endif %}
</code></pre>
<h2 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h2>
<h3 id="lazy-evaluation"><a class="header" href="#lazy-evaluation">Lazy Evaluation</a></h3>
<p>Use lazy evaluation for expensive operations:</p>
<pre><code class="language-markdown">---
name: smart-analyzer
title: Smart Performance Analyzer
description: Analyzes code with lazy evaluation
arguments:
  - name: code
    description: Code to analyze
    required: true
  - name: quick_check
    description: Perform quick check only
    default: "false"
---

# Code Analysis

{% if quick_check == "true" %}
## Quick Analysis
- Lines: {{code | split: "\n" | size}}
- Complexity: {{code | size | divided_by: 100}} (estimated)

{% else %}
{% comment %} Full analysis only when needed {% endcomment %}

{% capture complexity_analysis %}
  {% assign lines = code | split: "\n" %}
  {% assign complexity = 0 %}
  {% for line in lines %}
    {% if line contains "if " or line contains "for " or line contains "while " %}
      {% assign complexity = complexity | plus: 1 %}
    {% endif %}
  {% endfor %}
  Cyclomatic Complexity: {{complexity}}
{% endcapture %}

{% capture pattern_analysis %}
  {% if code contains "TODO" or code contains "FIXME" %}
    - Contains pending work items
  {% endif %}
  {% if code contains "console.log" or code contains "print(" %}
    - Contains debug output
  {% endif %}
{% endcapture %}

## Full Analysis

### Metrics
{{complexity_analysis}}

### Code Patterns
{{pattern_analysis | default: "No issues found"}}

### Detailed Review
Analyze the code for:
1. Performance bottlenecks
2. Security vulnerabilities
3. Best practice violations

</code></pre>
<p>{{code}}</p>
<pre><code>{% endif %}
</code></pre>
<h3 id="caching-computed-values"><a class="header" href="#caching-computed-values">Caching Computed Values</a></h3>
<p>Cache expensive computations:</p>
<pre><code class="language-markdown">---
name: data-processor
title: Efficient Data Processor
description: Processes data with caching
arguments:
  - name: data
    description: Data to process (CSV or JSON)
    required: true
  - name: operations
    description: Operations to perform
    required: true
---

{% comment %} Cache parsed data {% endcomment %}
{% assign is_json = false %}
{% assign is_csv = false %}

{% if data contains "{" and data contains "}" %}
  {% assign is_json = true %}
  {% assign parsed_data = data | parse_json %}
{% elsif data contains "," %}
  {% assign is_csv = true %}
  {% comment %} Cache row count {% endcomment %}
  {% assign rows = data | split: "\n" %}
  {% assign row_count = rows | size %}
{% endif %}

# Data Processing

## Data Format: {% if is_json %}JSON{% elsif is_csv %}CSV ({{row_count}} rows){% else %}Unknown{% endif %}

{% comment %} Reuse cached values {% endcomment %}
{% for operation in operations %}
  {% case operation %}
  {% when "count" %}
    - Count: {% if is_json %}{{parsed_data | size}}{% else %}{{row_count}}{% endif %}
  {% when "validate" %}
    - Validation: {% if is_json %}Valid JSON{% elsif is_csv %}Valid CSV{% endif %}
  {% endcase %}
{% endfor %}
</code></pre>
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<h3 id="graceful-degradation"><a class="header" href="#graceful-degradation">Graceful Degradation</a></h3>
<p>Handle errors gracefully:</p>
<pre><code class="language-markdown">---
name: robust-analyzer
title: Robust Code Analyzer
description: Analyzes code with error handling
arguments:
  - name: code
    description: Code to analyze
    required: true
  - name: language
    description: Programming language
    default: "auto"
---

# Code Analysis

{% comment %} Safe language detection {% endcomment %}
{% assign detected_language = "unknown" %}
{% if language == "auto" %}
  {% if code contains "def " and code contains ":" %}
    {% assign detected_language = "python" %}
  {% elsif code contains "function" or code contains "const " %}
    {% assign detected_language = "javascript" %}
  {% elsif code contains "fn " and code contains "-&gt;" %}
    {% assign detected_language = "rust" %}
  {% endif %}
{% else %}
  {% assign detected_language = language %}
{% endif %}

## Language: {{detected_language | capitalize}}

{% comment %} Safe parsing with fallbacks {% endcomment %}
{% assign parse_success = false %}
{% capture parsed_structure %}
  {% if detected_language == "python" %}
    {% comment %} Python-specific parsing {% endcomment %}
    {% assign functions = code | split: "def " | size | minus: 1 %}
    {% assign classes = code | split: "class " | size | minus: 1 %}
    Functions: {{functions}}, Classes: {{classes}}
    {% assign parse_success = true %}
  {% elsif detected_language == "javascript" %}
    {% comment %} JavaScript-specific parsing {% endcomment %}
    {% assign functions = code | split: "function" | size | minus: 1 %}
    {% assign arrows = code | split: "=&gt;" | size | minus: 1 %}
    Functions: {{functions | plus: arrows}}
    {% assign parse_success = true %}
  {% endif %}
{% endcapture %}

{% if parse_success %}
## Structure Analysis
{{parsed_structure}}
{% else %}
## Basic Analysis
Unable to parse structure for {{detected_language}}.
Falling back to general analysis:
- Lines: {{code | split: "\n" | size}}
- Characters: {{code | size}}
{% endif %}

## Code Review
Analyze the following {{detected_language}} code:

```{{detected_language}}
{{code}}
</code></pre>
<pre><code>
### Input Validation

Validate and sanitize inputs:

```markdown
---
name: secure-processor
title: Secure Input Processor
description: Processes inputs with validation
arguments:
  - name: user_input
    description: User-provided input
    required: true
  - name: input_type
    description: Expected input type
    required: true
  - name: max_length
    description: Maximum allowed length
    default: "1000"
---

{% comment %} Input validation {% endcomment %}
{% assign is_valid = true %}
{% assign validation_errors = "" %}

{% comment %} Length check {% endcomment %}
{% assign input_length = user_input | size %}
{% if input_length &gt; max_length %}
  {% assign is_valid = false %}
  {% capture validation_errors %}{{validation_errors}}
  - Input exceeds maximum length ({{input_length}} &gt; {{max_length}}){% endcapture %}
{% endif %}

{% comment %} Type validation {% endcomment %}
{% case input_type %}
{% when "email" %}
  {% unless user_input contains "@" and user_input contains "." %}
    {% assign is_valid = false %}
    {% capture validation_errors %}{{validation_errors}}
    - Invalid email format{% endcapture %}
  {% endunless %}
{% when "number" %}
  {% assign test_number = user_input | plus: 0 %}
  {% if test_number == 0 and user_input != "0" %}
    {% assign is_valid = false %}
    {% capture validation_errors %}{{validation_errors}}
    - Input is not a valid number{% endcapture %}
  {% endif %}
{% when "json" %}
  {% capture json_test %}{{user_input | parse_json}}{% endcapture %}
  {% unless json_test %}
    {% assign is_valid = false %}
    {% capture validation_errors %}{{validation_errors}}
    - Invalid JSON format{% endcapture %}
  {% endunless %}
{% endcase %}

# Input Processing Result

## Validation: {% if is_valid %}âœ… Passed{% else %}âŒ Failed{% endif %}

{% unless is_valid %}
## Validation Errors:
{{validation_errors}}
{% endunless %}

{% if is_valid %}
## Processing Input

Type: {{input_type}}
Length: {{input_length}} characters

### Sanitized Input:
</code></pre>
<p>{{user_input | strip | escape}}</p>
<pre><code>
### Next Steps:
Process the validated {{input_type}} input according to business logic.
{% else %}
## Cannot Process Invalid Input

Please fix the validation errors and try again.
{% endif %}
</code></pre>
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="external-tool-integration"><a class="header" href="#external-tool-integration">External Tool Integration</a></h3>
<p>Integrate with external tools and services:</p>
<pre><code class="language-markdown">---
name: ci-cd-analyzer
title: CI/CD Pipeline Analyzer
description: Analyzes CI/CD configurations
arguments:
  - name: pipeline_config
    description: CI/CD configuration file
    required: true
  - name: platform
    description: CI/CD platform (github, gitlab, jenkins)
    required: true
  - name: recommendations
    description: Include recommendations
    default: "true"
---

# CI/CD Pipeline Analysis

Platform: {{platform | capitalize}}

{% assign config = pipeline_config %}

## Pipeline Structure

{% case platform %}
{% when "github" %}
  {% if config contains "on:" %}
    ### Triggers
    - Configured triggers found
    {% if config contains "push:" %}âœ“ Push events{% endif %}
    {% if config contains "pull_request:" %}âœ“ Pull request events{% endif %}
    {% if config contains "schedule:" %}âœ“ Scheduled runs{% endif %}
  {% endif %}
  
  {% if config contains "jobs:" %}
    ### Jobs
    {% assign job_count = config | split: "jobs:" | last | split: ":" | size %}
    - Number of jobs: ~{{job_count}}
  {% endif %}

{% when "gitlab" %}
  {% if config contains "stages:" %}
    ### Stages
    - Pipeline stages defined
  {% endif %}
  
  {% if config contains "before_script:" %}
    ### Global Configuration
    - Global before_script found
  {% endif %}

{% when "jenkins" %}
  {% if config contains "pipeline {" %}
    ### Pipeline Type
    - Declarative pipeline
  {% elsif config contains "node {" %}
    - Scripted pipeline
  {% endif %}
{% endcase %}

## Security Analysis

{% capture security_issues %}
{% if config contains "secrets." or config contains "${{" %}
  - âœ“ Uses secure secret management
{% endif %}
{% if config contains "password" or config contains "api_key" %}
  - âš ï¸ Possible hardcoded credentials
{% endif %}
{% if platform == "github" and config contains "actions/checkout" %}
  {% unless config contains "actions/checkout@v" %}
    - âš ï¸ Using unpinned actions
  {% endunless %}
{% endif %}
{% endcapture %}

{{security_issues | default: "No security issues found"}}

{% if recommendations == "true" %}
## Recommendations

{% case platform %}
{% when "github" %}
1. Use specific action versions (e.g., `actions/checkout@v3`)
2. Implement job dependencies for efficiency
3. Use matrix builds for multiple versions
4. Cache dependencies for faster builds

{% when "gitlab" %}
1. Use DAG for job dependencies
2. Implement proper stage dependencies
3. Use artifacts for job communication
4. Enable pipeline caching

{% when "jenkins" %}
1. Use declarative pipeline syntax
2. Implement proper error handling
3. Use Jenkins shared libraries
4. Enable pipeline visualization
{% endcase %}

### General Best Practices
- Implement proper testing stages
- Add security scanning steps
- Use parallel execution where possible
- Monitor pipeline metrics
{% endif %}

## Raw Configuration

```yaml
{{pipeline_config}}
</code></pre>
<pre><code>
## Advanced Examples

### Multi-Stage Document Generator

```markdown
---
name: tech-doc-generator
title: Technical Documentation Generator
description: Generates comprehensive technical documentation
arguments:
  - name: project_info
    description: Project information (JSON)
    required: true
  - name: doc_sections
    description: Sections to include (comma-separated)
    default: "overview,architecture,api,deployment"
  - name: audience
    description: Target audience
    default: "developers"
---

{% assign project = project_info | parse_json %}
{% assign sections = doc_sections | split: "," %}

# {{project.name}} Technical Documentation

Version: {{project.version}}
Last Updated: {% assign date = 'now' | date: "%B %d, %Y" %}{{date}}

{% for section in sections %}
{% case section | strip %}
{% when "overview" %}
## Overview

{{project.description}}

### Key Features
{% for feature in project.features %}
- **{{feature.name}}**: {{feature.description}}
{% endfor %}

### Technology Stack
{% for tech in project.stack %}
- {{tech.name}} ({{tech.version}}) - {{tech.purpose}}
{% endfor %}

{% when "architecture" %}
## Architecture

### System Components
{% for component in project.components %}
#### {{component.name}}
- **Type**: {{component.type}}
- **Responsibility**: {{component.responsibility}}
- **Dependencies**: {% for dep in component.dependencies %}{{dep}}{% unless forloop.last %}, {% endunless %}{% endfor %}
{% endfor %}

### Data Flow
</code></pre>
<p>{% for flow in project.dataflows %}
{{flow.source}} â€“&gt; {{flow.destination}}: {{flow.description}}
{% endfor %}</p>
<pre><code>
{% when "api" %}
## API Reference

Base URL: `{{project.api.base_url}}`

### Authentication
{{project.api.auth.description}}

### Endpoints
{% for endpoint in project.api.endpoints %}
#### {{endpoint.method}} {{endpoint.path}}
{{endpoint.description}}

**Parameters:**
{% for param in endpoint.parameters %}
- `{{param.name}}` ({{param.type}}{% if param.required %}, required{% endif %}) - {{param.description}}
{% endfor %}

**Response:** {{endpoint.response.description}}
{% endfor %}

{% when "deployment" %}
## Deployment Guide

### Prerequisites
{% for prereq in project.deployment.prerequisites %}
- {{prereq}}
{% endfor %}

### Environment Variables
| Variable | Description | Required | Default |
|----------|-------------|----------|---------|
{% for env in project.deployment.env_vars %}
| {{env.name}} | {{env.description}} | {{env.required}} | {{env.default | default: "none"}} |
{% endfor %}

### Deployment Steps
{% for step in project.deployment.steps %}
{{forloop.index}}. {{step.description}}
   ```bash
   {{step.command}}
</code></pre>
<p>{% endfor %}
{% endcase %}
{% endfor %}</p>
<hr />
<p>Generated for {{audience}} by SwissArmyHammer</p>
<pre><code>
### Intelligent Code Refactoring Assistant

```markdown
---
name: refactoring-assistant
title: Intelligent Refactoring Assistant
description: Provides context-aware refactoring suggestions
arguments:
  - name: code
    description: Code to refactor
    required: true
  - name: code_metrics
    description: Code metrics (JSON)
    required: false
  - name: refactor_goals
    description: Refactoring goals (comma-separated)
    default: "readability,maintainability,performance"
  - name: preserve_behavior
    description: Ensure behavior preservation
    default: "true"
---

{% if code_metrics %}
  {% assign metrics = code_metrics | parse_json %}
{% endif %}

# Refactoring Analysis

## Current Code Metrics
{% if metrics %}
- Complexity: {{metrics.complexity}}
- Lines: {{metrics.lines}}
- Duplication: {{metrics.duplication}}%
- Test Coverage: {{metrics.coverage}}%
{% else %}
- Lines: {{code | split: "\n" | size}}
{% endif %}

## Refactoring Goals
{% assign goals = refactor_goals | split: "," %}
{% for goal in goals %}
- {{goal | strip | capitalize}}
{% endfor %}

## Analysis

</code></pre>
<p>{{code}}</p>
<pre><code>
{% capture refactoring_plan %}
{% for goal in goals %}
{% case goal | strip %}
{% when "readability" %}
### Readability Improvements
1. Extract complex conditionals into well-named functions
2. Replace magic numbers with named constants
3. Improve variable and function names
4. Add clarifying comments for complex logic

{% when "maintainability" %}
### Maintainability Enhancements
1. Apply SOLID principles
2. Reduce coupling between components
3. Extract reusable components
4. Improve error handling

{% when "performance" %}
### Performance Optimizations
1. Identify and optimize bottlenecks
2. Reduce unnecessary iterations
3. Implement caching where appropriate
4. Optimize data structures

{% when "testability" %}
### Testability Improvements
1. Extract pure functions
2. Reduce dependencies
3. Implement dependency injection
4. Separate business logic from I/O
{% endcase %}
{% endfor %}
{% endcapture %}

{{refactoring_plan}}

{% if preserve_behavior == "true" %}
## Behavior Preservation Strategy

To ensure the refactoring preserves behavior:

1. **Write characterization tests** before refactoring
2. **Refactor in small steps** with tests passing
3. **Use automated refactoring tools** where possible
4. **Compare outputs** before and after changes

### Suggested Test Cases
Based on the code analysis, ensure tests cover:
- Edge cases and boundary conditions
- Error handling paths
- Main business logic flows
- Integration points
{% endif %}

## Refactoring Priority

{% if metrics %}
{% if metrics.complexity &gt; 10 %}
**High Priority**: Reduce complexity first - current complexity of {{metrics.complexity}} is too high
{% elsif metrics.duplication &gt; 20 %}
**High Priority**: Address code duplication - {{metrics.duplication}}% duplication detected
{% elsif metrics.coverage &lt; 60 %}
**High Priority**: Improve test coverage before refactoring - only {{metrics.coverage}}% covered
{% else %}
**Normal Priority**: Code is in reasonable shape for refactoring
{% endif %}
{% else %}
Based on initial analysis, focus on readability and structure improvements.
{% endif %}

## Next Steps

1. Review the refactoring plan
2. Set up safety nets (tests, version control)
3. Apply refactorings incrementally
4. Validate behavior preservation
5. Update documentation
</code></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<h3 id="1-use-meaningful-variable-names"><a class="header" href="#1-use-meaningful-variable-names">1. Use Meaningful Variable Names</a></h3>
<pre><code class="language-liquid">{% comment %} Bad {% endcomment %}
{% assign x = data | split: "," %}

{% comment %} Good {% endcomment %}
{% assign csv_rows = data | split: "," %}
</code></pre>
<h3 id="2-cache-expensive-operations"><a class="header" href="#2-cache-expensive-operations">2. Cache Expensive Operations</a></h3>
<pre><code class="language-liquid">{% comment %} Cache parsed data {% endcomment %}
{% assign parsed_json = data | parse_json %}
{% comment %} Reuse parsed_json multiple times {% endcomment %}
</code></pre>
<h3 id="3-provide-fallbacks"><a class="header" href="#3-provide-fallbacks">3. Provide Fallbacks</a></h3>
<pre><code class="language-liquid">{{variable | default: "No value provided"}}
</code></pre>
<h3 id="4-use-comments-for-complex-logic"><a class="header" href="#4-use-comments-for-complex-logic">4. Use Comments for Complex Logic</a></h3>
<pre><code class="language-liquid">{% comment %} 
  Check if the code is Python by looking for specific syntax
  This is more reliable than file extension alone
{% endcomment %}
{% if code contains "def " and code contains ":" %}
  {% assign language = "python" %}
{% endif %}
</code></pre>
<h3 id="5-modularize-with-captures"><a class="header" href="#5-modularize-with-captures">5. Modularize with Captures</a></h3>
<pre><code class="language-liquid">{% capture header %}
  # {{title}}
  Generated on: {{date}}
{% endcapture %}

{% comment %} Reuse header in multiple places {% endcomment %}
{{header}}
</code></pre>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li>Explore <a href="./custom-filters.html">Custom Filters</a> for extending functionality</li>
<li>Learn about <a href="./prompt-organization.html">Prompt Organization</a> for managing complex prompts</li>
<li>See <a href="./examples.html">Examples</a> for more real-world scenarios</li>
<li>Read <a href="./template-variables.html">Template Variables</a> for Liquid syntax reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search-and-discovery-guide"><a class="header" href="#search-and-discovery-guide">Search and Discovery Guide</a></h1>
<p>SwissArmyHammer provides powerful search capabilities to help you discover and find prompts in your collection. This guide covers search strategies, advanced filtering, and integration workflows.</p>
<h2 id="basic-search-1"><a class="header" href="#basic-search-1">Basic Search</a></h2>
<h3 id="simple-text-search"><a class="header" href="#simple-text-search">Simple Text Search</a></h3>
<p>The most basic way to search is with a simple text query:</p>
<pre><code class="language-bash"># Search for prompts containing "code"
swissarmyhammer search code

# Search for multiple terms
swissarmyhammer search "code review"

# Search with partial matches
swissarmyhammer search debug
</code></pre>
<h3 id="search-results-format"><a class="header" href="#search-results-format">Search Results Format</a></h3>
<pre><code>Found 3 prompts matching "code":

ğŸ“ code-review (builtin)
   Review code for best practices and potential issues
   Arguments: code, language (optional)

ğŸ”§ debug-helper (user)
   Help debug programming issues and errors
   Arguments: error, context (optional)

ğŸ“Š analyze-performance (local)
   Analyze code performance and suggest optimizations
   Arguments: code, language, metrics (optional)
</code></pre>
<p>Each result shows:</p>
<ul>
<li><strong>Icon</strong>: Indicates prompt type (ğŸ“ builtin, ğŸ”§ user, ğŸ“Š local)</li>
<li><strong>Name</strong>: Prompt identifier</li>
<li><strong>Source</strong>: Where the prompt is stored</li>
<li><strong>Description</strong>: Brief description of the promptâ€™s purpose</li>
<li><strong>Arguments</strong>: Required and optional parameters</li>
</ul>
<h2 id="field-specific-search-1"><a class="header" href="#field-specific-search-1">Field-Specific Search</a></h2>
<h3 id="search-in-titles-only"><a class="header" href="#search-in-titles-only">Search in Titles Only</a></h3>
<pre><code class="language-bash"># Find prompts with "review" in the title
swissarmyhammer search --in title review

# Case-sensitive title search
swissarmyhammer search --in title --case-sensitive "Code Review"
</code></pre>
<h3 id="search-in-descriptions"><a class="header" href="#search-in-descriptions">Search in Descriptions</a></h3>
<pre><code class="language-bash"># Find prompts about debugging in descriptions
swissarmyhammer search --in description debug

# Find prompts mentioning specific technologies
swissarmyhammer search --in description "python javascript"
</code></pre>
<h3 id="search-in-content"><a class="header" href="#search-in-content">Search in Content</a></h3>
<pre><code class="language-bash"># Find prompts that use specific template variables
swissarmyhammer search --in content "{{code}}"

# Find prompts with specific instructions
swissarmyhammer search --in content "best practices"
</code></pre>
<h3 id="search-all-fields"><a class="header" href="#search-all-fields">Search All Fields</a></h3>
<pre><code class="language-bash"># Search across titles, descriptions, and content (default)
swissarmyhammer search --in all "security"

# Explicit all-field search
swissarmyhammer search "API documentation"
</code></pre>
<h2 id="advanced-search-techniques"><a class="header" href="#advanced-search-techniques">Advanced Search Techniques</a></h2>
<h3 id="regular-expression-search-1"><a class="header" href="#regular-expression-search-1">Regular Expression Search</a></h3>
<p>Use regex patterns for powerful pattern matching:</p>
<pre><code class="language-bash"># Find prompts with "test" followed by any word
swissarmyhammer search --regex "test\s+\w+"

# Find prompts starting with specific words
swissarmyhammer search --regex "^(debug|fix|analyze)"

# Find prompts with email patterns
swissarmyhammer search --regex "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b"

# Case-sensitive regex
swissarmyhammer search --regex --case-sensitive "^Code"
</code></pre>
<h3 id="search-by-source"><a class="header" href="#search-by-source">Search by Source</a></h3>
<p>Filter prompts by their source location:</p>
<pre><code class="language-bash"># Find only built-in prompts
swissarmyhammer search --source builtin

# Find only user-created prompts
swissarmyhammer search --source user

# Find only local project prompts
swissarmyhammer search --source local

# Combine with text search
swissarmyhammer search review --source user
</code></pre>
<h3 id="search-by-arguments"><a class="header" href="#search-by-arguments">Search by Arguments</a></h3>
<p>Find prompts based on their argument requirements:</p>
<pre><code class="language-bash"># Find prompts that accept a "code" argument
swissarmyhammer search --has-arg code

# Find prompts with no arguments (simple prompts)
swissarmyhammer search --no-args

# Find prompts with specific argument combinations
swissarmyhammer search --has-arg code --has-arg language

# Combine with text search
swissarmyhammer search debug --has-arg error
</code></pre>
<h2 id="search-strategies"><a class="header" href="#search-strategies">Search Strategies</a></h2>
<h3 id="discovery-workflows"><a class="header" href="#discovery-workflows">Discovery Workflows</a></h3>
<h4 id="finding-prompts-for-a-task"><a class="header" href="#finding-prompts-for-a-task">Finding Prompts for a Task</a></h4>
<pre><code class="language-bash"># 1. Start broad
swissarmyhammer search "code review"

# 2. Narrow down by context
swissarmyhammer search "code review" --source user

# 3. Check argument requirements
swissarmyhammer search "code review" --has-arg language

# 4. Examine specific matches
swissarmyhammer search --in title "Advanced Code Review"
</code></pre>
<h4 id="exploring-available-prompts"><a class="header" href="#exploring-available-prompts">Exploring Available Prompts</a></h4>
<pre><code class="language-bash"># See all available prompts
swissarmyhammer search --limit 50 ""

# Browse by category/topic
swissarmyhammer search documentation
swissarmyhammer search testing
swissarmyhammer search refactoring

# Find simple prompts (no arguments)
swissarmyhammer search --no-args
</code></pre>
<h4 id="finding-template-examples"><a class="header" href="#finding-template-examples">Finding Template Examples</a></h4>
<pre><code class="language-bash"># Find prompts using loops
swissarmyhammer search --in content "{% for"

# Find prompts with conditionals
swissarmyhammer search --in content "{% if"

# Find prompts using specific filters
swissarmyhammer search --in content "| capitalize"
</code></pre>
<h3 id="search-optimization"><a class="header" href="#search-optimization">Search Optimization</a></h3>
<h4 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h4>
<pre><code class="language-bash"># Limit results for faster response
swissarmyhammer search --limit 10 query

# Use specific fields to reduce search scope
swissarmyhammer search --in title query  # faster than all fields

# Use source filtering to narrow search space
swissarmyhammer search --source user query
</code></pre>
<h4 id="precision-vs-recall"><a class="header" href="#precision-vs-recall">Precision vs. Recall</a></h4>
<pre><code class="language-bash"># High precision (exact matches)
swissarmyhammer search --case-sensitive --regex "^exact pattern$"

# High recall (find everything related)
swissarmyhammer search --in all "broad topic"

# Balanced approach
swissarmyhammer search "specific terms" --limit 20
</code></pre>
<h2 id="integration-with-other-commands-1"><a class="header" href="#integration-with-other-commands-1">Integration with Other Commands</a></h2>
<h3 id="search-and-test-workflow"><a class="header" href="#search-and-test-workflow">Search and Test Workflow</a></h3>
<pre><code class="language-bash"># Find debugging prompts
swissarmyhammer search debug

# Test a specific one
swissarmyhammer test debug-helper

# Test with specific arguments
swissarmyhammer test debug-helper --arg error="TypeError: undefined"
</code></pre>
<h3 id="search-and-export-workflow"><a class="header" href="#search-and-export-workflow">Search and Export Workflow</a></h3>
<pre><code class="language-bash"># Find all review-related prompts
swissarmyhammer search review --limit 20

# Export specific ones found
swissarmyhammer export code-review security-review design-review output.tar.gz

# Or export all matching a pattern
# (manual selection based on search results)
</code></pre>
<h3 id="scripted-search"><a class="header" href="#scripted-search">Scripted Search</a></h3>
<pre><code class="language-bash">#!/bin/bash
# find-and-test.sh

QUERY="$1"
if [ -z "$QUERY" ]; then
    echo "Usage: $0 &lt;search-query&gt;"
    exit 1
fi

echo "Searching for: $QUERY"
PROMPTS=$(swissarmyhammer search --json "$QUERY" | jq -r '.results[].id')

if [ -z "$PROMPTS" ]; then
    echo "No prompts found"
    exit 1
fi

echo "Found prompts:"
echo "$PROMPTS"

echo "Select a prompt to test:"
select PROMPT in $PROMPTS; do
    if [ -n "$PROMPT" ]; then
        swissarmyhammer test "$PROMPT"
        break
    fi
done
</code></pre>
<h2 id="json-output-for-scripting"><a class="header" href="#json-output-for-scripting">JSON Output for Scripting</a></h2>
<h3 id="basic-json-search"><a class="header" href="#basic-json-search">Basic JSON Search</a></h3>
<pre><code class="language-bash">swissarmyhammer search --json "code review"
</code></pre>
<pre><code class="language-json">{
  "query": "code review",
  "total_found": 3,
  "results": [
    {
      "id": "code-review",
      "title": "Code Review Helper",
      "description": "Review code for best practices and potential issues",
      "source": "builtin",
      "path": "/builtin/review/code.md",
      "arguments": [
        {"name": "code", "required": true},
        {"name": "language", "required": false, "default": "auto-detect"}
      ],
      "score": 0.95
    }
  ]
}
</code></pre>
<h3 id="processing-json-results"><a class="header" href="#processing-json-results">Processing JSON Results</a></h3>
<pre><code class="language-bash"># Extract prompt IDs
swissarmyhammer search --json query | jq -r '.results[].id'

# Get highest scoring result
swissarmyhammer search --json query | jq -r '.results[0].id'

# Filter by score threshold
swissarmyhammer search --json query | jq '.results[] | select(.score &gt; 0.8)'

# Count results by source
swissarmyhammer search --json "" --limit 100 | jq '.results | group_by(.source) | map({source: .[0].source, count: length})'
</code></pre>
<h2 id="search-index-management"><a class="header" href="#search-index-management">Search Index Management</a></h2>
<h3 id="understanding-the-search-index"><a class="header" href="#understanding-the-search-index">Understanding the Search Index</a></h3>
<p>SwissArmyHammer automatically maintains a search index that includes:</p>
<ul>
<li><strong>Prompt titles</strong> - Weighted heavily in scoring</li>
<li><strong>Descriptions</strong> - Medium weight</li>
<li><strong>Content text</strong> - Lower weight</li>
<li><strong>Argument names</strong> - Considered for relevance</li>
<li><strong>File paths</strong> - Used for source filtering</li>
</ul>
<h3 id="index-updates"><a class="header" href="#index-updates">Index Updates</a></h3>
<p>The search index is automatically updated when:</p>
<ul>
<li>Prompts are added to the library</li>
<li>Existing prompts are modified</li>
<li>The <code>serve</code> command starts (full rebuild)</li>
<li>File watching detects changes</li>
</ul>
<h3 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h3>
<ul>
<li><strong>Index size</strong>: Proportional to prompt collection size</li>
<li><strong>Search speed</strong>: Sub-second for collections up to 10,000 prompts</li>
<li><strong>Memory usage</strong>: Moderate (index kept in memory)</li>
<li><strong>Update speed</strong>: Fast incremental updates</li>
</ul>
<h2 id="troubleshooting-search-issues"><a class="header" href="#troubleshooting-search-issues">Troubleshooting Search Issues</a></h2>
<h3 id="no-results-found"><a class="header" href="#no-results-found">No Results Found</a></h3>
<pre><code class="language-bash"># Check if prompts exist
swissarmyhammer search --limit 100 ""

# Verify prompt sources
swissarmyhammer search --source builtin
swissarmyhammer search --source user
swissarmyhammer search --source local

# Try broader search
swissarmyhammer search --in all "partial terms"
</code></pre>
<h3 id="too-many-results"><a class="header" href="#too-many-results">Too Many Results</a></h3>
<pre><code class="language-bash"># Use more specific terms
swissarmyhammer search "specific exact phrase"

# Limit by source
swissarmyhammer search broad-term --source user

# Use field-specific search
swissarmyhammer search --in title specific-title

# Limit result count
swissarmyhammer search broad-term --limit 5
</code></pre>
<h3 id="unexpected-results"><a class="header" href="#unexpected-results">Unexpected Results</a></h3>
<pre><code class="language-bash"># Check what's being matched
swissarmyhammer search --full query

# Use exact matching
swissarmyhammer search --regex "^exact term$"

# Search in specific field
swissarmyhammer search --in description query
</code></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<h3 id="effective-search-terms"><a class="header" href="#effective-search-terms">Effective Search Terms</a></h3>
<ol>
<li><strong>Use specific terms</strong>: â€œREST API documentationâ€ vs. â€œAPIâ€</li>
<li><strong>Include context</strong>: â€œPython debuggingâ€ vs. â€œdebuggingâ€</li>
<li><strong>Try synonyms</strong>: â€œreviewâ€, â€œanalyzeâ€, â€œexamineâ€</li>
<li><strong>Use argument names</strong>: Search for â€œcodeâ€, â€œerrorâ€, â€œdataâ€ to find relevant prompts</li>
</ol>
<h3 id="search-workflow-patterns"><a class="header" href="#search-workflow-patterns">Search Workflow Patterns</a></h3>
<ol>
<li><strong>Start broad, narrow down</strong>: Begin with general terms, add filters</li>
<li><strong>Use multiple strategies</strong>: Try both fuzzy and regex search</li>
<li><strong>Check all sources</strong>: Donâ€™t assume prompts are only in one location</li>
<li><strong>Combine with testing</strong>: Always test prompts before using</li>
</ol>
<h3 id="organization-for-searchability"><a class="header" href="#organization-for-searchability">Organization for Searchability</a></h3>
<ol>
<li><strong>Clear titles</strong>: Use descriptive, searchable titles</li>
<li><strong>Good descriptions</strong>: Include keywords and use cases</li>
<li><strong>Consistent naming</strong>: Use standard terms across prompts</li>
<li><strong>Tag with arguments</strong>: Use predictable argument names</li>
</ol>
<h2 id="advanced-examples-1"><a class="header" href="#advanced-examples-1">Advanced Examples</a></h2>
<h3 id="finding-template-patterns"><a class="header" href="#finding-template-patterns">Finding Template Patterns</a></h3>
<pre><code class="language-bash"># Find prompts using custom filters
swissarmyhammer search --in content "format_lang"

# Find prompts with error handling
swissarmyhammer search --in content "default:"

# Find prompts with loops
swissarmyhammer search --in content "{% for"
</code></pre>
<h3 id="building-prompt-collections"><a class="header" href="#building-prompt-collections">Building Prompt Collections</a></h3>
<pre><code class="language-bash"># Find all code-related prompts
swissarmyhammer search --regex "(code|programming|software)" --limit 50

# Find all documentation prompts
swissarmyhammer search --regex "(doc|documentation|readme|guide)" --limit 30

# Find all analysis prompts
swissarmyhammer search --regex "(analy|review|audit|inspect)" --limit 20
</code></pre>
<h3 id="quality-assurance"><a class="header" href="#quality-assurance">Quality Assurance</a></h3>
<pre><code class="language-bash"># Find prompts without descriptions
swissarmyhammer search --in description "^$" --regex

# Find prompts with no arguments (might need descriptions)
swissarmyhammer search --no-args --limit 50

# Find prompts with many arguments (might be complex)
swissarmyhammer search --json "" --limit 100 | \
  jq '.results[] | select(.arguments | length &gt; 5)'
</code></pre>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="./cli-search.html"><code>search</code> command</a> - Command reference</li>
<li><a href="./cli-test.html"><code>test</code> command</a> - Testing found prompts</li>
<li><a href="./prompt-organization.html">Prompt Organization</a> - Organizing for discoverability</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-and-debugging-guide"><a class="header" href="#testing-and-debugging-guide">Testing and Debugging Guide</a></h1>
<p>This guide covers testing strategies, debugging techniques, and best practices for working with SwissArmyHammer prompts.</p>
<h2 id="interactive-testing-1"><a class="header" href="#interactive-testing-1">Interactive Testing</a></h2>
<h3 id="basic-testing-workflow"><a class="header" href="#basic-testing-workflow">Basic Testing Workflow</a></h3>
<p>The <code>test</code> command provides an interactive environment for testing prompts:</p>
<pre><code class="language-bash"># Start interactive testing
swissarmyhammer test code-review
</code></pre>
<p>This will:</p>
<ol>
<li>Load the specified prompt</li>
<li>Prompt for required arguments</li>
<li>Show optional arguments with defaults</li>
<li>Render the template</li>
<li>Display the result</li>
<li>Offer additional actions (copy, save, retry)</li>
</ol>
<h3 id="testing-with-predefined-arguments"><a class="header" href="#testing-with-predefined-arguments">Testing with Predefined Arguments</a></h3>
<pre><code class="language-bash"># Test with known arguments
swissarmyhammer test code-review \
  --arg code="fn main() { println!(\"Hello\"); }" \
  --arg language="rust"

# Copy result directly to clipboard
swissarmyhammer test email-template \
  --arg recipient="John" \
  --arg subject="Meeting" \
  --copy
</code></pre>
<h2 id="debugging-template-issues"><a class="header" href="#debugging-template-issues">Debugging Template Issues</a></h2>
<h3 id="common-template-problems"><a class="header" href="#common-template-problems">Common Template Problems</a></h3>
<h4 id="missing-variables"><a class="header" href="#missing-variables">Missing Variables</a></h4>
<pre><code class="language-liquid">&lt;!-- Problem: undefined variable --&gt;
Hello {{name}}

&lt;!-- Solution: provide default --&gt;
Hello {{ name | default: "Guest" }}
</code></pre>
<h4 id="type-mismatches"><a class="header" href="#type-mismatches">Type Mismatches</a></h4>
<pre><code class="language-liquid">&lt;!-- Problem: trying to use string methods on numbers --&gt;
{{ count | upcase }}

&lt;!-- Solution: convert types --&gt;
{{ count | append: " items" }}
</code></pre>
<h4 id="loop-issues"><a class="header" href="#loop-issues">Loop Issues</a></h4>
<pre><code class="language-liquid">&lt;!-- Problem: not checking for empty arrays --&gt;
{% for item in items %}
  - {{ item }}
{% endfor %}

&lt;!-- Solution: check array exists and has items --&gt;
{% if items and items.size &gt; 0 %}
  {% for item in items %}
    - {{ item }}
  {% endfor %}
{% else %}
  No items found.
{% endif %}
</code></pre>
<h3 id="debug-mode-2"><a class="header" href="#debug-mode-2">Debug Mode</a></h3>
<p>Use debug mode to see detailed template processing:</p>
<pre><code class="language-bash">swissarmyhammer test prompt-name --debug
</code></pre>
<p>Debug output includes:</p>
<ul>
<li>Variable resolution steps</li>
<li>Filter application results</li>
<li>Conditional evaluation</li>
<li>Loop iteration details</li>
<li>Performance timing</li>
</ul>
<h2 id="validation-strategies"><a class="header" href="#validation-strategies">Validation Strategies</a></h2>
<h3 id="argument-validation-1"><a class="header" href="#argument-validation-1">Argument Validation</a></h3>
<p>Test with different argument combinations:</p>
<pre><code class="language-bash"># Test required arguments only
swissarmyhammer test prompt-name --arg required_arg="value"

# Test with all arguments
swissarmyhammer test prompt-name \
  --arg required_arg="value" \
  --arg optional_arg="optional_value"

# Test with edge cases
swissarmyhammer test prompt-name \
  --arg text="" \
  --arg number="0" \
  --arg array="[]"
</code></pre>
<h3 id="template-edge-cases"><a class="header" href="#template-edge-cases">Template Edge Cases</a></h3>
<p>Create test cases for common scenarios:</p>
<ol>
<li><strong>Empty inputs</strong></li>
<li><strong>Very long inputs</strong></li>
<li><strong>Special characters</strong></li>
<li><strong>Unicode content</strong></li>
<li><strong>Null/undefined values</strong></li>
</ol>
<h3 id="automated-testing"><a class="header" href="#automated-testing">Automated Testing</a></h3>
<p>For prompt libraries, create test scripts:</p>
<pre><code class="language-bash">#!/bin/bash
# test-all-prompts.sh

PROMPTS=$(swissarmyhammer search --json "" --limit 100 | jq -r '.results[].id')

for prompt in $PROMPTS; do
    echo "Testing $prompt..."
    if swissarmyhammer test "$prompt" --arg placeholder="test" 2&gt;/dev/null; then
        echo "âœ“ $prompt"
    else
        echo "âœ— $prompt"
    fi
done
</code></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<h3 id="measuring-render-time"><a class="header" href="#measuring-render-time">Measuring Render Time</a></h3>
<pre><code class="language-bash"># Time a complex template
time swissarmyhammer test complex-template \
  --arg large_data="$(cat large-file.json)"

# Use debug mode for detailed timing
swissarmyhammer test template-name --debug | grep "Performance:"
</code></pre>
<h3 id="memory-usage-testing"><a class="header" href="#memory-usage-testing">Memory Usage Testing</a></h3>
<p>For large templates or data:</p>
<pre><code class="language-bash"># Monitor memory usage during rendering
/usr/bin/time -v swissarmyhammer test large-template \
  --arg big_data="$(cat massive-dataset.json)"
</code></pre>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<h3 id="writing-testable-prompts"><a class="header" href="#writing-testable-prompts">Writing Testable Prompts</a></h3>
<ol>
<li><strong>Provide sensible defaults</strong> for optional arguments</li>
<li><strong>Handle empty/null inputs</strong> gracefully</li>
<li><strong>Use meaningful argument names</strong></li>
<li><strong>Include example values</strong> in descriptions</li>
<li><strong>Test with realistic data sizes</strong></li>
</ol>
<h3 id="testing-workflow"><a class="header" href="#testing-workflow">Testing Workflow</a></h3>
<ol>
<li><strong>Start simple</strong>: Test with minimal arguments</li>
<li><strong>Add complexity</strong>: Test with full argument sets</li>
<li><strong>Test edge cases</strong>: Empty, null, large inputs</li>
<li><strong>Validate output</strong>: Ensure rendered content makes sense</li>
<li><strong>Performance check</strong>: Verify reasonable render times</li>
</ol>
<h3 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging Tips</a></h3>
<ol>
<li><strong>Use debug mode</strong> for complex templates</li>
<li><strong>Test filters individually</strong> in simple templates</li>
<li><strong>Validate JSON/YAML</strong> with external tools</li>
<li><strong>Check argument types</strong> match expectations</li>
<li><strong>Use raw mode</strong> to see unprocessed templates</li>
</ol>
<h2 id="integration-with-development"><a class="header" href="#integration-with-development">Integration with Development</a></h2>
<h3 id="ide-integration-1"><a class="header" href="#ide-integration-1">IDE Integration</a></h3>
<p>Many editors support SwissArmyHammer testing:</p>
<pre><code class="language-bash"># VS Code task example
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Test Current Prompt",
      "type": "shell",
      "command": "swissarmyhammer",
      "args": ["test", "${fileBasenameNoExtension}"],
      "group": "test",
      "presentation": {
        "echo": true,
        "reveal": "always",
        "focus": false,
        "panel": "shared"
      }
    }
  ]
}
</code></pre>
<h3 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h3>
<p>Add prompt testing to CI pipelines:</p>
<pre><code class="language-yaml"># .github/workflows/test-prompts.yml
name: Test Prompts
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install SwissArmyHammer
        run: cargo install --git https://github.com/wballard/swissarmyhammer.git swissarmyhammer-cli
      - name: Test all prompts
        run: |
          for prompt in prompts/*.md; do
            name=$(basename "$prompt" .md)
            echo "Testing $name..."
            swissarmyhammer test "$name" --arg test="ci_validation"
          done
</code></pre>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="./cli-test.html"><code>test</code> command</a> - Command reference</li>
<li><a href="./template-variables.html">Template Variables</a> - Template syntax</li>
<li><a href="./custom-filters.html">Custom Filters</a> - Filter reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sharing-and-collaboration"><a class="header" href="#sharing-and-collaboration">Sharing and Collaboration</a></h1>
<p>This guide covers how to share SwissArmyHammer prompts with your team, collaborate on prompt development, and manage shared prompt libraries.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>SwissArmyHammer supports multiple collaboration workflows:</p>
<ul>
<li><strong>File Sharing</strong> - Share prompt files directly</li>
<li><strong>Git Integration</strong> - Version control for prompts</li>
<li><strong>Team Directories</strong> - Shared network folders</li>
<li><strong>Package Management</strong> - Distribute as packages</li>
</ul>
<h2 id="sharing-methods"><a class="header" href="#sharing-methods">Sharing Methods</a></h2>
<h3 id="direct-file-sharing"><a class="header" href="#direct-file-sharing">Direct File Sharing</a></h3>
<h4 id="single-prompt-sharing"><a class="header" href="#single-prompt-sharing">Single Prompt Sharing</a></h4>
<p>Share individual prompt files:</p>
<pre><code class="language-bash"># Send a single prompt
cp ~/.swissarmyhammer/prompts/code-review.md /shared/prompts/

# Share via email/chat
# Attach the .md file directly
</code></pre>
<p>Recipients install by copying to their prompt directory:</p>
<pre><code class="language-bash"># Install shared prompt
cp /downloads/code-review.md ~/.swissarmyhammer/prompts/
</code></pre>
<h4 id="prompt-collections-1"><a class="header" href="#prompt-collections-1">Prompt Collections</a></h4>
<p>Share multiple related prompts:</p>
<pre><code class="language-bash"># Create a collection
mkdir python-toolkit
cp ~/.swissarmyhammer/prompts/python-*.md python-toolkit/
cp ~/.swissarmyhammer/prompts/pytest-*.md python-toolkit/

# Share as zip
zip -r python-toolkit.zip python-toolkit/
</code></pre>
<h2 id="git-based-collaboration"><a class="header" href="#git-based-collaboration">Git-Based Collaboration</a></h2>
<h3 id="repository-structure"><a class="header" href="#repository-structure">Repository Structure</a></h3>
<p>Organize prompts in a Git repository:</p>
<pre><code>prompt-library/
â”œâ”€â”€ .git/
â”œâ”€â”€ README.md
â”œâ”€â”€ prompts/
â”‚   â”œâ”€â”€ development/
â”‚   â”‚   â”œâ”€â”€ languages/
â”‚   â”‚   â”œâ”€â”€ frameworks/
â”‚   â”‚   â””â”€â”€ tools/
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ analysis/
â”‚   â”‚   â””â”€â”€ visualization/
â”‚   â””â”€â”€ writing/
â”‚       â”œâ”€â”€ technical/
â”‚       â””â”€â”€ creative/
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ components/
â”‚   â””â”€â”€ templates/
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ validate.sh
â”‚   â””â”€â”€ install.sh
â””â”€â”€ .github/
    â””â”€â”€ workflows/
        â””â”€â”€ validate-prompts.yml
</code></pre>
<h3 id="team-workflow"><a class="header" href="#team-workflow">Team Workflow</a></h3>
<h4 id="initial-setup"><a class="header" href="#initial-setup">Initial Setup</a></h4>
<pre><code class="language-bash"># Create prompt repository
git init prompt-library
cd prompt-library

# Add initial structure
mkdir -p prompts/{development,data,writing}
mkdir -p shared/{components,templates}

# Add README
cat &gt; README.md &lt;&lt; 'EOF'
# Team Prompt Library

Shared SwissArmyHammer prompts for our team.

## Installation

```bash
git clone https://github.com/ourteam/prompt-library
./scripts/install.sh
</code></pre>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>See CONTRIBUTING.md for guidelines.
EOF</p>
<h1 id="initial-commit"><a class="header" href="#initial-commit">Initial commit</a></h1>
<p>git add .
git commit -m â€œInitial prompt library structureâ€</p>
<pre><code>
#### Installation Script

Create `scripts/install.sh`:

```bash
#!/bin/bash
# install.sh - Install team prompts

PROMPT_DIR="$HOME/.swissarmyhammer/prompts/team"

# Create team namespace
mkdir -p "$PROMPT_DIR"

# Copy prompts
cp -r prompts/* "$PROMPT_DIR/"

# Copy shared components
cp -r shared/* "$HOME/.swissarmyhammer/prompts/_shared/"

echo "Team prompts installed to $PROMPT_DIR"
echo "Run 'swissarmyhammer list' to see available prompts"
</code></pre>
<h4 id="contributing-prompts"><a class="header" href="#contributing-prompts">Contributing Prompts</a></h4>
<pre><code class="language-bash"># Clone repository
git clone https://github.com/ourteam/prompt-library
cd prompt-library

# Create feature branch
git checkout -b add-docker-prompts

# Add new prompts
mkdir -p prompts/development/docker
vim prompts/development/docker/dockerfile-optimizer.md

# Test locally
swissarmyhammer doctor --check prompts

# Commit and push
git add prompts/development/docker/
git commit -m "Add Docker optimization prompts"
git push origin add-docker-prompts

# Create pull request
gh pr create --title "Add Docker optimization prompts" \
  --body "Adds prompts for Dockerfile optimization and best practices"
</code></pre>
<h3 id="version-control-best-practices"><a class="header" href="#version-control-best-practices">Version Control Best Practices</a></h3>
<h4 id="branching-strategy"><a class="header" href="#branching-strategy">Branching Strategy</a></h4>
<pre><code class="language-bash"># Main branches
main           # Stable, tested prompts
develop        # Integration branch
feature/*      # New prompts
fix/*          # Bug fixes
experimental/* # Experimental prompts
</code></pre>
<h4 id="commit-messages"><a class="header" href="#commit-messages">Commit Messages</a></h4>
<p>Follow conventional commits:</p>
<pre><code class="language-bash"># Adding prompts
git commit -m "feat(python): add async code review prompt"

# Fixing prompts
git commit -m "fix(api-design): correct OpenAPI template syntax"

# Updating prompts
git commit -m "refactor(test-writer): improve test case generation"

# Documentation
git commit -m "docs: add prompt writing guidelines"
</code></pre>
<h4 id="pull-request-template"><a class="header" href="#pull-request-template">Pull Request Template</a></h4>
<p><code>.github/pull_request_template.md</code>:</p>
<pre><code class="language-markdown">## Description
Brief description of the prompts being added/modified

## Type of Change
- [ ] New prompt(s)
- [ ] Bug fix
- [ ] Enhancement
- [ ] Documentation

## Testing
- [ ] Tested with `swissarmyhammer doctor`
- [ ] Validated template syntax
- [ ] Checked for duplicates

## Checklist
- [ ] Follows naming conventions
- [ ] Includes required metadata
- [ ] Has meaningful description
- [ ] Includes usage examples
</code></pre>
<h3 id="automated-validation"><a class="header" href="#automated-validation">Automated Validation</a></h3>
<h4 id="github-actions-workflow"><a class="header" href="#github-actions-workflow">GitHub Actions Workflow</a></h4>
<p><code>.github/workflows/validate-prompts.yml</code>:</p>
<pre><code class="language-yaml">name: Validate Prompts

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  validate:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install SwissArmyHammer
      run: |
        curl -sSL https://install.swissarmyhammer.dev | sh
        
    - name: Validate Prompts
      run: |
        swissarmyhammer doctor --check prompts
        
    - name: Check Duplicates
      run: |
        swissarmyhammer list --format json | \
          jq -r '.[].name' | sort | uniq -d &gt; duplicates.txt
        if [ -s duplicates.txt ]; then
          echo "Duplicate prompts found:"
          cat duplicates.txt
          exit 1
        fi
        
    - name: Lint Markdown
      uses: DavidAnson/markdownlint-cli2-action@v11
      with:
        globs: 'prompts/**/*.md'
</code></pre>
<h2 id="team-directories"><a class="header" href="#team-directories">Team Directories</a></h2>
<h3 id="network-share-setup"><a class="header" href="#network-share-setup">Network Share Setup</a></h3>
<h4 id="windows-network-share"><a class="header" href="#windows-network-share">Windows Network Share</a></h4>
<pre><code class="language-powershell"># Create shared folder
New-Item -Path "\\server\prompts" -ItemType Directory

# Set permissions
$acl = Get-Acl "\\server\prompts"
$permission = "Domain\TeamMembers","ReadAndExecute","Allow"
$accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission
$acl.SetAccessRule($accessRule)
Set-Acl "\\server\prompts" $acl
</code></pre>
<p>Configure SwissArmyHammer:</p>
<pre><code class="language-toml"># ~/.swissarmyhammer/config.toml
[prompts]
directories = [
    "~/.swissarmyhammer/prompts",
    "//server/prompts"
]
</code></pre>
<h4 id="nfs-share-linuxmac"><a class="header" href="#nfs-share-linuxmac">NFS Share (Linux/Mac)</a></h4>
<pre><code class="language-bash"># Server setup
sudo mkdir -p /srv/prompts
sudo chown -R :team /srv/prompts
sudo chmod -R 775 /srv/prompts

# /etc/exports
/srv/prompts 192.168.1.0/24(ro,sync,no_subtree_check)

# Client mount
sudo mkdir -p /mnt/team-prompts
sudo mount -t nfs server:/srv/prompts /mnt/team-prompts
</code></pre>
<h3 id="syncing-strategies"><a class="header" href="#syncing-strategies">Syncing Strategies</a></h3>
<h4 id="rsync-method"><a class="header" href="#rsync-method">rsync Method</a></h4>
<pre><code class="language-bash">#!/bin/bash
# sync-prompts.sh

REMOTE="server:/srv/prompts"
LOCAL="$HOME/.swissarmyhammer/prompts/team"

# Sync from server (read-only)
rsync -avz --delete "$REMOTE/" "$LOCAL/"

# Watch for changes
while inotifywait -r -e modify,create,delete "$LOCAL"; do
    echo "Changes detected, syncing..."
    rsync -avz "$LOCAL/" "$REMOTE/"
done
</code></pre>
<h4 id="cloud-storage-sync"><a class="header" href="#cloud-storage-sync">Cloud Storage Sync</a></h4>
<p>Using rclone:</p>
<pre><code class="language-bash"># Configure rclone
rclone config

# Sync from cloud
rclone sync dropbox:team-prompts ~/.swissarmyhammer/prompts/team

# Bidirectional sync
rclone bisync dropbox:team-prompts ~/.swissarmyhammer/prompts/team
</code></pre>
<h2 id="package-management"><a class="header" href="#package-management">Package Management</a></h2>
<h3 id="creating-packages"><a class="header" href="#creating-packages">Creating Packages</a></h3>
<h4 id="npm-package"><a class="header" href="#npm-package">NPM Package</a></h4>
<p><code>package.json</code>:</p>
<pre><code class="language-json">{
  "name": "@company/swissarmyhammer-prompts",
  "version": "1.0.0",
  "description": "Company SwissArmyHammer prompts",
  "files": [
    "prompts/**/*.md",
    "install.js"
  ],
  "scripts": {
    "postinstall": "node install.js"
  },
  "keywords": ["swissarmyhammer", "prompts", "ai"],
  "repository": {
    "type": "git",
    "url": "https://github.com/company/prompts.git"
  }
}
</code></pre>
<p><code>install.js</code>:</p>
<pre><code class="language-javascript">const fs = require('fs');
const path = require('path');
const os = require('os');

const sourceDir = path.join(__dirname, 'prompts');
const targetDir = path.join(
  os.homedir(), 
  '.swissarmyhammer', 
  'prompts', 
  'company'
);

// Copy prompts to user directory
fs.cpSync(sourceDir, targetDir, { recursive: true });
console.log(`Prompts installed to ${targetDir}`);
</code></pre>
<h4 id="python-package"><a class="header" href="#python-package">Python Package</a></h4>
<p><code>setup.py</code>:</p>
<pre><code class="language-python">from setuptools import setup, find_packages
import os
from pathlib import Path

def get_prompt_files():
    """Get all prompt files for packaging."""
    prompt_files = []
    for root, dirs, files in os.walk('prompts'):
        for file in files:
            if file.endswith('.md'):
                prompt_files.append(os.path.join(root, file))
    return prompt_files

setup(
    name='company-swissarmyhammer-prompts',
    version='1.0.0',
    packages=find_packages(),
    data_files=[
        (f'.swissarmyhammer/prompts/company/{os.path.dirname(f)}', [f])
        for f in get_prompt_files()
    ],
    install_requires=[],
    entry_points={
        'console_scripts': [
            'install-company-prompts=scripts.install:main',
        ],
    },
)
</code></pre>
<h3 id="distribution-channels"><a class="header" href="#distribution-channels">Distribution Channels</a></h3>
<h4 id="internal-package-registry"><a class="header" href="#internal-package-registry">Internal Package Registry</a></h4>
<pre><code class="language-bash"># Publish to internal registry
npm publish --registry https://npm.company.com

# Install from registry
npm install @company/swissarmyhammer-prompts --registry https://npm.company.com
</code></pre>
<h4 id="container-registry"><a class="header" href="#container-registry">Container Registry</a></h4>
<p><code>Dockerfile</code>:</p>
<pre><code class="language-dockerfile">FROM alpine:latest

# Install prompts
COPY prompts /prompts

# Create tarball
RUN tar -czf /prompts.tar.gz -C / prompts

# Export as artifact
FROM scratch
COPY --from=0 /prompts.tar.gz /
</code></pre>
<pre><code class="language-bash"># Build and push
docker build -t registry.company.com/prompts:latest .
docker push registry.company.com/prompts:latest

# Pull and extract
docker create --name temp registry.company.com/prompts:latest
docker cp temp:/prompts.tar.gz .
docker rm temp
tar -xzf prompts.tar.gz -C ~/.swissarmyhammer/
</code></pre>
<h2 id="access-control"><a class="header" href="#access-control">Access Control</a></h2>
<h3 id="git-based-permissions"><a class="header" href="#git-based-permissions">Git-Based Permissions</a></h3>
<pre><code class="language-bash"># Separate repositories by access level
prompt-library-public/    # All team members
prompt-library-internal/  # Internal team only
prompt-library-sensitive/ # Restricted access
</code></pre>
<h3 id="file-system-permissions"><a class="header" href="#file-system-permissions">File System Permissions</a></h3>
<pre><code class="language-bash"># Create group-based access
sudo groupadd prompt-readers
sudo groupadd prompt-writers

# Set permissions
sudo chown -R :prompt-readers /srv/prompts
sudo chmod -R 750 /srv/prompts
sudo chmod -R 770 /srv/prompts/contributions

# Add users to groups
sudo usermod -a -G prompt-readers alice
sudo usermod -a -G prompt-writers bob
</code></pre>
<h3 id="prompt-metadata"><a class="header" href="#prompt-metadata">Prompt Metadata</a></h3>
<p>Mark prompts with access levels:</p>
<pre><code class="language-yaml">---
name: sensitive-data-analyzer
title: Sensitive Data Analysis
access: restricted
allowed_users:
  - security-team
  - data-governance
tags:
  - sensitive
  - compliance
  - restricted
---
</code></pre>
<h2 id="collaboration-tools"><a class="header" href="#collaboration-tools">Collaboration Tools</a></h2>
<h3 id="prompt-development-environment"><a class="header" href="#prompt-development-environment">Prompt Development Environment</a></h3>
<p>VS Code workspace settings:</p>
<p><code>.vscode/settings.json</code>:</p>
<pre><code class="language-json">{
  "files.associations": {
    "*.md": "markdown"
  },
  "markdown.validate.enabled": true,
  "markdown.validate.rules": {
    "yaml-front-matter": true
  },
  "files.exclude": {
    "**/.git": true,
    "**/.DS_Store": true
  },
  "search.exclude": {
    "**/node_modules": true,
    "**/.git": true
  }
}
</code></pre>
<h3 id="team-guidelines"><a class="header" href="#team-guidelines">Team Guidelines</a></h3>
<p>Create <code>CONTRIBUTING.md</code>:</p>
<pre><code class="language-markdown"># Contributing to Team Prompts

## Prompt Standards

### Naming Conventions
- Use kebab-case: `code-review-security.md`
- Be descriptive: `python-async-optimizer.md`
- Include context: `react-component-generator.md`

### Required Metadata
All prompts must include:
- `name` - Unique identifier
- `title` - Human-readable title
- `description` - What the prompt does
- `author` - Your email
- `category` - Primary category
- `tags` - At least 3 relevant tags

### Template Quality
- Use clear, concise language
- Include usage examples
- Test with various inputs
- Document edge cases

## Review Process

1. Create feature branch
2. Add/modify prompts
3. Run validation: `swissarmyhammer doctor`
4. Submit pull request
5. Address review feedback
6. Merge when approved

## Testing

Before submitting:
```bash
# Validate syntax
swissarmyhammer doctor --check prompts

# Test rendering
swissarmyhammer get your-prompt --args key=value

# Check for conflicts
swissarmyhammer list --format json | jq '.[] | select(.name=="your-prompt")'
</code></pre>
<pre><code>
### Communication

#### Slack Integration

```javascript
// slack-bot.js
const { WebClient } = require('@slack/web-api');
const { exec } = require('child_process');

const slack = new WebClient(process.env.SLACK_TOKEN);

// Notify on new prompts
async function notifyNewPrompt(promptName, author) {
  await slack.chat.postMessage({
    channel: '#prompt-library',
    text: `New prompt added: *${promptName}* by ${author}`,
    attachments: [{
      color: 'good',
      fields: [{
        title: 'View Prompt',
        value: `\`swissarmyhammer get ${promptName}\``,
        short: false
      }]
    }]
  });
}
</code></pre>
<h4 id="email-notifications"><a class="header" href="#email-notifications">Email Notifications</a></h4>
<pre><code class="language-bash">#!/bin/bash
# notify-updates.sh

RECIPIENTS="team@company.com"
SUBJECT="Prompt Library Updates"

# Get recent changes
CHANGES=$(git log --oneline --since="1 week ago" --grep="^feat\|^fix")

# Send email
echo "Weekly prompt library updates:

$CHANGES

To update your local prompts:
git pull origin main
./scripts/install.sh
" | mail -s "$SUBJECT" $RECIPIENTS
</code></pre>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<h3 id="1-establish-standards"><a class="header" href="#1-establish-standards">1. Establish Standards</a></h3>
<p>Define clear guidelines:</p>
<ul>
<li>Naming conventions</li>
<li>Required metadata</li>
<li>Quality standards</li>
<li>Review process</li>
<li>Version strategy</li>
</ul>
<h3 id="2-use-namespaces"><a class="header" href="#2-use-namespaces">2. Use Namespaces</a></h3>
<p>Organize prompts by team/project:</p>
<pre><code>~/.swissarmyhammer/prompts/
â”œâ”€â”€ personal/       # Your prompts
â”œâ”€â”€ team/          # Team shared
â”œâ”€â”€ company/       # Company wide
â””â”€â”€ community/     # Open source
</code></pre>
<h3 id="3-document-everything"><a class="header" href="#3-document-everything">3. Document Everything</a></h3>
<ul>
<li>README for each category</li>
<li>Usage examples in prompts</li>
<li>Change logs for versions</li>
<li>Migration guides</li>
</ul>
<h3 id="4-automate-validation"><a class="header" href="#4-automate-validation">4. Automate Validation</a></h3>
<ul>
<li>Pre-commit hooks</li>
<li>CI/CD validation</li>
<li>Automated testing</li>
<li>Quality metrics</li>
</ul>
<h3 id="5-regular-maintenance"><a class="header" href="#5-regular-maintenance">5. Regular Maintenance</a></h3>
<ul>
<li>Review unused prompts</li>
<li>Update outdated content</li>
<li>Consolidate duplicates</li>
<li>Archive deprecated</li>
</ul>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<h3 id="team-onboarding"><a class="header" href="#team-onboarding">Team Onboarding</a></h3>
<p>Create onboarding bundle:</p>
<pre><code class="language-bash">#!/bin/bash
# create-onboarding-bundle.sh

# Create directory structure
mkdir -p onboarding-prompts/prompts

# Copy essential prompts
cp ~/.swissarmyhammer/prompts/*onboarding*.md onboarding-prompts/prompts/
cp ~/.swissarmyhammer/prompts/*essential*.md onboarding-prompts/prompts/

# Add setup script
cat &gt; onboarding-prompts/setup.sh &lt;&lt; 'EOF'
#!/bin/bash
echo "Welcome to the team! Setting up your prompts..."
cp -r prompts/* ~/.swissarmyhammer/prompts/
echo "Run 'swissarmyhammer list' to see your new prompts!"
EOF

# Create welcome package
tar -czf welcome-pack.tar.gz onboarding-prompts/
</code></pre>
<h3 id="project-templates"><a class="header" href="#project-templates">Project Templates</a></h3>
<p>Share project-specific prompts:</p>
<pre><code class="language-yaml"># project-manifest.yaml
name: microservice-toolkit
version: 1.0.0
description: Prompts for microservice development
prompts:
  - api-design
  - openapi-generator
  - dockerfile-creator
  - k8s-manifest-builder
  - test-suite-generator
dependencies:
  - base-toolkit: "&gt;=1.0.0"
install_script: |
  mkdir -p ~/.swissarmyhammer/prompts/projects/microservices
  cp prompts/*.md ~/.swissarmyhammer/prompts/projects/microservices/
</code></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<ul>
<li>Read <a href="./prompt-organization.html">Prompt Organization</a> for structure best practices</li>
<li>See <a href="./contributing.html">Contributing</a> for contribution guidelines</li>
<li>Explore <a href="./development.html">Git Integration</a> for version control workflows</li>
<li>Learn about <a href="./configuration.html">Configuration</a> for team setup</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mcp-protocol"><a class="header" href="#mcp-protocol">MCP Protocol</a></h1>
<p>SwissArmyHammer implements the Model Context Protocol (MCP) to provide prompts to AI assistants like Claude. This guide covers the protocol details and implementation specifics.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The Model Context Protocol (MCP) is a standardized protocol for communication between AI assistants and context providers. SwissArmyHammer acts as an MCP server, providing prompt templates as resources and tools.</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         MCP          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Claude    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ SwissArmyHammer  â”‚
â”‚  (Client)   â”‚    JSON-RPC 2.0      â”‚    (Server)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="protocol-basics"><a class="header" href="#protocol-basics">Protocol Basics</a></h2>
<h3 id="transport"><a class="header" href="#transport">Transport</a></h3>
<p>MCP uses JSON-RPC 2.0 over various transports:</p>
<ul>
<li><strong>stdio</strong> - Standard input/output (default for Claude Code)</li>
<li><strong>HTTP</strong> - REST API endpoints</li>
<li><strong>WebSocket</strong> - Persistent connections</li>
</ul>
<h3 id="message-format"><a class="header" href="#message-format">Message Format</a></h3>
<p>All messages follow JSON-RPC 2.0 format:</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "prompts/list",
  "params": {},
  "id": 1
}
</code></pre>
<p>Response format:</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": {
    "prompts": [...]
  },
  "id": 1
}
</code></pre>
<h2 id="mcp-methods"><a class="header" href="#mcp-methods">MCP Methods</a></h2>
<h3 id="initialize"><a class="header" href="#initialize">Initialize</a></h3>
<p>Establishes connection and capabilities:</p>
<pre><code class="language-json">// Request
{
  "jsonrpc": "2.0",
  "method": "initialize",
  "params": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "prompts": {},
      "resources": {}
    },
    "clientInfo": {
      "name": "claude-code",
      "version": "1.0.0"
    }
  },
  "id": 1
}

// Response
{
  "jsonrpc": "2.0",
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "prompts": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "swissarmyhammer",
      "version": "0.1.0"
    }
  },
  "id": 1
}
</code></pre>
<h3 id="list-prompts"><a class="header" href="#list-prompts">List Prompts</a></h3>
<p>Get available prompts:</p>
<pre><code class="language-json">// Request
{
  "jsonrpc": "2.0",
  "method": "prompts/list",
  "params": {
    "cursor": null
  },
  "id": 2
}

// Response
{
  "jsonrpc": "2.0",
  "result": {
    "prompts": [
      {
        "id": "code-review",
        "name": "Code Review",
        "description": "Reviews code for best practices and issues",
        "arguments": [
          {
            "name": "code",
            "description": "The code to review",
            "required": true
          },
          {
            "name": "language",
            "description": "Programming language",
            "required": false
          }
        ]
      }
    ],
    "nextCursor": null
  },
  "id": 2
}
</code></pre>
<h3 id="get-prompt"><a class="header" href="#get-prompt">Get Prompt</a></h3>
<p>Retrieve a specific prompt with arguments:</p>
<pre><code class="language-json">// Request
{
  "jsonrpc": "2.0",
  "method": "prompts/get",
  "params": {
    "promptId": "code-review",
    "arguments": {
      "code": "def add(a, b):\n    return a + b",
      "language": "python"
    }
  },
  "id": 3
}

// Response
{
  "jsonrpc": "2.0",
  "result": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "Please review this python code:\n\n```python\ndef add(a, b):\n    return a + b\n```\n\nFocus on:\n- Code quality\n- Best practices\n- Potential issues"
        }
      }
    ]
  },
  "id": 3
}
</code></pre>
<h3 id="list-resources"><a class="header" href="#list-resources">List Resources</a></h3>
<p>Get available resources (prompt source files):</p>
<pre><code class="language-json">// Request
{
  "jsonrpc": "2.0",
  "method": "resources/list",
  "params": {
    "cursor": null
  },
  "id": 4
}

// Response
{
  "jsonrpc": "2.0",
  "result": {
    "resources": [
      {
        "uri": "prompt://code-review",
        "name": "code-review.md",
        "description": "Code review prompt source",
        "mimeType": "text/markdown"
      }
    ],
    "nextCursor": null
  },
  "id": 4
}
</code></pre>
<h3 id="read-resource"><a class="header" href="#read-resource">Read Resource</a></h3>
<p>Get resource content:</p>
<pre><code class="language-json">// Request
{
  "jsonrpc": "2.0",
  "method": "resources/read",
  "params": {
    "uri": "prompt://code-review"
  },
  "id": 5
}

// Response
{
  "jsonrpc": "2.0",
  "result": {
    "contents": [
      {
        "uri": "prompt://code-review",
        "mimeType": "text/markdown",
        "text": "---\nname: code-review\ntitle: Code Review\n---\n\n# Code Review\n..."
      }
    ]
  },
  "id": 5
}
</code></pre>
<h2 id="notifications"><a class="header" href="#notifications">Notifications</a></h2>
<h3 id="prompt-list-changed"><a class="header" href="#prompt-list-changed">Prompt List Changed</a></h3>
<p>Sent when prompts are added/removed/modified:</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "notifications/prompts/list_changed",
  "params": {}
}
</code></pre>
<h3 id="resource-list-changed"><a class="header" href="#resource-list-changed">Resource List Changed</a></h3>
<p>Sent when resources change:</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "notifications/resources/list_changed",
  "params": {}
}
</code></pre>
<h2 id="error-handling-8"><a class="header" href="#error-handling-8">Error Handling</a></h2>
<p>MCP defines standard error codes:</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "error": {
    "code": -32602,
    "message": "Invalid params",
    "data": {
      "details": "Missing required argument 'code'"
    }
  },
  "id": 6
}
</code></pre>
<p>Standard error codes:</p>
<ul>
<li><code>-32700</code> - Parse error</li>
<li><code>-32600</code> - Invalid request</li>
<li><code>-32601</code> - Method not found</li>
<li><code>-32602</code> - Invalid params</li>
<li><code>-32603</code> - Internal error</li>
</ul>
<p>Custom error codes:</p>
<ul>
<li><code>1001</code> - Prompt not found</li>
<li><code>1002</code> - Invalid prompt format</li>
<li><code>1003</code> - Template render error</li>
</ul>
<h2 id="swissarmyhammer-extensions"><a class="header" href="#swissarmyhammer-extensions">SwissArmyHammer Extensions</a></h2>
<h3 id="pagination"><a class="header" href="#pagination">Pagination</a></h3>
<p>For large prompt collections:</p>
<pre><code class="language-json">// Request with pagination
{
  "jsonrpc": "2.0",
  "method": "prompts/list",
  "params": {
    "cursor": "eyJvZmZzZXQiOjUwfQ==",
    "limit": 50
  },
  "id": 7
}
</code></pre>
<h3 id="filtering-1"><a class="header" href="#filtering-1">Filtering</a></h3>
<p>Filter prompts by criteria:</p>
<pre><code class="language-json">// Request with filters
{
  "jsonrpc": "2.0",
  "method": "prompts/list",
  "params": {
    "filter": {
      "category": "development",
      "tags": ["python", "testing"]
    }
  },
  "id": 8
}
</code></pre>
<h3 id="metadata"><a class="header" href="#metadata">Metadata</a></h3>
<p>Extended prompt metadata:</p>
<pre><code class="language-json">{
  "id": "code-review",
  "name": "Code Review",
  "description": "Reviews code for best practices",
  "metadata": {
    "author": "SwissArmyHammer Team",
    "version": "1.0.0",
    "category": "development",
    "tags": ["code", "review", "quality"],
    "lastModified": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="server-lifecycle"><a class="header" href="#server-lifecycle">Server Lifecycle</a></h3>
<ol>
<li>
<p><strong>Initialization</strong></p>
<pre><code class="language-rust">// Server startup sequence
let server = MCPServer::new();
server.load_prompts()?;
server.start_file_watcher()?;
server.listen(transport)?;</code></pre>
</li>
<li>
<p><strong>Request Handling</strong></p>
<pre><code class="language-rust">match request.method.as_str() {
    "initialize" =&gt; handle_initialize(params),
    "prompts/list" =&gt; handle_list_prompts(params),
    "prompts/get" =&gt; handle_get_prompt(params),
    "resources/list" =&gt; handle_list_resources(params),
    "resources/read" =&gt; handle_read_resource(params),
    _ =&gt; Err(MethodNotFound),
}</code></pre>
</li>
<li>
<p><strong>Change Detection</strong></p>
<pre><code class="language-rust">// File watcher triggers notifications
watcher.on_change(|event| {
    server.reload_prompts();
    server.notify_clients("prompts/list_changed");
});</code></pre>
</li>
</ol>
<h3 id="transport-implementations"><a class="header" href="#transport-implementations">Transport Implementations</a></h3>
<h4 id="stdio-transport"><a class="header" href="#stdio-transport">stdio Transport</a></h4>
<p>Default for Claude Code integration:</p>
<pre><code class="language-rust">// Read from stdin, write to stdout
let stdin = io::stdin();
let stdout = io::stdout();

loop {
    let request = read_json_rpc(&amp;mut stdin)?;
    let response = server.handle_request(request)?;
    write_json_rpc(&amp;mut stdout, response)?;
}</code></pre>
<h4 id="http-transport"><a class="header" href="#http-transport">HTTP Transport</a></h4>
<p>For web integrations:</p>
<pre><code class="language-rust">// HTTP endpoint handler
async fn handle_mcp(Json(request): Json&lt;MCPRequest&gt;) -&gt; Json&lt;MCPResponse&gt; {
    let response = server.handle_request(request).await;
    Json(response)
}</code></pre>
<h4 id="websocket-transport"><a class="header" href="#websocket-transport">WebSocket Transport</a></h4>
<p>For real-time updates:</p>
<pre><code class="language-rust">// WebSocket handler
async fn handle_websocket(ws: WebSocket, server: Arc&lt;MCPServer&gt;) {
    let (tx, rx) = ws.split();
    
    // Handle incoming messages
    rx.for_each(|msg| async {
        if let Ok(request) = parse_json_rpc(msg) {
            let response = server.handle_request(request).await;
            tx.send(serialize_json_rpc(response)).await;
        }
    }).await;
}</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<p>MCP doesnâ€™t specify authentication, but SwissArmyHammer supports:</p>
<pre><code class="language-json">// With API key
{
  "jsonrpc": "2.0",
  "method": "initialize",
  "params": {
    "authentication": {
      "type": "bearer",
      "token": "sk-..."
    }
  },
  "id": 1
}
</code></pre>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<p>Prevent abuse:</p>
<pre><code class="language-rust">// Rate limit configuration
rate_limiter: {
    requests_per_minute: 100,
    burst_size: 20,
    per_method: {
        "prompts/get": 50,
        "resources/read": 30
    }
}</code></pre>
<h3 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h3>
<p>All inputs are validated:</p>
<pre><code class="language-rust">// Validate prompt arguments
fn validate_arguments(args: &amp;HashMap&lt;String, Value&gt;) -&gt; Result&lt;()&gt; {
    // Check required fields
    // Validate data types
    // Sanitize inputs
    // Check size limits
}</code></pre>
<h2 id="performance-optimization-2"><a class="header" href="#performance-optimization-2">Performance Optimization</a></h2>
<h3 id="caching"><a class="header" href="#caching">Caching</a></h3>
<p>Responses are cached for efficiency:</p>
<pre><code class="language-rust">// Cache configuration
cache: {
    prompts_list: {
        ttl: 300,  // 5 minutes
        max_size: 1000
    },
    rendered_prompts: {
        ttl: 3600,  // 1 hour
        max_size: 10000
    }
}</code></pre>
<h3 id="streaming"><a class="header" href="#streaming">Streaming</a></h3>
<p>Large responses support streaming:</p>
<pre><code class="language-json">// Streaming response
{
  "jsonrpc": "2.0",
  "result": {
    "stream": true,
    "chunks": [
      {"index": 0, "data": "First chunk..."},
      {"index": 1, "data": "Second chunk..."},
      {"index": 2, "data": "Final chunk", "final": true}
    ]
  },
  "id": 9
}
</code></pre>
<h2 id="testing-mcp"><a class="header" href="#testing-mcp">Testing MCP</a></h2>
<h3 id="manual-testing"><a class="header" href="#manual-testing">Manual Testing</a></h3>
<p>Test with curl:</p>
<pre><code class="language-bash"># Test initialize
echo '{"jsonrpc":"2.0","method":"initialize","params":{},"id":1}' | \
  swissarmyhammer serve --transport stdio

# Test prompts list
curl -X POST http://localhost:3333/mcp \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"prompts/list","params":{},"id":2}'
</code></pre>
<h3 id="automated-testing-1"><a class="header" href="#automated-testing-1">Automated Testing</a></h3>
<pre><code class="language-rust">#[test]
async fn test_mcp_protocol() {
    let server = MCPServer::new_test();
    
    // Test initialize
    let response = server.handle_request(json!({
        "jsonrpc": "2.0",
        "method": "initialize",
        "params": {},
        "id": 1
    })).await;
    
    assert_eq!(response["result"]["serverInfo"]["name"], "swissarmyhammer");
}</code></pre>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="enable-debug-logging"><a class="header" href="#enable-debug-logging">Enable Debug Logging</a></h3>
<pre><code class="language-yaml">logging:
  modules:
    swissarmyhammer::mcp: debug
</code></pre>
<h3 id="requestresponse-logging"><a class="header" href="#requestresponse-logging">Request/Response Logging</a></h3>
<pre><code class="language-rust">// Log all MCP traffic
middleware: {
    log_requests: true,
    log_responses: true,
    log_errors: true,
    pretty_print: true
}</code></pre>
<h3 id="protocol-inspector"><a class="header" href="#protocol-inspector">Protocol Inspector</a></h3>
<pre><code class="language-bash"># Inspect MCP traffic
swissarmyhammer mcp-inspector --port 3334

# Connect through inspector
export MCP_PROXY=http://localhost:3334
</code></pre>
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<ol>
<li><strong>Always validate inputs</strong> - Never trust client data</li>
<li><strong>Handle errors gracefully</strong> - Return proper error codes</li>
<li><strong>Implement timeouts</strong> - Prevent hanging requests</li>
<li><strong>Cache when possible</strong> - Reduce computation</li>
<li><strong>Log important events</strong> - Aid debugging</li>
<li><strong>Version your changes</strong> - Maintain compatibility</li>
<li><strong>Document extensions</strong> - Help client implementers</li>
</ol>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li>Implement <a href="./claude-code-integration.html">Claude Code Integration</a></li>
<li>Review <a href="./api-reference.html">API Reference</a> for details</li>
<li>See <a href="./troubleshooting.html">Troubleshooting</a> for common issues</li>
<li>Check <a href="./examples.html">Examples</a> for implementation patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h1>
<p>SwissArmyHammer offers flexible configuration options through configuration files, environment variables, and command-line arguments. This guide covers all configuration methods and settings.</p>
<h2 id="configuration-file-2"><a class="header" href="#configuration-file-2">Configuration File</a></h2>
<h3 id="location"><a class="header" href="#location">Location</a></h3>
<p>SwissArmyHammer looks for configuration files in this order:</p>
<ol>
<li><code>./swissarmyhammer.toml</code> (current directory)</li>
<li><code>~/.swissarmyhammer/config.toml</code> (user directory)</li>
<li><code>/etc/swissarmyhammer/config.toml</code> (system-wide)</li>
</ol>
<h3 id="format"><a class="header" href="#format">Format</a></h3>
<p>Configuration uses TOML format:</p>
<pre><code class="language-toml"># ~/.swissarmyhammer/config.toml

# Server configuration
[server]
host = "localhost"
port = 8080
debug = false
timeout = 30000  # milliseconds

# Prompt directories
[prompts]
directories = [
    "~/.swissarmyhammer/prompts",
    "./prompts",
    "/opt/company/prompts"
]
builtin = true
watch = true

# File watching configuration
[watch]
enabled = true
poll_interval = 1000  # milliseconds
max_depth = 5
ignore_patterns = [
    "*.tmp",
    "*.swp",
    ".git/*",
    "__pycache__/*"
]

# Logging configuration
[log]
level = "info"  # debug, info, warn, error
file = "~/.swissarmyhammer/logs/server.log"
rotate = true
max_size = "10MB"
max_age = 30  # days

# Cache configuration
[cache]
enabled = true
directory = "~/.swissarmyhammer/cache"
ttl = 3600  # seconds
max_size = "100MB"

# Template engine configuration
[template]
strict_variables = false
strict_filters = false
custom_filters_path = "~/.swissarmyhammer/filters"

# Security settings
[security]
allow_file_access = false
allow_network_access = false
sandbox_mode = true
allowed_domains = ["api.company.com", "github.com"]

# MCP specific settings
[mcp]
protocol_version = "1.0"
capabilities = ["prompts", "notifications"]
max_prompt_size = 1048576  # 1MB
compression = true
</code></pre>
<h2 id="environment-variables-5"><a class="header" href="#environment-variables-5">Environment Variables</a></h2>
<p>All configuration options can be set via environment variables:</p>
<h3 id="naming-convention"><a class="header" href="#naming-convention">Naming Convention</a></h3>
<ul>
<li>Prefix: <code>SWISSARMYHAMMER_</code></li>
<li>Nested values use underscores: <code>SECTION_KEY</code></li>
<li>Arrays use comma separation</li>
</ul>
<h3 id="examples-9"><a class="header" href="#examples-9">Examples</a></h3>
<pre><code class="language-bash"># Server settings
export SWISSARMYHAMMER_SERVER_HOST=0.0.0.0
export SWISSARMYHAMMER_SERVER_PORT=9000
export SWISSARMYHAMMER_SERVER_DEBUG=true

# Prompt directories (comma-separated)
export SWISSARMYHAMMER_PROMPTS_DIRECTORIES="/opt/prompts,~/my-prompts"
export SWISSARMYHAMMER_PROMPTS_BUILTIN=false

# Logging
export SWISSARMYHAMMER_LOG_LEVEL=debug
export SWISSARMYHAMMER_LOG_FILE=/var/log/swissarmyhammer.log

# File watching
export SWISSARMYHAMMER_WATCH_ENABLED=true
export SWISSARMYHAMMER_WATCH_POLL_INTERVAL=2000

# Security
export SWISSARMYHAMMER_SECURITY_SANDBOX_MODE=true
export SWISSARMYHAMMER_SECURITY_ALLOWED_DOMAINS="api.example.com,cdn.example.com"
</code></pre>
<h3 id="precedence"><a class="header" href="#precedence">Precedence</a></h3>
<p>Configuration precedence (highest to lowest):</p>
<ol>
<li>Command-line arguments</li>
<li>Environment variables</li>
<li>Configuration files</li>
<li>Default values</li>
</ol>
<h2 id="command-line-options"><a class="header" href="#command-line-options">Command-Line Options</a></h2>
<h3 id="global-options-1"><a class="header" href="#global-options-1">Global Options</a></h3>
<pre><code class="language-bash">swissarmyhammer [GLOBAL_OPTIONS] &lt;COMMAND&gt; [COMMAND_OPTIONS]

Global Options:
  --config &lt;FILE&gt;     Use specific configuration file
  --verbose          Enable verbose output
  --quiet            Suppress non-error output
  --no-color         Disable colored output
  --json             Output in JSON format
  --help             Show help information
  --version          Show version information
</code></pre>
<h3 id="per-command-configuration"><a class="header" href="#per-command-configuration">Per-Command Configuration</a></h3>
<p>Override configuration for specific commands:</p>
<pre><code class="language-bash"># Override server settings
swissarmyhammer serve --host 0.0.0.0 --port 9000 --debug

# Override prompt directories
swissarmyhammer serve --prompts /custom/prompts --no-builtin

# Override logging
swissarmyhammer serve --log-level debug --log-file server.log
</code></pre>
<h2 id="configuration-sections"><a class="header" href="#configuration-sections">Configuration Sections</a></h2>
<h3 id="server-configuration-1"><a class="header" href="#server-configuration-1">Server Configuration</a></h3>
<p>Controls the MCP server behavior:</p>
<pre><code class="language-toml">[server]
# Network binding
host = "localhost"      # IP address or hostname
port = 8080            # Port number (0 for auto-assign)

# Performance
workers = 4            # Number of worker threads
max_connections = 100  # Maximum concurrent connections
timeout = 30000        # Request timeout in milliseconds

# Debugging
debug = false          # Enable debug mode
trace = false          # Enable trace logging
metrics = true         # Enable metrics collection
</code></pre>
<h3 id="prompt-configuration"><a class="header" href="#prompt-configuration">Prompt Configuration</a></h3>
<p>Manages prompt loading and directories:</p>
<pre><code class="language-toml">[prompts]
# Directories to load prompts from
directories = [
    "~/.swissarmyhammer/prompts",    # User prompts
    "./prompts",                      # Project prompts
    "/opt/shared/prompts"             # Shared prompts
]

# Loading behavior
builtin = true          # Include built-in prompts
watch = true            # Enable file watching
recursive = true        # Scan directories recursively
follow_symlinks = false # Follow symbolic links

# Filtering
include_patterns = ["*.md", "*.markdown"]
exclude_patterns = ["*.draft.md", "test-*"]

# Validation
strict_validation = true     # Fail on invalid prompts
required_fields = ["name", "description"]
max_file_size = "1MB"       # Maximum prompt file size
</code></pre>
<h3 id="file-watching-2"><a class="header" href="#file-watching-2">File Watching</a></h3>
<p>Configure file system monitoring:</p>
<pre><code class="language-toml">[watch]
enabled = true              # Enable/disable watching
strategy = "efficient"      # efficient, aggressive, polling

# Polling strategy settings
poll_interval = 1000        # Milliseconds between polls
poll_timeout = 100          # Polling timeout

# Watch behavior
debounce = 500             # Milliseconds to wait for changes to settle
max_depth = 10             # Maximum directory depth
batch_events = true        # Batch multiple changes

# Ignore patterns
ignore_patterns = [
    "*.tmp",
    "*.swp",
    "*.bak",
    ".git/**",
    ".svn/**",
    "__pycache__/**",
    "node_modules/**"
]

# Performance
max_watches = 10000        # Maximum number of watches
event_buffer_size = 1000   # Event queue size
</code></pre>
<h3 id="logging"><a class="header" href="#logging">Logging</a></h3>
<p>Configure logging behavior:</p>
<pre><code class="language-toml">[log]
# Log level: trace, debug, info, warn, error
level = "info"

# Console output
console = true
console_format = "pretty"  # pretty, json, compact
console_colors = true

# File logging
file = "~/.swissarmyhammer/logs/server.log"
file_format = "json"
rotate = true
max_size = "10MB"
max_files = 5
max_age = 30  # days

# Log filtering
include_modules = ["server", "prompts"]
exclude_modules = ["watcher"]

# Performance
buffer_size = 8192
async = true
</code></pre>
<h3 id="cache-configuration"><a class="header" href="#cache-configuration">Cache Configuration</a></h3>
<p>Control caching behavior:</p>
<pre><code class="language-toml">[cache]
enabled = true
directory = "~/.swissarmyhammer/cache"

# Cache strategy
strategy = "lru"           # lru, lfu, ttl
max_entries = 1000
max_size = "100MB"

# Time-based settings
ttl = 3600                # Default TTL in seconds
refresh_ahead = 300       # Refresh cache 5 minutes before expiry

# Cache categories
[cache.prompts]
enabled = true
ttl = 7200

[cache.templates]
enabled = true
ttl = 3600

[cache.search]
enabled = false           # Disable search result caching
</code></pre>
<h3 id="template-engine-2"><a class="header" href="#template-engine-2">Template Engine</a></h3>
<p>Configure Liquid template processing:</p>
<pre><code class="language-toml">[template]
# Parsing
strict_variables = false   # Error on undefined variables
strict_filters = false     # Error on undefined filters
error_mode = "warn"        # warn, error, ignore

# Custom extensions
custom_filters_path = "~/.swissarmyhammer/filters"
custom_tags_path = "~/.swissarmyhammer/tags"

# Security
allow_includes = true
include_paths = ["~/.swissarmyhammer/includes"]
max_render_depth = 10
max_iterations = 1000

# Performance
cache_templates = true
compile_cache = "~/.swissarmyhammer/template_cache"
</code></pre>
<h3 id="security-settings"><a class="header" href="#security-settings">Security Settings</a></h3>
<p>Control security features:</p>
<pre><code class="language-toml">[security]
# Sandboxing
sandbox_mode = true        # Enable security sandbox
allow_file_access = false  # Allow template file access
allow_network_access = false # Allow network requests
allow_system_access = false # Allow system commands

# Network security
allowed_domains = [
    "api.company.com",
    "cdn.company.com",
    "github.com"
]
blocked_domains = [
    "malicious.site"
]

# File security
allowed_paths = [
    "~/Documents/projects",
    "/opt/shared/data"
]
blocked_paths = [
    "/etc",
    "/sys",
    "~/.ssh"
]

# Content security
max_input_size = "10MB"
max_output_size = "50MB"
sanitize_html = true
</code></pre>
<h2 id="configuration-profiles"><a class="header" href="#configuration-profiles">Configuration Profiles</a></h2>
<h3 id="using-profiles"><a class="header" href="#using-profiles">Using Profiles</a></h3>
<p>Define multiple configuration profiles:</p>
<pre><code class="language-toml"># Default configuration
[default]
server.host = "localhost"
server.port = 8080
log.level = "info"

# Development profile
[profiles.development]
server.debug = true
log.level = "debug"
cache.enabled = false
template.strict_variables = true

# Production profile
[profiles.production]
server.host = "0.0.0.0"
server.workers = 8
log.level = "warn"
security.sandbox_mode = true

# Testing profile
[profiles.test]
server.port = 0  # Auto-assign
log.file = "/tmp/test.log"
prompts.directories = ["./test/fixtures"]
</code></pre>
<h3 id="activating-profiles"><a class="header" href="#activating-profiles">Activating Profiles</a></h3>
<pre><code class="language-bash"># Via environment variable
export SWISSARMYHAMMER_PROFILE=production
swissarmyhammer serve

# Via command line
swissarmyhammer --profile development serve

# Multiple profiles (later overrides earlier)
swissarmyhammer --profile production --profile custom serve
</code></pre>
<h2 id="advanced-configuration"><a class="header" href="#advanced-configuration">Advanced Configuration</a></h2>
<h3 id="dynamic-configuration"><a class="header" href="#dynamic-configuration">Dynamic Configuration</a></h3>
<p>Load configuration from external sources:</p>
<pre><code class="language-toml">[config]
# Load additional config from URL
remote_config = "https://config.company.com/swissarmyhammer"
remote_check_interval = 300  # seconds

# Load from environment-specific file
env_config = "/etc/swissarmyhammer/config.${ENV}.toml"

# Merge strategy
merge_strategy = "deep"  # deep, shallow, replace
</code></pre>
<h3 id="hooks-configuration"><a class="header" href="#hooks-configuration">Hooks Configuration</a></h3>
<p>Configure lifecycle hooks:</p>
<pre><code class="language-toml">[hooks]
# Startup hooks
pre_start = [
    "~/scripts/pre-start.sh",
    "/opt/swissarmyhammer/hooks/validate.py"
]
post_start = [
    "~/scripts/notify-start.sh"
]

# Shutdown hooks
pre_stop = [
    "~/scripts/save-state.sh"
]
post_stop = [
    "~/scripts/cleanup.sh"
]

# Prompt hooks
pre_load = "~/scripts/validate-prompt.sh"
post_load = "~/scripts/index-prompt.sh"

# Error hooks
on_error = "~/scripts/error-handler.sh"

# Hook configuration
[hooks.config]
timeout = 30           # seconds
fail_on_error = false  # Continue if hook fails
environment = {
    CUSTOM_VAR = "value"
}
</code></pre>
<h3 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h3>
<p>Optimize for different scenarios:</p>
<pre><code class="language-toml">[performance]
# Threading
thread_pool_size = 8
async_workers = 4
io_threads = 2

# Memory
max_memory = "2GB"
gc_interval = 300      # seconds
cache_pressure = 0.8   # Evict cache at 80% memory

# Network
connection_pool_size = 50
keep_alive = true
tcp_nodelay = true
socket_timeout = 30

# File I/O
read_buffer_size = 8192
write_buffer_size = 8192
use_mmap = true        # Memory-mapped files

# Optimizations
lazy_loading = true
parallel_parsing = true
compress_cache = true
</code></pre>
<h3 id="monitoring-configuration"><a class="header" href="#monitoring-configuration">Monitoring Configuration</a></h3>
<p>Enable monitoring and metrics:</p>
<pre><code class="language-toml">[monitoring]
enabled = true

# Metrics collection
[monitoring.metrics]
enabled = true
interval = 60          # seconds
retention = 7          # days

# Metrics to collect
collect = [
    "cpu_usage",
    "memory_usage",
    "prompt_count",
    "request_rate",
    "error_rate",
    "cache_hit_rate"
]

# Export metrics
[monitoring.export]
format = "prometheus"  # prometheus, json, statsd
endpoint = "http://metrics.company.com:9090"
labels = {
    service = "swissarmyhammer",
    environment = "production"
}

# Health checks
[monitoring.health]
enabled = true
endpoint = "/health"
checks = [
    "server_status",
    "prompt_loading",
    "file_watcher",
    "cache_status"
]
</code></pre>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<h3 id="minimal-configuration"><a class="header" href="#minimal-configuration">Minimal Configuration</a></h3>
<pre><code class="language-toml"># Minimal working configuration
[server]
host = "localhost"
port = 8080

[prompts]
directories = ["~/.swissarmyhammer/prompts"]
</code></pre>
<h3 id="development-configuration"><a class="header" href="#development-configuration">Development Configuration</a></h3>
<pre><code class="language-toml"># Development-optimized configuration
[server]
host = "localhost"
port = 8080
debug = true

[prompts]
directories = [
    "./prompts",
    "~/.swissarmyhammer/prompts"
]
watch = true

[log]
level = "debug"
console = true

[cache]
enabled = false  # Disable caching for development

[template]
strict_variables = true  # Catch template errors early
</code></pre>
<h3 id="production-configuration"><a class="header" href="#production-configuration">Production Configuration</a></h3>
<pre><code class="language-toml"># Production-optimized configuration
[server]
host = "0.0.0.0"
port = 80
workers = 8
timeout = 60000

[prompts]
directories = [
    "/opt/swissarmyhammer/prompts",
    "/var/lib/swissarmyhammer/prompts"
]
builtin = true
watch = false  # Disable for performance

[log]
level = "warn"
file = "/var/log/swissarmyhammer/server.log"
rotate = true
max_size = "100MB"
max_files = 10

[cache]
enabled = true
strategy = "lru"
max_size = "1GB"

[security]
sandbox_mode = true
allow_file_access = false
allow_network_access = false

[monitoring]
enabled = true
metrics.enabled = true
health.enabled = true
</code></pre>
<h3 id="high-performance-configuration"><a class="header" href="#high-performance-configuration">High-Performance Configuration</a></h3>
<pre><code class="language-toml"># Optimized for high load
[server]
workers = 16
max_connections = 1000
timeout = 120000

[performance]
thread_pool_size = 32
async_workers = 16
connection_pool_size = 200
lazy_loading = true
parallel_parsing = true

[cache]
enabled = true
strategy = "lfu"
max_size = "4GB"
refresh_ahead = 600

[watch]
enabled = false  # Disable for performance

[log]
level = "error"  # Minimize logging overhead
async = true
buffer_size = 65536
</code></pre>
<h2 id="configuration-validation"><a class="header" href="#configuration-validation">Configuration Validation</a></h2>
<h3 id="validate-configuration"><a class="header" href="#validate-configuration">Validate Configuration</a></h3>
<pre><code class="language-bash"># Validate configuration file
swissarmyhammer config validate

# Validate specific file
swissarmyhammer config validate --file custom-config.toml

# Show effective configuration
swissarmyhammer config show

# Show configuration with sources
swissarmyhammer config show --sources
</code></pre>
<h3 id="configuration-schema"><a class="header" href="#configuration-schema">Configuration Schema</a></h3>
<pre><code class="language-bash"># Generate configuration schema
swissarmyhammer config schema &gt; config-schema.json

# Validate against schema
swissarmyhammer config validate --schema config-schema.json
</code></pre>
<h2 id="best-practices-14"><a class="header" href="#best-practices-14">Best Practices</a></h2>
<h3 id="1-use-profiles"><a class="header" href="#1-use-profiles">1. Use Profiles</a></h3>
<p>Separate configurations for different environments:</p>
<pre><code class="language-toml">[profiles.local]
server.debug = true

[profiles.staging]
server.host = "staging.company.com"

[profiles.production]
server.host = "0.0.0.0"
security.sandbox_mode = true
</code></pre>
<h3 id="2-secure-sensitive-data"><a class="header" href="#2-secure-sensitive-data">2. Secure Sensitive Data</a></h3>
<p>Never store secrets in configuration files:</p>
<pre><code class="language-toml"># Bad
api_key = "sk-1234567890abcdef"

# Good - use environment variables
api_key = "${API_KEY}"
</code></pre>
<h3 id="3-document-configuration"><a class="header" href="#3-document-configuration">3. Document Configuration</a></h3>
<p>Add comments explaining non-obvious settings:</p>
<pre><code class="language-toml"># Increase timeout for slow network environments
timeout = 60000  # 1 minute

# Disable caching during development to see changes immediately
[cache]
enabled = false  # TODO: Enable for production
</code></pre>
<h3 id="4-version-control"><a class="header" href="#4-version-control">4. Version Control</a></h3>
<p>Track configuration changes:</p>
<pre><code class="language-bash"># .gitignore
config.local.toml
config.production.toml

# Track example configuration
config.example.toml
</code></pre>
<h3 id="5-validate-changes"><a class="header" href="#5-validate-changes">5. Validate Changes</a></h3>
<p>Always validate configuration changes:</p>
<pre><code class="language-bash"># Before deploying
swissarmyhammer config validate --file new-config.toml

# Test with dry run
swissarmyhammer serve --config new-config.toml --dry-run
</code></pre>
<h2 id="troubleshooting-7"><a class="header" href="#troubleshooting-7">Troubleshooting</a></h2>
<h3 id="configuration-not-loading"><a class="header" href="#configuration-not-loading">Configuration Not Loading</a></h3>
<ol>
<li>Check file exists and is readable</li>
<li>Validate TOML syntax</li>
<li>Check environment variable names</li>
<li>Review precedence order</li>
</ol>
<h3 id="performance-issues-3"><a class="header" href="#performance-issues-3">Performance Issues</a></h3>
<ol>
<li>Disable file watching in production</li>
<li>Tune cache settings</li>
<li>Adjust worker counts</li>
<li>Enable performance monitoring</li>
</ol>
<h3 id="security-warnings"><a class="header" href="#security-warnings">Security Warnings</a></h3>
<ol>
<li>Review security settings</li>
<li>Enable sandbox mode</li>
<li>Restrict file and network access</li>
<li>Update allowed domains</li>
</ol>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li>See <a href="./cli-reference.html">CLI Reference</a> for command-line options</li>
<li>Learn about <a href="./file-watching.html">File Watching</a> configuration</li>
<li>Explore <a href="./troubleshooting.html">Troubleshooting</a> for common issues</li>
<li>Read <a href="./security.html">Security</a> for security best practices</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-watching-3"><a class="header" href="#file-watching-3">File Watching</a></h1>
<p>SwissArmyHammer includes a powerful file watching system that automatically detects and reloads prompt changes without restarting the server.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>The file watcher monitors your prompt directories for changes and automatically:</p>
<ol>
<li><strong>Detects</strong> new, modified, or deleted prompt files</li>
<li><strong>Validates</strong> changed files for syntax errors</li>
<li><strong>Reloads</strong> prompts into memory</li>
<li><strong>Notifies</strong> connected clients of updates</li>
<li><strong>Maintains</strong> state during the reload process</li>
</ol>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ File System â”‚â”€â”€â”€â”€&gt;â”‚ File Watcher â”‚â”€â”€â”€â”€&gt;â”‚ Prompt Cache â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚                     â”‚
                            â–¼                     â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Validator   â”‚     â”‚ MCP Clients  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<h3 id="basic-settings"><a class="header" href="#basic-settings">Basic Settings</a></h3>
<p>Configure file watching in your <code>config.yaml</code>:</p>
<pre><code class="language-yaml">watch:
  # Enable/disable file watching
  enabled: true
  
  # Check interval in milliseconds
  interval: 1000
  
  # Debounce delay to batch rapid changes
  debounce: 500
  
  # Maximum files to process per cycle
  batch_size: 100
</code></pre>
<h3 id="advanced-options"><a class="header" href="#advanced-options">Advanced Options</a></h3>
<pre><code class="language-yaml">watch:
  # File patterns to watch
  patterns:
    - "**/*.md"
    - "**/*.markdown"
    - "**/prompts.yaml"
  
  # Patterns to ignore
  ignore:
    - "**/node_modules/**"
    - "**/.git/**"
    - "**/target/**"
    - "**/*.swp"
    - "**/*~"
    - "**/.DS_Store"
  
  # Watch strategy
  strategy: efficient  # efficient, aggressive, polling
  
  # Platform-specific settings
  platform:
    # macOS FSEvents
    macos:
      use_fsevents: true
      latency: 0.1
    
    # Linux inotify
    linux:
      use_inotify: true
      max_watches: 8192
    
    # Windows
    windows:
      use_polling: false
      poll_interval: 1000
</code></pre>
<h2 id="watch-strategies"><a class="header" href="#watch-strategies">Watch Strategies</a></h2>
<h3 id="efficient-default"><a class="header" href="#efficient-default">Efficient (Default)</a></h3>
<p>Best for most use cases:</p>
<pre><code class="language-yaml">watch:
  strategy: efficient
  # Uses native OS file watching APIs
  # Low CPU usage
  # May have slight delay on some systems
</code></pre>
<h3 id="aggressive"><a class="header" href="#aggressive">Aggressive</a></h3>
<p>For development with frequent changes:</p>
<pre><code class="language-yaml">watch:
  strategy: aggressive
  interval: 100      # Check every 100ms
  debounce: 50       # Minimal debounce
  # Higher CPU usage
  # Near-instant updates
</code></pre>
<h3 id="polling"><a class="header" href="#polling">Polling</a></h3>
<p>Fallback for compatibility:</p>
<pre><code class="language-yaml">watch:
  strategy: polling
  interval: 2000     # Poll every 2 seconds
  # Works everywhere
  # Higher CPU usage
  # Slower updates
</code></pre>
<h2 id="file-events"><a class="header" href="#file-events">File Events</a></h2>
<h3 id="supported-events"><a class="header" href="#supported-events">Supported Events</a></h3>
<p>The watcher handles these file system events:</p>
<ol>
<li><strong>Created</strong> - New prompt files added</li>
<li><strong>Modified</strong> - Existing files changed</li>
<li><strong>Deleted</strong> - Files removed</li>
<li><strong>Renamed</strong> - Files moved or renamed</li>
<li><strong>Metadata</strong> - Permission or timestamp changes</li>
</ol>
<h3 id="event-processing"><a class="header" href="#event-processing">Event Processing</a></h3>
<pre><code class="language-yaml"># Event processing configuration
watch:
  events:
    # Process creation events
    create:
      enabled: true
      validate: true
      
    # Process modification events
    modify:
      enabled: true
      validate: true
      reload_delay: 100  # ms
      
    # Process deletion events
    delete:
      enabled: true
      cleanup_cache: true
      
    # Process rename events
    rename:
      enabled: true
      track_moves: true
</code></pre>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<h3 id="automatic-validation"><a class="header" href="#automatic-validation">Automatic Validation</a></h3>
<p>Files are validated before reload:</p>
<pre><code class="language-yaml">watch:
  validation:
    # Enable validation
    enabled: true
    
    # Validation rules
    rules:
      # Check YAML front matter
      yaml_syntax: true
      
      # Validate required fields
      required_fields:
        - name
        - title
        - description
      
      # Check template syntax
      template_syntax: true
      
      # Maximum file size
      max_size: 1MB
    
    # What to do on validation failure
    on_failure: warn  # warn, ignore, stop
</code></pre>
<h3 id="validation-errors"><a class="header" href="#validation-errors">Validation Errors</a></h3>
<p>When validation fails:</p>
<pre><code>[WARN] Validation failed for prompts/invalid.md:
  - Line 5: Invalid YAML syntax
  - Missing required field: 'title'
  - Template error: Unclosed tag '{% if'
  
File will not be loaded. Fix errors and save again.
</code></pre>
<h2 id="performance-2"><a class="header" href="#performance-2">Performance</a></h2>
<h3 id="optimization-tips"><a class="header" href="#optimization-tips">Optimization Tips</a></h3>
<ol>
<li>
<p><strong>Exclude unnecessary paths</strong>:</p>
<pre><code class="language-yaml">watch:
  ignore:
    - "**/backup/**"
    - "**/archive/**"
    - "**/*.log"
</code></pre>
</li>
<li>
<p><strong>Tune intervals for your workflow</strong>:</p>
<pre><code class="language-yaml"># For active development
watch:
  interval: 500
  debounce: 250

# For production
watch:
  interval: 5000
  debounce: 2000
</code></pre>
</li>
<li>
<p><strong>Limit watch scope</strong>:</p>
<pre><code class="language-yaml">watch:
  # Only watch specific directories
  directories:
    - ./prompts
    - ~/.swissarmyhammer/prompts
  # Don't watch subdirectories
  recursive: false
</code></pre>
</li>
</ol>
<h3 id="resource-usage"><a class="header" href="#resource-usage">Resource Usage</a></h3>
<p>Monitor watcher resource usage:</p>
<pre><code class="language-bash"># Check watcher status
swissarmyhammer doctor --watch

# Show watcher statistics
swissarmyhammer status --verbose

# Output:
File Watcher Status:
  Strategy: efficient
  Files watched: 156
  Directories: 12
  CPU usage: 0.1%
  Memory: 2.4MB
  Events processed: 1,234
  Last reload: 2 minutes ago
</code></pre>
<h2 id="debugging-1"><a class="header" href="#debugging-1">Debugging</a></h2>
<h3 id="enable-debug-logging-1"><a class="header" href="#enable-debug-logging-1">Enable Debug Logging</a></h3>
<pre><code class="language-yaml">logging:
  modules:
    swissarmyhammer::watcher: debug
</code></pre>
<h3 id="common-issues-2"><a class="header" href="#common-issues-2">Common Issues</a></h3>
<ol>
<li>
<p><strong>Changes not detected</strong>:</p>
<pre><code class="language-bash"># Check if watching is enabled
swissarmyhammer config get watch.enabled

# Test file watching
swissarmyhammer test --watch
</code></pre>
</li>
<li>
<p><strong>High CPU usage</strong>:</p>
<pre><code class="language-yaml"># Increase intervals
watch:
  interval: 2000
  debounce: 1000

# Use efficient strategy
watch:
  strategy: efficient
</code></pre>
</li>
<li>
<p><strong>Too many open files</strong>:</p>
<pre><code class="language-bash"># Linux: Increase inotify watches
echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf
sudo sysctl -p

# macOS: Usually not an issue with FSEvents

# Windows: Use polling fallback
</code></pre>
</li>
</ol>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>Uses FSEvents for efficient watching:</p>
<pre><code class="language-yaml">watch:
  platform:
    macos:
      use_fsevents: true
      # FSEvents latency in seconds
      latency: 0.1
      # Ignore events older than
      ignore_older_than: 10  # seconds
</code></pre>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Uses inotify with automatic limits:</p>
<pre><code class="language-yaml">watch:
  platform:
    linux:
      use_inotify: true
      # Will warn if approaching limits
      warn_threshold: 0.8
      # Fallback to polling if needed
      auto_fallback: true
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Uses ReadDirectoryChangesW:</p>
<pre><code class="language-yaml">watch:
  platform:
    windows:
      # Buffer size for changes
      buffer_size: 65536
      # Watch subtree
      watch_subtree: true
      # Notification filters
      filters:
        - file_name
        - last_write
        - size
</code></pre>
<h2 id="integration"><a class="header" href="#integration">Integration</a></h2>
<h3 id="client-notifications"><a class="header" href="#client-notifications">Client Notifications</a></h3>
<p>Clients are notified of changes:</p>
<pre><code class="language-javascript">// MCP client receives notification
client.on('prompt.changed', (event) =&gt; {
  console.log(`Prompt ${event.name} was ${event.type}`);
  // Refresh UI, clear caches, etc.
});
</code></pre>
<h3 id="hooks"><a class="header" href="#hooks">Hooks</a></h3>
<p>Run commands on file changes:</p>
<pre><code class="language-yaml">watch:
  hooks:
    # Before processing changes
    pre_reload:
      - echo "Reloading prompts..."
    
    # After successful reload
    post_reload:
      - ./scripts/notify-team.sh
      - ./scripts/update-index.sh
    
    # On reload failure
    on_error:
      - ./scripts/alert-admin.sh
</code></pre>
<h3 id="api-access"><a class="header" href="#api-access">API Access</a></h3>
<p>Query watcher status via API:</p>
<pre><code class="language-bash"># Get watcher status
curl http://localhost:3333/api/watcher/status

# Get recent events
curl http://localhost:3333/api/watcher/events

# Trigger manual reload
curl -X POST http://localhost:3333/api/watcher/reload
</code></pre>
<h2 id="best-practices-15"><a class="header" href="#best-practices-15">Best Practices</a></h2>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<ol>
<li><strong>Use aggressive watching</strong> for immediate feedback</li>
<li><strong>Enable validation</strong> to catch errors early</li>
<li><strong>Watch only active directories</strong> to reduce overhead</li>
<li><strong>Use debug logging</strong> to troubleshoot issues</li>
</ol>
<h3 id="production"><a class="header" href="#production">Production</a></h3>
<ol>
<li><strong>Use efficient strategy</strong> for lower resource usage</li>
<li><strong>Increase intervals</strong> to reduce CPU load</li>
<li><strong>Disable watching</strong> if prompts rarely change</li>
<li><strong>Monitor resource usage</strong> regularly</li>
</ol>
<h3 id="large-projects"><a class="header" href="#large-projects">Large Projects</a></h3>
<ol>
<li><strong>Exclude build directories</strong> and dependencies</li>
<li><strong>Use specific patterns</strong> instead of wildcards</li>
<li><strong>Consider splitting</strong> prompts across multiple directories</li>
<li><strong>Implement caching</strong> to reduce reload impact</li>
</ol>
<h2 id="manual-control"><a class="header" href="#manual-control">Manual Control</a></h2>
<h3 id="cli-commands"><a class="header" href="#cli-commands">CLI Commands</a></h3>
<p>Control file watching manually:</p>
<pre><code class="language-bash"># Pause file watching
swissarmyhammer watch pause

# Resume file watching
swissarmyhammer watch resume

# Force reload all prompts
swissarmyhammer watch reload

# Show watch status
swissarmyhammer watch status
</code></pre>
<h3 id="environment-variables-6"><a class="header" href="#environment-variables-6">Environment Variables</a></h3>
<p>Override watch settings:</p>
<pre><code class="language-bash"># Disable watching
export SWISSARMYHAMMER_WATCH_ENABLED=false

# Change interval
export SWISSARMYHAMMER_WATCH_INTERVAL=5000

# Force polling strategy
export SWISSARMYHAMMER_WATCH_STRATEGY=polling
</code></pre>
<h2 id="troubleshooting-8"><a class="header" href="#troubleshooting-8">Troubleshooting</a></h2>
<h3 id="diagnostic-commands"><a class="header" href="#diagnostic-commands">Diagnostic Commands</a></h3>
<pre><code class="language-bash"># Run watcher diagnostics
swissarmyhammer doctor --watch

# Test file detection
echo "test" &gt;&gt; prompts/test.md
swissarmyhammer watch test

# Monitor events in real-time
swissarmyhammer watch monitor
</code></pre>
<h3 id="common-solutions"><a class="header" href="#common-solutions">Common Solutions</a></h3>
<ol>
<li><strong>Linux: Increase inotify limits</strong></li>
<li><strong>macOS: Grant full disk access</strong></li>
<li><strong>Windows: Run as administrator</strong></li>
<li><strong>All: Check file permissions</strong></li>
<li><strong>All: Verify ignore patterns</strong></li>
</ol>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<ul>
<li>Configure watching in <a href="./configuration.html">Configuration</a></li>
<li>Learn about <a href="./prompt-organization.html">Prompt Organization</a></li>
<li>Understand <a href="./prompt-overrides.html">Prompt Overrides</a></li>
<li>Read <a href="./troubleshooting.html">Troubleshooting</a> for more help</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prompt-overrides"><a class="header" href="#prompt-overrides">Prompt Overrides</a></h1>
<p>SwissArmyHammer supports a hierarchical override system that allows you to customize prompts at different levels without modifying the original files.</p>
<h2 id="override-hierarchy"><a class="header" href="#override-hierarchy">Override Hierarchy</a></h2>
<p>Prompts are loaded and merged in this order (later overrides earlier):</p>
<pre><code>1. Built-in prompts (system)
   â†“
2. User prompts (~/.swissarmyhammer/prompts)
   â†“
3. Project prompts (./.swissarmyhammer/prompts)
   â†“
4. Runtime overrides (CLI/API)
</code></pre>
<h2 id="how-overrides-work"><a class="header" href="#how-overrides-work">How Overrides Work</a></h2>
<h3 id="complete-override"><a class="header" href="#complete-override">Complete Override</a></h3>
<p>Replace an entire prompt by using the same name:</p>
<pre><code class="language-markdown">&lt;!-- Built-in: /usr/share/swissarmyhammer/prompts/code-review.md --&gt;
---
name: code-review
title: Code Review
description: Reviews code for issues
arguments:
  - name: code
    required: true
---
Please review this code.

&lt;!-- User override: ~/.swissarmyhammer/prompts/code-review.md --&gt;
---
name: code-review
title: Enhanced Code Review
description: Comprehensive code analysis with security focus
arguments:
  - name: code
    required: true
  - name: security_check
    required: false
    default: true
---
Perform a detailed security-focused code review.
</code></pre>
<h3 id="partial-override"><a class="header" href="#partial-override">Partial Override</a></h3>
<p>Override specific fields while inheriting others:</p>
<pre><code class="language-yaml"># ~/.swissarmyhammer/overrides/code-review.yaml
name: code-review
extends: true  # Inherit from lower level
title: "Code Review (Company Standards)"
# Only override specific arguments
arguments:
  merge: true  # Merge with parent arguments
  items:
    - name: style_guide
      default: "company-style-guide.md"
</code></pre>
<h2 id="override-methods"><a class="header" href="#override-methods">Override Methods</a></h2>
<h3 id="1-file-based-overrides"><a class="header" href="#1-file-based-overrides">1. File-Based Overrides</a></h3>
<p>Create a prompt file with the same name at a higher level:</p>
<pre><code># Original
/usr/share/swissarmyhammer/prompts/development/python-analyzer.md

# User override
~/.swissarmyhammer/prompts/development/python-analyzer.md

# Project override
./.swissarmyhammer/prompts/development/python-analyzer.md
</code></pre>
<h3 id="2-override-configuration"><a class="header" href="#2-override-configuration">2. Override Configuration</a></h3>
<p>Use override files to modify prompts without duplicating:</p>
<pre><code class="language-yaml"># ~/.swissarmyhammer/overrides.yaml
overrides:
  - name: code-review
    # Override just the description
    description: "Code review with company standards"
    
  - name: api-generator
    # Add new arguments
    arguments:
      append:
        - name: auth_type
          default: "oauth2"
    
  - name: test-writer
    # Modify template content
    template:
      prepend: |
        # Company Test Standards
        Follow these guidelines:
        - Use pytest exclusively
        - Include docstrings
        
      append: |
        
        ## Additional Requirements
        - Minimum 80% coverage
        - Include integration tests
</code></pre>
<h3 id="3-runtime-overrides"><a class="header" href="#3-runtime-overrides">3. Runtime Overrides</a></h3>
<p>Override prompts at runtime via CLI or API:</p>
<pre><code class="language-bash"># Override prompt arguments
swissarmyhammer test code-review \
  --override title="Security Review" \
  --override description="Focus on security vulnerabilities"

# Override template content
swissarmyhammer test api-docs \
  --template-override prepend="# CONFIDENTIAL\n\n" \
  --template-override append="\n\nÂ© 2024 Acme Corp"
</code></pre>
<h2 id="advanced-override-patterns"><a class="header" href="#advanced-override-patterns">Advanced Override Patterns</a></h2>
<h3 id="inheritance-chain"><a class="header" href="#inheritance-chain">Inheritance Chain</a></h3>
<p>Create a chain of inherited prompts:</p>
<pre><code class="language-yaml"># base-analyzer.yaml
name: base-analyzer
abstract: true  # Can't be used directly
title: Base Code Analyzer
arguments:
  - name: code
    required: true
  - name: language
    required: false

# python-analyzer.yaml
name: python-analyzer
extends: base-analyzer
title: Python Code Analyzer
arguments:
  merge: true
  items:
    - name: check_types
      default: true

# security-python-analyzer.yaml
name: security-python-analyzer
extends: python-analyzer
title: Security-Focused Python Analyzer
template:
  inherit: true
  prepend: |
    ## Security Analysis
    Focus on OWASP Top 10 vulnerabilities.
</code></pre>
<h3 id="conditional-overrides"><a class="header" href="#conditional-overrides">Conditional Overrides</a></h3>
<p>Apply overrides based on conditions:</p>
<pre><code class="language-yaml"># overrides.yaml
conditional_overrides:
  - condition:
      environment: production
    overrides:
      - name: all
        arguments:
          - name: verbose
            default: false
            
  - condition:
      user: qa-team
    overrides:
      - name: test-generator
        template:
          append: |
            Include edge case testing.
            
  - condition:
      project_type: web
    overrides:
      - name: security-scan
        arguments:
          - name: check_xss
            default: true
</code></pre>
<h3 id="template-merging"><a class="header" href="#template-merging">Template Merging</a></h3>
<p>Control how templates are merged:</p>
<pre><code class="language-yaml"># Override with template merging
name: api-docs
extends: true
template_merge:
  strategy: smart  # smart, prepend, append, replace
  sections:
    - match: "## Authentication"
      action: replace
      content: |
        ## Authentication
        Use OAuth 2.0 with PKCE flow.
    
    - match: "## Error Handling"
      action: append
      content: |
        
        ### Company Error Codes
        - 4001: Invalid API key
        - 4002: Rate limit exceeded
</code></pre>
<h2 id="project-specific-overrides"><a class="header" href="#project-specific-overrides">Project-Specific Overrides</a></h2>
<h3 id="directory-structure-4"><a class="header" href="#directory-structure-4">Directory Structure</a></h3>
<p>Organize project overrides:</p>
<pre><code>.swissarmyhammer/
â”œâ”€â”€ prompts/           # Complete prompt overrides
â”‚   â””â”€â”€ code-review.md
â”œâ”€â”€ overrides.yaml     # Partial overrides
â”œâ”€â”€ templates/         # Template snippets
â”‚   â”œâ”€â”€ header.md
â”‚   â””â”€â”€ footer.md
â””â”€â”€ config.yaml       # Override configuration
</code></pre>
<h3 id="override-configuration"><a class="header" href="#override-configuration">Override Configuration</a></h3>
<p>Configure override behavior:</p>
<pre><code class="language-yaml"># .swissarmyhammer/config.yaml
overrides:
  # Enable/disable overrides
  enabled: true
  
  # Override precedence
  precedence:
    - runtime      # Highest priority
    - project
    - user
    - system      # Lowest priority
  
  # Merge strategies
  merge:
    arguments: deep     # deep, shallow, replace
    template: smart     # smart, simple, replace
    metadata: shallow   # deep, shallow, replace
  
  # Validation
  validation:
    strict: true
    require_base: false
    allow_new_fields: true
</code></pre>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<h3 id="1-company-standards"><a class="header" href="#1-company-standards">1. Company Standards</a></h3>
<p>Enforce company-wide standards:</p>
<pre><code class="language-yaml"># ~/.swissarmyhammer/company-overrides.yaml
global_overrides:
  all_prompts:
    template:
      prepend: |
        # {{company}} Standards
        This output follows {{company}} guidelines.
        
    globals:
      company: "Acme Corp"
      support_email: "ai-support@acme.com"
</code></pre>
<h3 id="2-environment-specific"><a class="header" href="#2-environment-specific">2. Environment-Specific</a></h3>
<p>Different behavior per environment:</p>
<pre><code class="language-yaml"># Development overrides
development:
  overrides:
    - name: code-review
      arguments:
        - name: verbose
          default: true
        - name: include_suggestions
          default: true

# Production overrides
production:
  overrides:
    - name: code-review
      arguments:
        - name: verbose
          default: false
        - name: security_scan
          default: true
</code></pre>
<h3 id="3-team-customization"><a class="header" href="#3-team-customization">3. Team Customization</a></h3>
<p>Team-specific modifications:</p>
<pre><code class="language-yaml"># Frontend team overrides
team: frontend
overrides:
  - pattern: "*-component"
    template:
      prepend: |
        Use React 18+ features.
        Follow Material-UI guidelines.
        
  - name: test-writer
    arguments:
      - name: framework
        default: "jest"
      - name: include_snapshots
        default: true
</code></pre>
<h2 id="override-resolution"><a class="header" href="#override-resolution">Override Resolution</a></h2>
<h3 id="name-matching"><a class="header" href="#name-matching">Name Matching</a></h3>
<p>How prompts are matched for override:</p>
<ol>
<li><strong>Exact match</strong>: <code>code-review</code> matches <code>code-review</code></li>
<li><strong>Pattern match</strong>: <code>*-review</code> matches <code>code-review</code>, <code>security-review</code></li>
<li><strong>Category match</strong>: <code>category:development</code> matches all development prompts</li>
</ol>
<h3 id="conflict-resolution"><a class="header" href="#conflict-resolution">Conflict Resolution</a></h3>
<p>When multiple overrides apply:</p>
<pre><code class="language-yaml"># Resolution rules
conflict_resolution:
  # Strategy: first, last, merge, error
  strategy: merge
  
  # Priority (higher wins)
  priorities:
    exact_match: 100
    pattern_match: 50
    category_match: 10
    global: 1
</code></pre>
<h3 id="debugging-overrides"><a class="header" href="#debugging-overrides">Debugging Overrides</a></h3>
<p>See what overrides are applied:</p>
<pre><code class="language-bash"># Show override chain for a prompt
swissarmyhammer debug code-review --show-overrides

# Output:
Override chain for 'code-review':
1. System: /usr/share/swissarmyhammer/prompts/code-review.md
2. User: ~/.swissarmyhammer/prompts/code-review.md (extends)
3. Project: ./.swissarmyhammer/overrides.yaml (partial)
4. Runtime: --override title="Custom Review"

# Test with override preview
swissarmyhammer test code-review --preview-overrides
</code></pre>
<h2 id="best-practices-16"><a class="header" href="#best-practices-16">Best Practices</a></h2>
<h3 id="1-minimal-overrides"><a class="header" href="#1-minimal-overrides">1. Minimal Overrides</a></h3>
<p>Override only what needs to change:</p>
<pre><code class="language-yaml"># Good: Override specific fields
name: code-review
extends: true
description: "Code review with security focus"

# Avoid: Duplicating entire prompt
name: code-review
title: Code Review  # Unchanged
description: "Code review with security focus"  # Only this changed
arguments: [...]  # Duplicated
template: |       # Duplicated
  ...
</code></pre>
<h3 id="2-document-overrides"><a class="header" href="#2-document-overrides">2. Document Overrides</a></h3>
<p>Always document why overrides exist:</p>
<pre><code class="language-yaml"># overrides.yaml
overrides:
  - name: api-generator
    # OVERRIDE REASON: Company requires OAuth2 for all APIs
    # JIRA: SECURITY-123
    # Date: 2024-01-15
    arguments:
      - name: auth_type
        default: "oauth2"
        locked: true  # Prevent further overrides
</code></pre>
<h3 id="3-version-control"><a class="header" href="#3-version-control">3. Version Control</a></h3>
<p>Track override changes:</p>
<pre><code class="language-bash"># .swissarmyhammer/.gitignore
# Don't ignore override files
!overrides.yaml
!prompts/

# Track override history
git add .swissarmyhammer/overrides.yaml
git commit -m "Add security requirements to code-review prompt"
</code></pre>
<h3 id="4-testing-overrides"><a class="header" href="#4-testing-overrides">4. Testing Overrides</a></h3>
<p>Test overrides thoroughly:</p>
<pre><code class="language-bash"># Test override application
swissarmyhammer test code-review --test-overrides

# Compare with and without overrides
swissarmyhammer test code-review --no-overrides &gt; without.txt
swissarmyhammer test code-review &gt; with.txt
diff without.txt with.txt
</code></pre>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<h3 id="lock-overrides"><a class="header" href="#lock-overrides">Lock Overrides</a></h3>
<p>Prevent certain overrides:</p>
<pre><code class="language-yaml"># System prompt with locked fields
---
name: security-scan
locked_fields:
  - title
  - core_checks
no_override: false  # Can't be overridden at all
</code></pre>
<h3 id="validate-overrides"><a class="header" href="#validate-overrides">Validate Overrides</a></h3>
<p>Ensure overrides meet requirements:</p>
<pre><code class="language-yaml"># Override validation rules
validation:
  rules:
    - field: arguments
      required_items:
        - name: code
        - name: language
    
    - field: template
      must_contain:
        - "SECURITY WARNING"
        - "Confidential"
      
    - field: description
      min_length: 50
      pattern: ".*security.*"
</code></pre>
<h2 id="troubleshooting-9"><a class="header" href="#troubleshooting-9">Troubleshooting</a></h2>
<h3 id="common-issues-3"><a class="header" href="#common-issues-3">Common Issues</a></h3>
<ol>
<li>
<p><strong>Override not applying</strong>:</p>
<pre><code class="language-bash"># Check override precedence
swissarmyhammer config get overrides.precedence

# Verify file locations
swissarmyhammer debug --show-paths
</code></pre>
</li>
<li>
<p><strong>Merge conflicts</strong>:</p>
<pre><code class="language-bash"># Show merge details
swissarmyhammer debug code-review --trace-merge
</code></pre>
</li>
<li>
<p><strong>Validation errors</strong>:</p>
<pre><code class="language-bash"># Validate overrides
swissarmyhammer validate --overrides
</code></pre>
</li>
</ol>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<ul>
<li>Learn about <a href="./prompt-organization.html">Prompt Organization</a></li>
<li>Understand <a href="./configuration.html">Configuration</a> options</li>
<li>Read about <a href="./testing-guide.html">Testing</a> override scenarios</li>
<li>See <a href="./examples.html">Examples</a> of override patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-prompts"><a class="header" href="#built-in-prompts">Built-in Prompts</a></h1>
<p>SwissArmyHammer includes a comprehensive set of built-in prompts designed to assist with various development tasks. These prompts are organized by category and leverage Liquid templating for dynamic, customizable assistance.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>All built-in prompts:</p>
<ul>
<li>Support customizable arguments with sensible defaults</li>
<li>Use Liquid syntax for variable substitution and control flow</li>
<li>Are organized into logical categories for easy discovery</li>
<li>Follow a standardized YAML front matter format</li>
</ul>
<h2 id="categories"><a class="header" href="#categories">Categories</a></h2>
<h3 id="analysis-1"><a class="header" href="#analysis-1">Analysis</a></h3>
<h4 id="statistics-calculator"><a class="header" href="#statistics-calculator">statistics-calculator</a></h4>
<p>Calculate statistics on numeric data using math filters and array operations.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>numbers</code> (required) - Comma-separated list of numbers</li>
<li><code>precision</code> (default: â€œ2â€) - Decimal precision for calculations</li>
<li><code>show_outliers</code> (default: â€œtrueâ€) - Identify outliers in the dataset</li>
<li><code>percentiles</code> (default: â€œ25,50,75â€) - Calculate percentiles (comma-separated)</li>
<li><code>visualization</code> (default: â€œtrueâ€) - Show ASCII visualization</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test statistics-calculator --numbers "10,20,30,40,50" --percentiles "10,50,90"
</code></pre>
<h3 id="communication"><a class="header" href="#communication">Communication</a></h3>
<h4 id="email-composer"><a class="header" href="#email-composer">email-composer</a></h4>
<p>Compose professional emails with dynamic content using capture blocks.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>recipient_name</code> (required) - Name of the email recipient</li>
<li><code>sender_name</code> (required) - Name of the sender</li>
<li><code>email_type</code> (required) - Type of email (welcome, followup, reminder, thank_you)</li>
<li><code>context</code> (default: â€œâ€) - Additional context for the email</li>
<li><code>formal</code> (default: â€œfalseâ€) - Use formal tone</li>
<li><code>include_signature</code> (default: â€œtrueâ€) - Include email signature</li>
<li><code>time_of_day</code> (default: â€œmorningâ€) - Current time of day</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test email-composer --recipient_name "John Doe" --sender_name "Jane Smith" --email_type "followup" --formal "true"
</code></pre>
<h3 id="data-processing"><a class="header" href="#data-processing">Data Processing</a></h3>
<h4 id="array-processor"><a class="header" href="#array-processor">array-processor</a></h4>
<p>Process arrays with flexible filtering and loop control.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>items</code> (required) - Comma-separated list of items to process</li>
<li><code>skip_pattern</code> (default: â€œâ€) - Pattern to skip items containing this text</li>
<li><code>stop_pattern</code> (default: â€œâ€) - Pattern to stop processing</li>
<li><code>max_items</code> (default: â€œ100â€) - Maximum number of items to process</li>
<li><code>show_skipped</code> (default: â€œfalseâ€) - Show skipped items separately</li>
<li><code>format</code> (default: â€œlistâ€) - Output format (list, table, json)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test array-processor --items "apple,banana,cherry" --skip_pattern "berry" --format "table"
</code></pre>
<h3 id="debug"><a class="header" href="#debug">Debug</a></h3>
<h4 id="debugerror"><a class="header" href="#debugerror">debug/error</a></h4>
<p>Analyze error messages and provide debugging guidance with potential solutions.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>error_message</code> (required) - The error message or stack trace to analyze</li>
<li><code>language</code> (default: â€œauto-detectâ€) - The programming language</li>
<li><code>context</code> (default: â€œâ€) - Additional context about when the error occurs</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test debug/error --error_message "TypeError: cannot read property 'name' of undefined" --language "javascript"
</code></pre>
<h4 id="debuglogs"><a class="header" href="#debuglogs">debug/logs</a></h4>
<p>Analyze log files to identify issues and patterns.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>log_content</code> (required) - The log content to analyze</li>
<li><code>issue_description</code> (default: â€œgeneral analysisâ€) - Description of the issue youâ€™re investigating</li>
<li><code>time_range</code> (default: â€œallâ€) - Specific time range to focus on</li>
<li><code>log_format</code> (default: â€œauto-detectâ€) - Log format (json, plaintext, syslog, etc.)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test debug/logs --log_content "$(cat application.log)" --issue_description "API timeout errors"
</code></pre>
<h4 id="debugperformance"><a class="header" href="#debugperformance">debug/performance</a></h4>
<p>Analyze performance problems and suggest optimization strategies.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>problem_description</code> (required) - Description of the performance issue</li>
<li><code>metrics</code> (default: â€œnot providedâ€) - Performance metrics</li>
<li><code>code_snippet</code> (default: â€œâ€) - Relevant code that might be causing the issue</li>
<li><code>environment</code> (default: â€œdevelopmentâ€) - Environment details</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test debug/performance --problem_description "Database queries taking 5+ seconds" --environment "production"
</code></pre>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<h4 id="docsapi"><a class="header" href="#docsapi">docs/api</a></h4>
<p>Create comprehensive API documentation from code.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>code</code> (required) - The API code to document</li>
<li><code>api_type</code> (default: â€œRESTâ€) - Type of API (REST, GraphQL, gRPC, library)</li>
<li><code>format</code> (default: â€œmarkdownâ€) - Documentation format (markdown, openapi, swagger)</li>
<li><code>include_examples</code> (default: â€œtrueâ€) - Whether to include usage examples</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test docs/api --code "$(cat api.py)" --api_type "REST" --include_examples "true"
</code></pre>
<h4 id="docscomments"><a class="header" href="#docscomments">docs/comments</a></h4>
<p>Add comprehensive comments and documentation to code.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>code</code> (required) - The code to document</li>
<li><code>comment_style</code> (default: â€œauto-detectâ€) - Comment style (inline, block, jsdoc, docstring, rustdoc)</li>
<li><code>detail_level</code> (default: â€œstandardâ€) - Level of detail (minimal, standard, comprehensive)</li>
<li><code>audience</code> (default: â€œdevelopersâ€) - Target audience for the comments</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test docs/comments --code "$(cat utils.js)" --comment_style "jsdoc" --detail_level "comprehensive"
</code></pre>
<h4 id="docsreadme"><a class="header" href="#docsreadme">docs/readme</a></h4>
<p>Create comprehensive README documentation for a project.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>project_name</code> (required) - Name of the project</li>
<li><code>project_description</code> (required) - Brief description of what the project does</li>
<li><code>language</code> (default: â€œauto-detectâ€) - Primary programming language</li>
<li><code>features</code> (default: â€œâ€) - Key features of the project (comma-separated)</li>
<li><code>target_audience</code> (default: â€œdevelopersâ€) - Who this project is for</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test docs/readme --project_name "MyLib" --project_description "A library for awesome things" --features "fast,reliable,easy"
</code></pre>
<h3 id="formatting"><a class="header" href="#formatting">Formatting</a></h3>
<h4 id="table-generator"><a class="header" href="#table-generator">table-generator</a></h4>
<p>Generate formatted tables with alternating row styles.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>headers</code> (required) - Comma-separated list of table headers</li>
<li><code>rows</code> (required) - Semicolon-separated rows, with comma-separated values</li>
<li><code>style</code> (default: â€œmarkdownâ€) - Table style (markdown, html, ascii)</li>
<li><code>zebra</code> (default: â€œtrueâ€) - Enable zebra striping for rows</li>
<li><code>row_numbers</code> (default: â€œfalseâ€) - Add row numbers</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test table-generator --headers "Name,Age,City" --rows "John,30,NYC;Jane,25,LA" --style "markdown"
</code></pre>
<h3 id="planning--productivity"><a class="header" href="#planning--productivity">Planning &amp; Productivity</a></h3>
<h4 id="plan"><a class="header" href="#plan">plan</a></h4>
<p>Create structured plans and break down complex tasks.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>task</code> (required) - The task to plan for</li>
<li><code>context</code> (default: â€œâ€) - Additional context for the planning</li>
<li><code>constraints</code> (default: â€œnoneâ€) - Any constraints or limitations to consider</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test plan --task "Implement user authentication" --constraints "Must use OAuth2"
</code></pre>
<h4 id="task-formatter"><a class="header" href="#task-formatter">task-formatter</a></h4>
<p>Format and organize tasks with priorities and grouping.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>tasks</code> (required) - Comma-separated list of tasks</li>
<li><code>group_by</code> (default: â€œnoneâ€) - How to group tasks (priority, status, category, none)</li>
<li><code>show_index</code> (default: â€œtrueâ€) - Show task numbers</li>
<li><code>show_status</code> (default: â€œtrueâ€) - Include status checkboxes</li>
<li><code>date_format</code> (default: â€œ%B %d, %Yâ€) - Date format for due dates</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test task-formatter --tasks "Write tests,Fix bug,Update docs" --group_by "priority"
</code></pre>
<h3 id="prompt-management"><a class="header" href="#prompt-management">Prompt Management</a></h3>
<h4 id="promptscreate"><a class="header" href="#promptscreate">prompts/create</a></h4>
<p>Help create effective prompts for SwissArmyHammer.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>purpose</code> (required) - What the prompt should accomplish</li>
<li><code>category</code> (default: â€œgeneralâ€) - Category for the prompt</li>
<li><code>inputs_needed</code> (default: â€œâ€) - What information the prompt needs from users</li>
<li><code>complexity</code> (default: â€œmoderateâ€) - Complexity level (simple, moderate, advanced)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test prompts/create --purpose "Generate database migrations" --category "database"
</code></pre>
<h4 id="promptsimprove"><a class="header" href="#promptsimprove">prompts/improve</a></h4>
<p>Analyze and enhance existing prompts for better effectiveness.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>prompt_content</code> (required) - The current prompt content (including YAML front matter)</li>
<li><code>improvement_goals</code> (default: â€œoverall enhancementâ€) - What aspects to improve</li>
<li><code>user_feedback</code> (default: â€œâ€) - Any feedback or issues users have reported</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test prompts/improve --prompt_content "$(cat my-prompt.md)" --improvement_goals "clarity,flexibility"
</code></pre>
<h3 id="refactoring"><a class="header" href="#refactoring">Refactoring</a></h3>
<h4 id="refactorclean"><a class="header" href="#refactorclean">refactor/clean</a></h4>
<p>Refactor code for better readability, maintainability, and adherence to best practices.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>code</code> (required) - The code to refactor</li>
<li><code>language</code> (default: â€œauto-detectâ€) - Programming language</li>
<li><code>focus_areas</code> (default: â€œallâ€) - Specific areas to focus on</li>
<li><code>style_guide</code> (default: â€œlanguage defaultsâ€) - Specific style guide to follow</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test refactor/clean --code "$(cat messy_code.py)" --focus_areas "naming,complexity"
</code></pre>
<h4 id="refactorextract"><a class="header" href="#refactorextract">refactor/extract</a></h4>
<p>Extract code into well-named, reusable methods or functions.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>code</code> (required) - The code containing logic to extract</li>
<li><code>extract_purpose</code> (required) - What the extracted method should do</li>
<li><code>method_name</code> (default: â€œauto-suggestâ€) - Suggested name for the extracted method</li>
<li><code>scope</code> (default: â€œmethodâ€) - Scope for the extraction (method, function, class, module)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test refactor/extract --code "$(cat complex.js)" --extract_purpose "validate user input"
</code></pre>
<h4 id="refactorpatterns"><a class="header" href="#refactorpatterns">refactor/patterns</a></h4>
<p>Refactor code to match a target pattern or improve structure.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>code</code> (required) - The code to refactor</li>
<li><code>target_pattern</code> (required) - The pattern or style to refactor towards</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test refactor/patterns --code "$(cat service.py)" --target_pattern "Repository pattern"
</code></pre>
<h3 id="code-review"><a class="header" href="#code-review">Code Review</a></h3>
<h4 id="reviewcode"><a class="header" href="#reviewcode">review/code</a></h4>
<p>Review code for quality, bugs, and improvements.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>file_path</code> (required) - Path to the file being reviewed</li>
<li><code>context</code> (default: â€œgeneral reviewâ€) - Additional context about the code review focus</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test review/code --file_path "src/auth.py" --context "focus on security"
</code></pre>
<h4 id="reviewcode-dynamic"><a class="header" href="#reviewcode-dynamic">review/code-dynamic</a></h4>
<p>Language-specific code review with conditional logic.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>file_path</code> (required) - Path to the file being reviewed</li>
<li><code>language</code> (required) - Programming language (python, javascript, rust, etc.)</li>
<li><code>focus_areas</code> (default: â€œstyle,bugs,performanceâ€) - Comma-separated list of areas to focus on</li>
<li><code>severity_level</code> (default: â€œwarningâ€) - Minimum severity level to report (info, warning, error)</li>
<li><code>include_suggestions</code> (default: â€œtrueâ€) - Include code improvement suggestions</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test review/code-dynamic --file_path "app.js" --language "javascript" --focus_areas "security,performance"
</code></pre>
<h4 id="reviewsecurity"><a class="header" href="#reviewsecurity">review/security</a></h4>
<p>Perform a comprehensive security review of code to identify vulnerabilities.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>code</code> (required) - The code to review for security issues</li>
<li><code>context</code> (default: â€œgeneral purpose codeâ€) - Context about the code</li>
<li><code>language</code> (default: â€œauto-detectâ€) - Programming language</li>
<li><code>severity_threshold</code> (default: â€œlowâ€) - Minimum severity to report (critical, high, medium, low)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test review/security --code "$(cat login.php)" --context "handles user authentication"
</code></pre>
<h4 id="reviewaccessibility"><a class="header" href="#reviewaccessibility">review/accessibility</a></h4>
<p>Review code for accessibility compliance and best practices.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>code</code> (required) - The UI/frontend code to review</li>
<li><code>wcag_level</code> (default: â€œAAâ€) - WCAG compliance level target (A, AA, AAA)</li>
<li><code>component_type</code> (default: â€œgeneralâ€) - Type of component (form, navigation, content, interactive)</li>
<li><code>target_users</code> (default: â€œall usersâ€) - Specific user needs to consider</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test review/accessibility --code "$(cat form.html)" --component_type "form" --wcag_level "AA"
</code></pre>
<h3 id="testing-1"><a class="header" href="#testing-1">Testing</a></h3>
<h4 id="testunit"><a class="header" href="#testunit">test/unit</a></h4>
<p>Create comprehensive unit tests for code with good coverage.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>code</code> (required) - The code to generate tests for</li>
<li><code>framework</code> (default: â€œauto-detectâ€) - Testing framework to use</li>
<li><code>style</code> (default: â€œBDDâ€) - Testing style (BDD, TDD, classical)</li>
<li><code>coverage_target</code> (default: â€œ80â€) - Target test coverage percentage</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test test/unit --code "$(cat calculator.py)" --framework "pytest" --style "BDD"
</code></pre>
<h4 id="testintegration"><a class="header" href="#testintegration">test/integration</a></h4>
<p>Create integration tests to verify component interactions.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>system_description</code> (required) - Description of the system/components to test</li>
<li><code>test_scenarios</code> (default: â€œbasic flowâ€) - Specific scenarios to test (comma-separated)</li>
<li><code>framework</code> (default: â€œauto-detectâ€) - Testing framework to use</li>
<li><code>environment</code> (default: â€œlocalâ€) - Test environment setup requirements</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test test/integration --system_description "User service and database" --test_scenarios "user creation,user update"
</code></pre>
<h4 id="testproperty"><a class="header" href="#testproperty">test/property</a></h4>
<p>Create property-based tests to find edge cases automatically.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>code</code> (required) - The code to test with properties</li>
<li><code>framework</code> (default: â€œauto-detectâ€) - Property testing framework</li>
<li><code>properties_to_test</code> (default: â€œcommon propertiesâ€) - Specific properties or invariants to verify</li>
<li><code>num_examples</code> (default: â€œ100â€) - Number of random examples to generate</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test test/property --code "$(cat sort.js)" --properties_to_test "output length equals input length"
</code></pre>
<h3 id="general-purpose"><a class="header" href="#general-purpose">General Purpose</a></h3>
<h4 id="help"><a class="header" href="#help">help</a></h4>
<p>A prompt for providing helpful assistance and guidance to users.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>topic</code> (default: â€œgeneral assistanceâ€) - The topic to get help about</li>
<li><code>detail_level</code> (default: â€œnormalâ€) - How detailed the help should be</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test help --topic "git workflows" --detail_level "detailed"
</code></pre>
<h4 id="example-3"><a class="header" href="#example-3">example</a></h4>
<p>An example prompt for testing.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>topic</code> (default: â€œgeneral topicâ€) - The topic to ask about</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">swissarmyhammer test example --topic "testing prompts"
</code></pre>
<h2 id="usage-patterns"><a class="header" href="#usage-patterns">Usage Patterns</a></h2>
<h3 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h3>
<pre><code class="language-bash"># Use a prompt with default arguments
swissarmyhammer test review/code --file_path "main.py"

# Specify custom arguments
swissarmyhammer test test/unit --code "$(cat utils.js)" --framework "jest" --coverage_target "90"
</code></pre>
<h3 id="piping-content"><a class="header" href="#piping-content">Piping Content</a></h3>
<pre><code class="language-bash"># Pipe file content to a prompt
cat error.log | xargs -I {} swissarmyhammer test debug/logs --log_content "{}" --issue_description "memory leak"

# Use command substitution
swissarmyhammer test docs/api --code "$(cat api.py)" --api_type "REST"
</code></pre>
<h3 id="combining-multiple-prompts"><a class="header" href="#combining-multiple-prompts">Combining Multiple Prompts</a></h3>
<pre><code class="language-bash"># First analyze the code
swissarmyhammer test review/code --file_path "service.py" &gt; review.md

# Then generate tests based on the review
swissarmyhammer test test/unit --code "$(cat service.py)" --style "TDD"
</code></pre>
<h3 id="custom-workflows-1"><a class="header" href="#custom-workflows-1">Custom Workflows</a></h3>
<pre><code class="language-bash"># Create a security-focused workflow
swissarmyhammer test review/security --code "$(cat auth.js)" --severity_threshold "medium" &gt; security.md
swissarmyhammer test test/unit --code "$(cat auth.js)" --focus "security edge cases"
</code></pre>
<h2 id="best-practices-17"><a class="header" href="#best-practices-17">Best Practices</a></h2>
<ol>
<li><strong>Choose the Right Prompt</strong> - Select prompts that match your specific task</li>
<li><strong>Provide Context</strong> - Use optional arguments to give more context</li>
<li><strong>Combine Prompts</strong> - Use multiple prompts in sequence for comprehensive workflows</li>
<li><strong>Customize Arguments</strong> - Override defaults when you need specific behavior</li>
<li><strong>Review Output</strong> - Always review and validate generated content before using it</li>
</ol>
<h2 id="creating-custom-prompts"><a class="header" href="#creating-custom-prompts">Creating Custom Prompts</a></h2>
<p>If the built-in prompts donâ€™t meet your needs:</p>
<ol>
<li>Use the <code>prompts/create</code> prompt to generate a template</li>
<li>Save it in your <code>~/.swissarmyhammer/prompts/</code> directory</li>
<li>Follow the YAML front matter format for consistency</li>
<li>Test with various inputs to ensure reliability</li>
</ol>
<p>For more information on creating custom prompts, see <a href="./creating-prompts.html">Creating Prompts</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-filters-reference-1"><a class="header" href="#custom-filters-reference-1">Custom Filters Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-10"><a class="header" href="#examples-10">Examples</a></h1>
<p>This page provides real-world examples of using SwissArmyHammer for various development tasks.</p>
<h2 id="basic-prompt-usage"><a class="header" href="#basic-prompt-usage">Basic Prompt Usage</a></h2>
<h3 id="simple-code-review"><a class="header" href="#simple-code-review">Simple Code Review</a></h3>
<pre><code class="language-bash"># Review a Python file
swissarmyhammer test review/code --file_path "src/main.py"

# Review with specific focus
swissarmyhammer test review/code --file_path "api/auth.py" --context "focus on security and error handling"
</code></pre>
<h3 id="generate-unit-tests"><a class="header" href="#generate-unit-tests">Generate Unit Tests</a></h3>
<pre><code class="language-bash"># Generate tests for a function
swissarmyhammer test test/unit --code "$(cat calculator.py)" --framework "pytest"

# Generate tests with high coverage target
swissarmyhammer test test/unit --code "$(cat utils.js)" --framework "jest" --coverage_target "95"
</code></pre>
<h3 id="debug-an-error"><a class="header" href="#debug-an-error">Debug an Error</a></h3>
<pre><code class="language-bash"># Analyze an error message
swissarmyhammer test debug/error \
  --error_message "TypeError: Cannot read property 'name' of undefined" \
  --language "javascript" \
  --context "Happens when user submits form"
</code></pre>
<h2 id="creating-custom-prompts-1"><a class="header" href="#creating-custom-prompts-1">Creating Custom Prompts</a></h2>
<h3 id="basic-prompt-structure"><a class="header" href="#basic-prompt-structure">Basic Prompt Structure</a></h3>
<p>Create <code>~/.swissarmyhammer/prompts/my-prompt.md</code>:</p>
<pre><code class="language-markdown">---
name: git-commit-message
title: Git Commit Message Generator
description: Generate conventional commit messages from changes
arguments:
  - name: changes
    description: Description of changes made
    required: true
  - name: type
    description: Type of change (feat, fix, docs, etc.)
    required: false
    default: feat
  - name: scope
    description: Scope of the change
    required: false
    default: ""
---

# Git Commit Message

Based on the changes: {{changes}}

Generate a conventional commit message:

Type: {{type}}
{% if scope %}Scope: {{scope}}{% endif %}

Format: `{{type}}{% if scope %}({{scope}}){% endif %}: &lt;subject&gt;`

Subject should be:
- 50 characters or less
- Present tense
- No period at the end
- Clear and descriptive
</code></pre>
<p>Use it:</p>
<pre><code class="language-bash">swissarmyhammer test git-commit-message \
  --changes "Added user authentication with OAuth2" \
  --type "feat" \
  --scope "auth"
</code></pre>
<h3 id="advanced-template-with-conditionals"><a class="header" href="#advanced-template-with-conditionals">Advanced Template with Conditionals</a></h3>
<p>Create <code>~/.swissarmyhammer/prompts/database-query.md</code>:</p>
<pre><code class="language-markdown">---
name: database-query-optimizer
title: Database Query Optimizer
description: Optimize SQL queries for better performance
arguments:
  - name: query
    description: The SQL query to optimize
    required: true
  - name: database
    description: Database type (postgres, mysql, sqlite)
    required: false
    default: postgres
  - name: table_sizes
    description: Approximate table sizes (small, medium, large)
    required: false
    default: medium
  - name: indexes
    description: Available indexes (comma-separated)
    required: false
    default: ""
---

# SQL Query Optimization

## Original Query
```sql
{{query}}
</code></pre>
<h2 id="database-database--capitalize"><a class="header" href="#database-database--capitalize">Database: {{database | capitalize}}</a></h2>
<p>{% if database == â€œpostgresâ€ %}</p>
<h3 id="postgresql-specific-optimizations"><a class="header" href="#postgresql-specific-optimizations">PostgreSQL Specific Optimizations</a></h3>
<ul>
<li>Consider using EXPLAIN ANALYZE</li>
<li>Check for missing indexes on JOIN columns</li>
<li>Use CTEs for complex queries</li>
<li>Consider partial indexes for WHERE conditions
{% elsif database == â€œmysqlâ€ %}</li>
</ul>
<h3 id="mysql-specific-optimizations"><a class="header" href="#mysql-specific-optimizations">MySQL Specific Optimizations</a></h3>
<ul>
<li>Use EXPLAIN to check execution plan</li>
<li>Consider covering indexes</li>
<li>Optimize GROUP BY queries</li>
<li>Check buffer pool size
{% else %}</li>
</ul>
<h3 id="sqlite-specific-optimizations"><a class="header" href="#sqlite-specific-optimizations">SQLite Specific Optimizations</a></h3>
<ul>
<li>Use EXPLAIN QUERY PLAN</li>
<li>Consider table order in JOINs</li>
<li>Minimize use of LIKE with wildcards
{% endif %}</li>
</ul>
<h2 id="table-size-considerations"><a class="header" href="#table-size-considerations">Table Size Considerations</a></h2>
<p>{% case table_sizes %}
{% when â€œsmallâ€ %}</p>
<ul>
<li>Full table scans might be acceptable</li>
<li>Focus on query simplicity
{% when â€œlargeâ€ %}</li>
<li>Indexes are critical</li>
<li>Consider partitioning</li>
<li>Avoid SELECT *
{% else %}</li>
<li>Balance between indexes and write performance</li>
<li>Monitor query execution time
{% endcase %}</li>
</ul>
<p>{% if indexes %}</p>
<h2 id="available-indexes"><a class="header" href="#available-indexes">Available Indexes</a></h2>
<p>{% assign index_list = indexes | split: â€œ,â€ %}
{% for index in index_list %}</p>
<ul>
<li>{{ index | strip }}
{% endfor %}
{% endif %}</li>
</ul>
<p>Provide:</p>
<ol>
<li>Optimized query</li>
<li>Explanation of changes</li>
<li>Expected performance improvement</li>
<li>Additional index recommendations</li>
</ol>
<pre><code>
### Using Arrays and Loops

Create `~/.swissarmyhammer/prompts/api-client.md`:

```markdown
---
name: api-client-generator
title: API Client Generator
description: Generate API client code from endpoint specifications
arguments:
  - name: endpoints
    description: Comma-separated list of endpoints (method:path)
    required: true
  - name: base_url
    description: Base URL for the API
    required: true
  - name: language
    description: Target language for the client
    required: false
    default: javascript
  - name: auth_type
    description: Authentication type (none, bearer, basic, apikey)
    required: false
    default: none
---

# API Client Generator

Generate a {{language}} API client for:
- Base URL: {{base_url}}
- Authentication: {{auth_type}}

## Endpoints
{% assign endpoint_list = endpoints | split: "," %}
{% for endpoint in endpoint_list %}
  {% assign parts = endpoint | split: ":" %}
  {% assign method = parts[0] | strip | upcase %}
  {% assign path = parts[1] | strip %}
- {{method}} {{path}}
{% endfor %}

{% if language == "javascript" %}
Generate a modern JavaScript client using:
- Fetch API for requests
- Async/await syntax
- Proper error handling
- TypeScript interfaces if applicable
{% elsif language == "python" %}
Generate a Python client using:
- requests library
- Type hints
- Proper exception handling
- Docstrings for all methods
{% endif %}

{% if auth_type != "none" %}
Include authentication handling for {{auth_type}}:
{% case auth_type %}
{% when "bearer" %}
- Accept token in constructor
- Add Authorization: Bearer header
{% when "basic" %}
- Accept username/password
- Encode credentials properly
{% when "apikey" %}
- Accept API key
- Add to headers or query params as needed
{% endcase %}
{% endif %}

Include:
1. Complete client class
2. Error handling
3. Usage examples
4. Any necessary types/interfaces
</code></pre>
<h2 id="complex-workflows"><a class="header" href="#complex-workflows">Complex Workflows</a></h2>
<h3 id="multi-step-code-analysis"><a class="header" href="#multi-step-code-analysis">Multi-Step Code Analysis</a></h3>
<pre><code class="language-bash">#!/bin/bash
# analyze-codebase.sh

# Step 1: Get overview of the codebase
echo "=== Codebase Overview ==="
swissarmyhammer test help --topic "codebase structure" --detail_level "detailed" &gt; analysis/overview.md

# Step 2: Review critical files
echo "=== Security Review ==="
for file in auth.py payment.py user.py; do
  echo "Reviewing $file..."
  swissarmyhammer test review/security \
    --code "$(cat src/$file)" \
    --context "handles sensitive data" \
    --severity_threshold "medium" &gt; "analysis/security-$file.md"
done

# Step 3: Generate tests for uncovered code
echo "=== Test Generation ==="
swissarmyhammer test test/unit \
  --code "$(cat src/utils.py)" \
  --framework "pytest" \
  --style "BDD" \
  --coverage_target "90" &gt; tests/test_utils_generated.py

# Step 4: Create documentation
echo "=== Documentation ==="
swissarmyhammer test docs/api \
  --code "$(cat src/api.py)" \
  --api_type "REST" \
  --format "openapi" &gt; docs/api-spec.yaml

echo "Analysis complete! Check the analysis/ directory for results."
</code></pre>
<h3 id="automated-pr-review"><a class="header" href="#automated-pr-review">Automated PR Review</a></h3>
<pre><code class="language-bash">#!/bin/bash
# pr-review.sh

# Get changed files
CHANGED_FILES=$(git diff --name-only main...HEAD)

echo "# Pull Request Review" &gt; pr-review.md
echo "" &gt;&gt; pr-review.md

for file in $CHANGED_FILES; do
  if [[ $file == *.py ]] || [[ $file == *.js ]] || [[ $file == *.ts ]]; then
    echo "## Review: $file" &gt;&gt; pr-review.md
    
    # Dynamic code review
    swissarmyhammer test review/code-dynamic \
      --file_path "$file" \
      --language "${file##*.}" \
      --focus_areas "bugs,security,performance" \
      --severity_level "info" &gt;&gt; pr-review.md
    
    echo "" &gt;&gt; pr-review.md
  fi
done

# Check for accessibility issues in UI files
for file in $CHANGED_FILES; do
  if [[ $file == *.html ]] || [[ $file == *.jsx ]] || [[ $file == *.tsx ]]; then
    echo "## Accessibility: $file" &gt;&gt; pr-review.md
    swissarmyhammer test review/accessibility \
      --code "$(cat $file)" \
      --wcag_level "AA" &gt;&gt; pr-review.md
    echo "" &gt;&gt; pr-review.md
  fi
done

echo "Review complete! See pr-review.md"
</code></pre>
<h3 id="project-setup-automation"><a class="header" href="#project-setup-automation">Project Setup Automation</a></h3>
<pre><code class="language-bash">#!/bin/bash
# setup-project.sh

PROJECT_NAME=$1
PROJECT_TYPE=$2  # api, webapp, library

# Create project structure
mkdir -p $PROJECT_NAME/{src,tests,docs}
cd $PROJECT_NAME

# Generate README
swissarmyhammer test docs/readme \
  --project_name "$PROJECT_NAME" \
  --project_description "A $PROJECT_TYPE project" \
  --language "$PROJECT_TYPE" &gt; README.md

# Create initial prompts
mkdir -p prompts/project

# Generate project-specific code review prompt
cat &gt; prompts/project/code-review.md &lt;&lt; 'EOF'
---
name: project-code-review
title: Project Code Review
description: Review code according to our project standards
arguments:
  - name: file_path
    description: File to review
    required: true
---

Review {{file_path}} for:
- Our naming conventions (camelCase for JS, snake_case for Python)
- Error handling patterns we use
- Project-specific security requirements
- Performance considerations for our scale
EOF

# Configure SwissArmyHammer for this project
claude mcp add ${PROJECT_NAME}_sah swissarmyhammer serve --prompts ./prompts

echo "Project $PROJECT_NAME setup complete!"
</code></pre>
<h2 id="integration-examples-2"><a class="header" href="#integration-examples-2">Integration Examples</a></h2>
<h3 id="git-hooks"><a class="header" href="#git-hooks">Git Hooks</a></h3>
<p><code>.git/hooks/pre-commit</code>:</p>
<pre><code class="language-bash">#!/bin/bash
# Check code quality before commit

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(py|js|ts)$')

if [ -z "$STAGED_FILES" ]; then
  exit 0
fi

echo "Running pre-commit checks..."

for FILE in $STAGED_FILES; do
  # Run security review on staged content
  git show ":$FILE" | swissarmyhammer test review/security \
    --code "$(cat)" \
    --severity_threshold "high" \
    --language "${FILE##*.}"
  
  if [ $? -ne 0 ]; then
    echo "Security issues found in $FILE"
    exit 1
  fi
done

echo "Pre-commit checks passed!"
</code></pre>
<h3 id="cicd-integration"><a class="header" href="#cicd-integration">CI/CD Integration</a></h3>
<p><code>.github/workflows/code-quality.yml</code>:</p>
<pre><code class="language-yaml">name: Code Quality

on: [push, pull_request]

jobs:
  quality-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install SwissArmyHammer
        run: |
          curl -sSL https://raw.githubusercontent.com/wballard/swissarmyhammer/main/install.sh | bash
          echo "$HOME/.local/bin" &gt;&gt; $GITHUB_PATH
      
      - name: Run Code Reviews
        run: |
          for file in $(find src -name "*.py"); do
            swissarmyhammer test review/code-dynamic \
              --file_path "$file" \
              --language "python" \
              --focus_areas "bugs,security" \
              --severity_level "warning"
          done
      
      - name: Generate Missing Tests
        run: |
          swissarmyhammer test test/unit \
            --code "$(cat src/core.py)" \
            --framework "pytest" \
            --coverage_target "80" &gt; tests/test_core_generated.py
      
      - name: Update Documentation
        run: |
          swissarmyhammer test docs/api \
            --code "$(cat src/api.py)" \
            --api_type "REST" \
            --format "markdown" &gt; docs/api.md
</code></pre>
<h3 id="vs-code-task"><a class="header" href="#vs-code-task">VS Code Task</a></h3>
<p><code>.vscode/tasks.json</code>:</p>
<pre><code class="language-json">{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Review Current File",
      "type": "shell",
      "command": "swissarmyhammer",
      "args": [
        "test",
        "review/code",
        "--file_path",
        "${file}"
      ],
      "group": {
        "kind": "test",
        "isDefault": true
      },
      "presentation": {
        "reveal": "always",
        "panel": "new"
      }
    },
    {
      "label": "Generate Tests",
      "type": "shell",
      "command": "swissarmyhammer",
      "args": [
        "test",
        "test/unit",
        "--code",
        "$(cat ${file})",
        "--framework",
        "auto-detect"
      ],
      "group": "test"
    }
  ]
}
</code></pre>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="dynamic-prompt-selection"><a class="header" href="#dynamic-prompt-selection">Dynamic Prompt Selection</a></h3>
<pre><code class="language-bash">#!/bin/bash
# smart-review.sh

FILE=$1
EXTENSION="${FILE##*.}"

case $EXTENSION in
  py)
    PROMPT="review/code-dynamic"
    ARGS="--language python --focus_areas style,typing"
    ;;
  js|ts)
    PROMPT="review/code-dynamic"
    ARGS="--language javascript --focus_areas async,security"
    ;;
  html)
    PROMPT="review/accessibility"
    ARGS="--wcag_level AA"
    ;;
  sql)
    PROMPT="database-query-optimizer"
    ARGS="--database postgres"
    ;;
  *)
    PROMPT="review/code"
    ARGS=""
    ;;
esac

swissarmyhammer test $PROMPT --file_path "$FILE" $ARGS
</code></pre>
<h3 id="batch-processing-1"><a class="header" href="#batch-processing-1">Batch Processing</a></h3>
<pre><code class="language-python">#!/usr/bin/env python3
# batch_analyze.py

import subprocess
import json
import glob

def analyze_file(filepath):
    """Run SwissArmyHammer analysis on a file."""
    result = subprocess.run([
        'swissarmyhammer', 'test', 'review/code',
        '--file_path', filepath,
        '--context', 'batch analysis'
    ], capture_output=True, text=True)
    
    return {
        'file': filepath,
        'output': result.stdout,
        'errors': result.stderr
    }

# Analyze all Python files
files = glob.glob('**/*.py', recursive=True)
results = [analyze_file(f) for f in files]

# Save results
with open('analysis_results.json', 'w') as f:
    json.dump(results, f, indent=2)

print(f"Analyzed {len(files)} files. Results saved to analysis_results.json")
</code></pre>
<h3 id="custom-filter-integration"><a class="header" href="#custom-filter-integration">Custom Filter Integration</a></h3>
<p>Create a prompt that uses custom filters:</p>
<pre><code class="language-markdown">---
name: data-transformer
title: Data Transformation Pipeline
description: Transform data using custom filters
arguments:
  - name: data
    description: Input data (JSON or CSV)
    required: true
  - name: transformations
    description: Comma-separated list of transformations
    required: true
---

# Data Transformation

Input data:
</code></pre>
<p>{{data}}</p>
<pre><code>
Apply transformations: {{transformations}}

{% assign transform_list = transformations | split: "," %}
{% for transform in transform_list %}
  {% case transform | strip %}
  {% when "uppercase" %}
    - Convert all text fields to uppercase
  {% when "normalize" %}
    - Normalize whitespace and formatting
  {% when "validate" %}
    - Validate data types and constraints
  {% when "aggregate" %}
    - Aggregate numeric fields
  {% endcase %}
{% endfor %}

Provide:
1. Transformed data
2. Transformation log
3. Any validation errors
4. Summary statistics
</code></pre>
<h2 id="tips-and-best-practices"><a class="header" href="#tips-and-best-practices">Tips and Best Practices</a></h2>
<h3 id="1-use-command-substitution"><a class="header" href="#1-use-command-substitution">1. Use Command Substitution</a></h3>
<pre><code class="language-bash"># Good - passes file content directly
swissarmyhammer test review/code --code "$(cat main.py)"

# Less efficient - requires file path handling
swissarmyhammer test review/code --file_path main.py
</code></pre>
<h3 id="2-chain-commands"><a class="header" href="#2-chain-commands">2. Chain Commands</a></h3>
<pre><code class="language-bash"># Review then test
swissarmyhammer test review/code --file_path app.py &amp;&amp; \
swissarmyhammer test test/unit --code "$(cat app.py)"
</code></pre>
<h3 id="3-save-common-workflows"><a class="header" href="#3-save-common-workflows">3. Save Common Workflows</a></h3>
<p>Create <code>~/.swissarmyhammer/scripts/full-review.sh</code>:</p>
<pre><code class="language-bash">#!/bin/bash
FILE=$1
echo "=== Code Review ==="
swissarmyhammer test review/code --file_path "$FILE"

echo -e "\n=== Security Check ==="
swissarmyhammer test review/security --code "$(cat $FILE)"

echo -e "\n=== Test Generation ==="
swissarmyhammer test test/unit --code "$(cat $FILE)"
</code></pre>
<h3 id="4-use-environment-variables"><a class="header" href="#4-use-environment-variables">4. Use Environment Variables</a></h3>
<pre><code class="language-bash">export SAH_DEFAULT_LANGUAGE=python
export SAH_DEFAULT_FRAMEWORK=pytest

# Now these defaults apply
swissarmyhammer test test/unit --code "$(cat app.py)"
</code></pre>
<h3 id="5-create-project-templates"><a class="header" href="#5-create-project-templates">5. Create Project Templates</a></h3>
<p>Store in <code>~/.swissarmyhammer/templates/</code>:</p>
<pre><code class="language-bash"># Create new project with templates
cp -r ~/.swissarmyhammer/templates/webapp-template my-new-app
cd my-new-app
swissarmyhammer test docs/readme \
  --project_name "my-new-app" \
  --project_description "My awesome web app"
</code></pre>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<ul>
<li>Explore <a href="./builtin-prompts.html">Built-in Prompts</a> for more capabilities</li>
<li>Learn about <a href="./creating-prompts.html">Creating Prompts</a> for custom workflows</li>
<li>Check <a href="./cli-reference.html">CLI Reference</a> for all available commands</li>
<li>See <a href="./library-usage.html">Library Usage</a> for programmatic integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-10"><a class="header" href="#troubleshooting-10">Troubleshooting</a></h1>
<p>This guide helps you resolve common issues with SwissArmyHammer. For additional support, check the <a href="https://github.com/wballard/swissarmyhammer/issues">GitHub Issues</a>.</p>
<h2 id="quick-diagnostics"><a class="header" href="#quick-diagnostics">Quick Diagnostics</a></h2>
<p>Run the doctor command for automated diagnosis:</p>
<pre><code class="language-bash">swissarmyhammer doctor --verbose
</code></pre>
<h2 id="installation-issues-1"><a class="header" href="#installation-issues-1">Installation Issues</a></h2>
<h3 id="command-not-found"><a class="header" href="#command-not-found">Command Not Found</a></h3>
<p><strong>Problem</strong>: <code>swissarmyhammer: command not found</code></p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Verify installation</strong>:</p>
<pre><code class="language-bash">ls -la ~/.local/bin/swissarmyhammer
# or
ls -la /usr/local/bin/swissarmyhammer
</code></pre>
</li>
<li>
<p><strong>Add to PATH</strong>:</p>
<pre><code class="language-bash">echo 'export PATH="$HOME/.local/bin:$PATH"' &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
</li>
<li>
<p><strong>Reinstall</strong>:</p>
<pre><code class="language-bash">curl -sSL https://raw.githubusercontent.com/wballard/swissarmyhammer/main/install.sh | bash
</code></pre>
</li>
</ol>
<h3 id="permission-denied-1"><a class="header" href="#permission-denied-1">Permission Denied</a></h3>
<p><strong>Problem</strong>: <code>Permission denied</code> when running swissarmyhammer</p>
<p><strong>Solutions</strong>:</p>
<pre><code class="language-bash"># Make executable
chmod +x $(which swissarmyhammer)

# If installed system-wide, use sudo
sudo chmod +x /usr/local/bin/swissarmyhammer
</code></pre>
<h3 id="installation-script-fails"><a class="header" href="#installation-script-fails">Installation Script Fails</a></h3>
<p><strong>Problem</strong>: Install script errors or hangs</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Manual installation</strong>:</p>
<pre><code class="language-bash"># Download binary directly
curl -L https://github.com/wballard/swissarmyhammer/releases/latest/download/swissarmyhammer-linux-x64 -o swissarmyhammer
chmod +x swissarmyhammer
sudo mv swissarmyhammer /usr/local/bin/
</code></pre>
</li>
<li>
<p><strong>Build from source</strong>:</p>
<pre><code class="language-bash">git clone https://github.com/wballard/swissarmyhammer.git
cd swissarmyhammer
cargo build --release
sudo cp target/release/swissarmyhammer /usr/local/bin/
</code></pre>
</li>
</ol>
<h2 id="mcp-server-issues"><a class="header" href="#mcp-server-issues">MCP Server Issues</a></h2>
<h3 id="server-wont-start-2"><a class="header" href="#server-wont-start-2">Server Wonâ€™t Start</a></h3>
<p><strong>Problem</strong>: <code>swissarmyhammer serve</code> fails to start</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Check port availability</strong>:</p>
<pre><code class="language-bash"># Default port
lsof -i :8080

# Try different port
swissarmyhammer serve --port 8081
</code></pre>
</li>
<li>
<p><strong>Debug mode</strong>:</p>
<pre><code class="language-bash">swissarmyhammer serve --debug
</code></pre>
</li>
<li>
<p><strong>Check permissions</strong>:</p>
<pre><code class="language-bash"># Ensure read access to prompt directories
ls -la ~/.swissarmyhammer/prompts
</code></pre>
</li>
</ol>
<h3 id="claude-code-connection-issues"><a class="header" href="#claude-code-connection-issues">Claude Code Connection Issues</a></h3>
<p><strong>Problem</strong>: SwissArmyHammer doesnâ€™t appear in Claude Code</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Verify MCP configuration</strong>:</p>
<pre><code class="language-bash">claude mcp list
</code></pre>
</li>
<li>
<p><strong>Re-add server</strong>:</p>
<pre><code class="language-bash">claude mcp remove swissarmyhammer
claude mcp add swissarmyhammer swissarmyhammer serve
</code></pre>
</li>
<li>
<p><strong>Check server is running</strong>:</p>
<pre><code class="language-bash"># In another terminal
ps aux | grep swissarmyhammer
</code></pre>
</li>
<li>
<p><strong>Restart Claude Code</strong>:</p>
<ul>
<li>Close Claude Code completely</li>
<li>Start Claude Code</li>
<li>Check MCP servers are connected</li>
</ul>
</li>
</ol>
<h3 id="mcp-protocol-errors"><a class="header" href="#mcp-protocol-errors">MCP Protocol Errors</a></h3>
<p><strong>Problem</strong>: Protocol errors in Claude Code logs</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Update SwissArmyHammer</strong>:</p>
<pre><code class="language-bash"># Check version
swissarmyhammer --version

# Update to latest
curl -sSL https://install.sh | bash
</code></pre>
</li>
<li>
<p><strong>Check logs</strong>:</p>
<pre><code class="language-bash"># Enable debug logging
swissarmyhammer serve --debug &gt; debug.log 2&gt;&amp;1
</code></pre>
</li>
<li>
<p><strong>Validate prompt syntax</strong>:</p>
<pre><code class="language-bash">swissarmyhammer doctor --check prompts
</code></pre>
</li>
</ol>
<h2 id="prompt-issues-1"><a class="header" href="#prompt-issues-1">Prompt Issues</a></h2>
<h3 id="prompts-not-loading-2"><a class="header" href="#prompts-not-loading-2">Prompts Not Loading</a></h3>
<p><strong>Problem</strong>: Prompts donâ€™t appear or are outdated</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Check directories</strong>:</p>
<pre><code class="language-bash"># List prompt directories
ls -la ~/.swissarmyhammer/prompts
ls -la ./prompts
</code></pre>
</li>
<li>
<p><strong>Validate prompts</strong>:</p>
<pre><code class="language-bash">swissarmyhammer test &lt;prompt-name&gt;
swissarmyhammer doctor --check prompts --verbose
</code></pre>
</li>
<li>
<p><strong>Force reload</strong>:</p>
<pre><code class="language-bash"># Restart server
# Ctrl+C to stop, then:
swissarmyhammer serve
</code></pre>
</li>
</ol>
<h3 id="invalid-yaml-front-matter-1"><a class="header" href="#invalid-yaml-front-matter-1">Invalid YAML Front Matter</a></h3>
<p><strong>Problem</strong>: YAML parsing errors</p>
<p><strong>Common Issues</strong>:</p>
<ol>
<li>
<p><strong>Missing quotes</strong>:</p>
<pre><code class="language-yaml"># Bad
description: This won't work: because of the colon

# Good
description: "This works: because it's quoted"
</code></pre>
</li>
<li>
<p><strong>Incorrect indentation</strong>:</p>
<pre><code class="language-yaml"># Bad
arguments:
- name: test
description: Test argument

# Good
arguments:
  - name: test
    description: Test argument
</code></pre>
</li>
<li>
<p><strong>Missing required fields</strong>:</p>
<pre><code class="language-yaml"># Must have name, title, description
---
name: my-prompt
title: My Prompt
description: What this prompt does
---
</code></pre>
</li>
</ol>
<h3 id="template-rendering-errors"><a class="header" href="#template-rendering-errors">Template Rendering Errors</a></h3>
<p><strong>Problem</strong>: Liquid template errors</p>
<p><strong>Common Issues</strong>:</p>
<ol>
<li>
<p><strong>Undefined variables</strong>:</p>
<pre><code class="language-liquid"># Error: undefined variable 'foo'
{{ foo }}

# Fix: Check if variable exists
{% if foo %}{{ foo }}{% endif %}
</code></pre>
</li>
<li>
<p><strong>Invalid filter</strong>:</p>
<pre><code class="language-liquid"># Error: unknown filter
{{ text | invalid_filter }}

# Fix: Use valid filter
{{ text | capitalize }}
</code></pre>
</li>
<li>
<p><strong>Syntax errors</strong>:</p>
<pre><code class="language-liquid"># Error: unclosed tag
{% if condition %}

# Fix: Close all tags
{% if condition %}...{% endif %}
</code></pre>
</li>
</ol>
<h3 id="duplicate-prompt-names-1"><a class="header" href="#duplicate-prompt-names-1">Duplicate Prompt Names</a></h3>
<p><strong>Problem</strong>: Multiple prompts with same name</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Check override hierarchy</strong>:</p>
<pre><code class="language-bash">swissarmyhammer list --verbose | grep "prompt-name"
</code></pre>
</li>
<li>
<p><strong>Rename conflicts</strong>:</p>
<ul>
<li>Local prompts override user prompts</li>
<li>User prompts override built-in prompts</li>
<li>Rename one to avoid confusion</li>
</ul>
</li>
</ol>
<h2 id="performance-issues-4"><a class="header" href="#performance-issues-4">Performance Issues</a></h2>
<h3 id="slow-prompt-loading-1"><a class="header" href="#slow-prompt-loading-1">Slow Prompt Loading</a></h3>
<p><strong>Problem</strong>: Server takes long to start or reload</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Disable file watching</strong>:</p>
<pre><code class="language-bash">swissarmyhammer serve --watch false
</code></pre>
</li>
<li>
<p><strong>Limit prompt directories</strong>:</p>
<pre><code class="language-bash">swissarmyhammer serve --prompts ./essential-prompts --builtin false
</code></pre>
</li>
<li>
<p><strong>Check directory size</strong>:</p>
<pre><code class="language-bash">find ~/.swissarmyhammer/prompts -type f | wc -l
</code></pre>
</li>
</ol>
<h3 id="high-memory-usage-1"><a class="header" href="#high-memory-usage-1">High Memory Usage</a></h3>
<p><strong>Problem</strong>: Excessive memory consumption</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Monitor usage</strong>:</p>
<pre><code class="language-bash">top | grep swissarmyhammer
</code></pre>
</li>
<li>
<p><strong>Optimize configuration</strong>:</p>
<pre><code class="language-bash"># Disable file watching
swissarmyhammer serve --watch false

# Reduce prompt count
# Move unused prompts to archive
</code></pre>
</li>
<li>
<p><strong>System limits</strong>:</p>
<pre><code class="language-bash"># Check ulimits
ulimit -a

# Increase if needed
ulimit -n 4096
</code></pre>
</li>
</ol>
<h2 id="file-system-issues"><a class="header" href="#file-system-issues">File System Issues</a></h2>
<h3 id="permission-errors"><a class="header" href="#permission-errors">Permission Errors</a></h3>
<p><strong>Problem</strong>: Cannot read/write prompt files</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Fix directory permissions</strong>:</p>
<pre><code class="language-bash">chmod -R 755 ~/.swissarmyhammer
chmod -R 644 ~/.swissarmyhammer/prompts/*.md
</code></pre>
</li>
<li>
<p><strong>Check ownership</strong>:</p>
<pre><code class="language-bash">ls -la ~/.swissarmyhammer/
# Fix if needed
chown -R $USER:$USER ~/.swissarmyhammer
</code></pre>
</li>
</ol>
<h3 id="file-watching-not-working"><a class="header" href="#file-watching-not-working">File Watching Not Working</a></h3>
<p><strong>Problem</strong>: Changes to prompts not detected</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Check file system support</strong>:</p>
<pre><code class="language-bash"># macOS
fs_usage | grep swissarmyhammer

# Linux
inotifywait -m ~/.swissarmyhammer/prompts
</code></pre>
</li>
<li>
<p><strong>Increase watch limits (Linux)</strong>:</p>
<pre><code class="language-bash">echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
</code></pre>
</li>
<li>
<p><strong>Manual reload</strong>:</p>
<ul>
<li>Restart the server</li>
<li>Or disable watching: <code>--watch false</code></li>
</ul>
</li>
</ol>
<h2 id="cli-command-issues"><a class="header" href="#cli-command-issues">CLI Command Issues</a></h2>
<h3 id="test-command-fails"><a class="header" href="#test-command-fails">Test Command Fails</a></h3>
<p><strong>Problem</strong>: <code>swissarmyhammer test</code> errors</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Check prompt exists</strong>:</p>
<pre><code class="language-bash">swissarmyhammer list | grep "prompt-name"
</code></pre>
</li>
<li>
<p><strong>Validate arguments</strong>:</p>
<pre><code class="language-bash"># Show required arguments
swissarmyhammer test prompt-name --help
</code></pre>
</li>
<li>
<p><strong>Debug mode</strong>:</p>
<pre><code class="language-bash">swissarmyhammer test prompt-name --debug
</code></pre>
</li>
</ol>
<h3 id="exportimport-errors"><a class="header" href="#exportimport-errors">Export/Import Errors</a></h3>
<p><strong>Problem</strong>: Cannot export or import prompts</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Check file permissions</strong>:</p>
<pre><code class="language-bash"># For export
touch test-export.tar.gz

# For import
ls -la import-file.tar.gz
</code></pre>
</li>
<li>
<p><strong>Validate archive</strong>:</p>
<pre><code class="language-bash">tar -tzf archive.tar.gz
</code></pre>
</li>
<li>
<p><strong>Manual export</strong>:</p>
<pre><code class="language-bash">tar -czf prompts.tar.gz -C ~/.swissarmyhammer prompts/
</code></pre>
</li>
</ol>
<h2 id="environment-specific-issues"><a class="header" href="#environment-specific-issues">Environment-Specific Issues</a></h2>
<h3 id="macos-issues"><a class="header" href="#macos-issues">macOS Issues</a></h3>
<p><strong>Problem</strong>: Security warnings or quarantine</p>
<p><strong>Solutions</strong>:</p>
<pre><code class="language-bash"># Remove quarantine attribute
xattr -d com.apple.quarantine /usr/local/bin/swissarmyhammer

# Allow in Security &amp; Privacy settings
# System Preferences &gt; Security &amp; Privacy &gt; General
</code></pre>
<h3 id="linux-issues"><a class="header" href="#linux-issues">Linux Issues</a></h3>
<p><strong>Problem</strong>: Library dependencies missing</p>
<p><strong>Solutions</strong>:</p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt-get update
sudo apt-get install libssl-dev

# Fedora
sudo dnf install openssl-devel

# Check dependencies
ldd $(which swissarmyhammer)
</code></pre>
<h3 id="windows-issues"><a class="header" href="#windows-issues">Windows Issues</a></h3>
<p><strong>Problem</strong>: Path or execution issues</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Use PowerShell as Administrator</strong></p>
</li>
<li>
<p><strong>Add to PATH</strong>:</p>
<pre><code class="language-powershell">$env:Path += ";C:\Program Files\swissarmyhammer"
[Environment]::SetEnvironmentVariable("Path", $env:Path, [EnvironmentVariableTarget]::User)
</code></pre>
</li>
<li>
<p><strong>Windows Defender</strong>:</p>
<ul>
<li>Add exclusion for swissarmyhammer.exe</li>
<li>Check Windows Security logs</li>
</ul>
</li>
</ol>
<h2 id="debug-techniques"><a class="header" href="#debug-techniques">Debug Techniques</a></h2>
<h3 id="enable-verbose-logging"><a class="header" href="#enable-verbose-logging">Enable Verbose Logging</a></h3>
<pre><code class="language-bash"># Server debug mode
swissarmyhammer serve --debug

# Redirect to file
swissarmyhammer serve --debug &gt; debug.log 2&gt;&amp;1

# CLI debug
RUST_LOG=debug swissarmyhammer test prompt-name
</code></pre>
<h3 id="check-configuration"><a class="header" href="#check-configuration">Check Configuration</a></h3>
<pre><code class="language-bash"># Run comprehensive checks
swissarmyhammer doctor --verbose

# Check specific areas
swissarmyhammer doctor --check prompts --check mcp

# Auto-fix issues
swissarmyhammer doctor --fix
</code></pre>
<h3 id="trace-mcp-communication"><a class="header" href="#trace-mcp-communication">Trace MCP Communication</a></h3>
<pre><code class="language-bash"># Save MCP messages
swissarmyhammer serve --debug | grep MCP &gt; mcp-trace.log

# Monitor in real-time
swissarmyhammer serve --debug | grep -E "(request|response)"
</code></pre>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<h3 id="documentation-1"><a class="header" href="#documentation-1">Documentation</a></h3>
<ul>
<li>Check this troubleshooting guide first</li>
<li>Read the <a href="./cli-reference.html">CLI Reference</a></li>
<li>Review <a href="./configuration.html">Configuration</a> options</li>
</ul>
<h3 id="community-support"><a class="header" href="#community-support">Community Support</a></h3>
<ul>
<li><a href="https://github.com/wballard/swissarmyhammer/issues">GitHub Issues</a></li>
<li><a href="https://github.com/wballard/swissarmyhammer/discussions">Discussions</a></li>
<li><a href="troubleshooting.html#">Discord/Slack Community</a> (if available)</li>
</ul>
<h3 id="reporting-issues"><a class="header" href="#reporting-issues">Reporting Issues</a></h3>
<p>When reporting issues, include:</p>
<ol>
<li>
<p><strong>System information</strong>:</p>
<pre><code class="language-bash">swissarmyhammer doctor --json &gt; diagnosis.json
</code></pre>
</li>
<li>
<p><strong>Steps to reproduce</strong></p>
</li>
<li>
<p><strong>Error messages and logs</strong></p>
</li>
<li>
<p><strong>Expected vs actual behavior</strong></p>
</li>
</ol>
<h3 id="debug-information-script"><a class="header" href="#debug-information-script">Debug Information Script</a></h3>
<p>Save this as <code>debug-info.sh</code>:</p>
<pre><code class="language-bash">#!/bin/bash
echo "=== SwissArmyHammer Debug Information ==="
echo "Date: $(date)"
echo "Version: $(swissarmyhammer --version)"
echo "OS: $(uname -a)"
echo ""
echo "=== Doctor Report ==="
swissarmyhammer doctor --verbose
echo ""
echo "=== Configuration ==="
cat ~/.swissarmyhammer/config.toml 2&gt;/dev/null || echo "No config file"
echo ""
echo "=== Prompt Directories ==="
ls -la ~/.swissarmyhammer/prompts 2&gt;/dev/null || echo "No user prompts"
ls -la ./prompts 2&gt;/dev/null || echo "No local prompts"
echo ""
echo "=== Process Check ==="
ps aux | grep swissarmyhammer | grep -v grep
</code></pre>
<p>Run and save output:</p>
<pre><code class="language-bash">bash debug-info.sh &gt; debug-info.txt
</code></pre>
<h2 id="common-error-messages"><a class="header" href="#common-error-messages">Common Error Messages</a></h2>
<h3 id="failed-to-bind-to-address"><a class="header" href="#failed-to-bind-to-address">â€œFailed to bind to addressâ€</a></h3>
<ul>
<li>Port already in use</li>
<li>Try: <code>--port 8081</code></li>
</ul>
<h3 id="permission-denied-2"><a class="header" href="#permission-denied-2">â€œPermission deniedâ€</a></h3>
<ul>
<li>File/directory permissions issue</li>
<li>Try: <code>chmod +x</code> or check ownership</li>
</ul>
<h3 id="yaml-parse-error"><a class="header" href="#yaml-parse-error">â€œYAML parse errorâ€</a></h3>
<ul>
<li>Invalid YAML syntax in prompt</li>
<li>Check indentation and special characters</li>
</ul>
<h3 id="template-compilation-failed"><a class="header" href="#template-compilation-failed">â€œTemplate compilation failedâ€</a></h3>
<ul>
<li>Liquid syntax error</li>
<li>Check tags are closed and filters exist</li>
</ul>
<h3 id="prompt-not-found"><a class="header" href="#prompt-not-found">â€œPrompt not foundâ€</a></h3>
<ul>
<li>Prompt name doesnâ€™t exist</li>
<li>Check: <code>swissarmyhammer list</code></li>
</ul>
<h3 id="connection-refused"><a class="header" href="#connection-refused">â€œConnection refusedâ€</a></h3>
<ul>
<li>MCP server not running</li>
<li>Start server: <code>swissarmyhammer serve</code></li>
</ul>
<h2 id="prevention-tips"><a class="header" href="#prevention-tips">Prevention Tips</a></h2>
<ol>
<li>
<p><strong>Regular maintenance</strong>:</p>
<pre><code class="language-bash"># Weekly health check
swissarmyhammer doctor

# Update regularly
swissarmyhammer --version
</code></pre>
</li>
<li>
<p><strong>Backup prompts</strong>:</p>
<pre><code class="language-bash"># Regular backups
swissarmyhammer export ~/.swissarmyhammer/backups/prompts-$(date +%Y%m%d).tar.gz
</code></pre>
</li>
<li>
<p><strong>Test changes</strong>:</p>
<pre><code class="language-bash"># Before committing
swissarmyhammer test new-prompt
swissarmyhammer doctor --check prompts
</code></pre>
</li>
<li>
<p><strong>Monitor logs</strong>:</p>
<pre><code class="language-bash"># Keep logs for debugging
swissarmyhammer serve --debug &gt; server.log 2&gt;&amp;1 &amp;
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h1>
<p>Thank you for your interest in contributing to SwissArmyHammer! This guide will help you get started with contributing to the project.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>SwissArmyHammer welcomes contributions in many forms:</p>
<ul>
<li><strong>Code contributions</strong> - Features, bug fixes, optimizations</li>
<li><strong>Prompt contributions</strong> - New built-in prompts</li>
<li><strong>Documentation</strong> - Improvements, examples, translations</li>
<li><strong>Bug reports</strong> - Issues and reproducible test cases</li>
<li><strong>Feature requests</strong> - Ideas and suggestions</li>
</ul>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ul>
<li>Rust 1.70+ (check with <code>rustc --version</code>)</li>
<li>Git</li>
<li>GitHub account</li>
<li>Basic familiarity with:
<ul>
<li>Rust programming</li>
<li>Model Context Protocol (MCP)</li>
<li>Liquid templating</li>
</ul>
</li>
</ul>
<h3 id="fork-and-clone"><a class="header" href="#fork-and-clone">Fork and Clone</a></h3>
<ol>
<li>
<p>Fork the repository on GitHub</p>
</li>
<li>
<p>Clone your fork:</p>
<pre><code class="language-bash">git clone https://github.com/YOUR_USERNAME/swissarmyhammer.git
cd swissarmyhammer
</code></pre>
</li>
<li>
<p>Add upstream remote:</p>
<pre><code class="language-bash">git remote add upstream https://github.com/wballard/swissarmyhammer.git
</code></pre>
</li>
</ol>
<h3 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h3>
<ol>
<li>
<p>Install Rust toolchain:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
</li>
<li>
<p>Install development tools:</p>
<pre><code class="language-bash"># Format checker
rustup component add rustfmt

# Linter
rustup component add clippy

# Documentation
cargo install mdbook
</code></pre>
</li>
<li>
<p>Build the project:</p>
<pre><code class="language-bash">cargo build
cargo test
</code></pre>
</li>
</ol>
<h2 id="development-workflow-1"><a class="header" href="#development-workflow-1">Development Workflow</a></h2>
<h3 id="branch-strategy"><a class="header" href="#branch-strategy">Branch Strategy</a></h3>
<ul>
<li><code>main</code> - Stable release branch</li>
<li><code>develop</code> - Development branch</li>
<li><code>feature/*</code> - Feature branches</li>
<li><code>fix/*</code> - Bug fix branches</li>
<li><code>docs/*</code> - Documentation branches</li>
</ul>
<h3 id="creating-a-feature-branch"><a class="header" href="#creating-a-feature-branch">Creating a Feature Branch</a></h3>
<pre><code class="language-bash"># Update your fork
git checkout main
git pull upstream main
git push origin main

# Create feature branch
git checkout -b feature/your-feature-name

# Or for fixes
git checkout -b fix/issue-description
</code></pre>
<h3 id="making-changes"><a class="header" href="#making-changes">Making Changes</a></h3>
<ol>
<li><strong>Write code</strong> following our style guide</li>
<li><strong>Add tests</strong> for new functionality</li>
<li><strong>Update documentation</strong> as needed</li>
<li><strong>Run checks</strong> before committing</li>
</ol>
<h3 id="running-checks"><a class="header" href="#running-checks">Running Checks</a></h3>
<pre><code class="language-bash"># Format code
cargo fmt

# Run linter
cargo clippy -- -D warnings

# Run tests
cargo test

# Build documentation
cargo doc --no-deps --open

# Check everything
./scripts/check-all.sh
</code></pre>
<h2 id="code-style-guide"><a class="header" href="#code-style-guide">Code Style Guide</a></h2>
<h3 id="rust-code"><a class="header" href="#rust-code">Rust Code</a></h3>
<p>Follow Rust standard style with these additions:</p>
<pre><code class="language-rust">// Good: Clear module organization
pub mod prompts;
pub mod template;
pub mod mcp;

use std::collections::HashMap;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};

// Good: Descriptive names
pub struct PromptManager {
    prompts: HashMap&lt;String, Prompt&gt;,
    directories: Vec&lt;PathBuf&gt;,
    watcher: Option&lt;FileWatcher&gt;,
}

// Good: Clear error handling
impl PromptManager {
    pub fn load_prompt(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {
        let content = std::fs::read_to_string(path)
            .with_context(|| format!("Failed to read prompt file: {}", path.display()))?;
        
        let prompt = Prompt::parse(&amp;content)
            .with_context(|| format!("Failed to parse prompt: {}", path.display()))?;
        
        self.prompts.insert(prompt.name.clone(), prompt);
        Ok(())
    }
}

// Good: Comprehensive tests
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_load_prompt() {
        let mut manager = PromptManager::new();
        let result = manager.load_prompt(Path::new("test.md"));
        assert!(result.is_ok());
    }
}</code></pre>
<h3 id="documentation-2"><a class="header" href="#documentation-2">Documentation</a></h3>
<ul>
<li>Use <code>///</code> for public API documentation</li>
<li>Include examples in doc comments</li>
<li>Keep comments concise and helpful</li>
</ul>
<pre><code class="language-rust">/// Manages a collection of prompts and provides MCP server functionality.
/// 
/// # Examples
/// 
/// ```
/// use swissarmyhammer::PromptManager;
/// 
/// let mut manager = PromptManager::new();
/// manager.load_prompts()?;
/// ```
pub struct PromptManager {
    // Implementation details...
}</code></pre>
<h3 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h3>
<p>Make errors helpful and actionable:</p>
<pre><code class="language-rust">// Good
bail!("Prompt '{}' not found in directories: {:?}", name, self.directories);

// Good with context
.with_context(|| format!("Failed to parse YAML front matter in {}", path.display()))?;

// Bad
bail!("Error");</code></pre>
<h2 id="contributing-prompts-1"><a class="header" href="#contributing-prompts-1">Contributing Prompts</a></h2>
<h3 id="built-in-prompt-guidelines"><a class="header" href="#built-in-prompt-guidelines">Built-in Prompt Guidelines</a></h3>
<ol>
<li><strong>Location</strong>: <code>src/prompts/builtin/</code></li>
<li><strong>Categories</strong>: Place in appropriate subdirectory</li>
<li><strong>Quality</strong>: Must be generally useful</li>
<li><strong>Testing</strong>: Include test cases</li>
</ol>
<h3 id="prompt-standards"><a class="header" href="#prompt-standards">Prompt Standards</a></h3>
<pre><code class="language-markdown">---
name: descriptive-name
title: Human Readable Title
description: |
  Clear description of what this prompt does.
  Include use cases and examples.
category: development
tags:
  - relevant
  - searchable
  - tags
author: your-email@example.com
version: 1.0.0
arguments:
  - name: required_arg
    description: What this argument is for
    required: true
  - name: optional_arg
    description: Optional parameter
    default: "default value"
---

# Prompt Title

Clear instructions using the arguments:
- {{required_arg}}
- {{optional_arg}}

## Section Headers

Organize the prompt logically...
</code></pre>
<h3 id="testing-prompts"><a class="header" href="#testing-prompts">Testing Prompts</a></h3>
<p>Add test file <code>src/prompts/builtin/tests/your-prompt.test.md</code>:</p>
<pre><code class="language-yaml">name: test-your-prompt
cases:
  - name: basic usage
    arguments:
      required_arg: "test value"
    expected_contains:
      - "test value"
      - "expected output"
    expected_not_contains:
      - "error"
      
  - name: edge case
    arguments:
      required_arg: ""
      optional_arg: "custom"
    expected_error: "required_arg cannot be empty"
</code></pre>
<h2 id="documentation-3"><a class="header" href="#documentation-3">Documentation</a></h2>
<h3 id="documentation-structure"><a class="header" href="#documentation-structure">Documentation Structure</a></h3>
<pre><code>doc/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ SUMMARY.md      # Table of contents
â”‚   â”œâ”€â”€ chapter-1.md    # Content files
â”‚   â””â”€â”€ images/         # Images and diagrams
â””â”€â”€ book.toml          # mdbook configuration
</code></pre>
<h3 id="writing-documentation"><a class="header" href="#writing-documentation">Writing Documentation</a></h3>
<ol>
<li><strong>Be clear and concise</strong></li>
<li><strong>Include examples</strong></li>
<li><strong>Use proper markdown</strong></li>
<li><strong>Test all code examples</strong></li>
</ol>
<h3 id="building-documentation"><a class="header" href="#building-documentation">Building Documentation</a></h3>
<pre><code class="language-bash">cd doc
mdbook build
mdbook serve  # Preview at http://localhost:3000
</code></pre>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<h3 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h3>
<pre><code>tests/
â”œâ”€â”€ integration/     # Integration tests
â”œâ”€â”€ fixtures/       # Test data
â””â”€â”€ common/        # Shared test utilities
</code></pre>
<h3 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h3>
<pre><code class="language-rust">#[test]
fn test_prompt_loading() {
    let temp_dir = tempdir().unwrap();
    let prompt_file = temp_dir.path().join("test.md");
    
    std::fs::write(&amp;prompt_file, r#"---
name: test-prompt
title: Test
---
Content"#).unwrap();
    
    let mut manager = PromptManager::new();
    manager.add_directory(temp_dir.path());
    manager.load_prompts().unwrap();
    
    assert!(manager.get_prompt("test-prompt").is_some());
}</code></pre>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<pre><code class="language-bash"># All tests
cargo test

# Specific test
cargo test test_prompt_loading

# With output
cargo test -- --nocapture

# Integration tests only
cargo test --test integration
</code></pre>
<h2 id="submitting-changes"><a class="header" href="#submitting-changes">Submitting Changes</a></h2>
<h3 id="commit-messages-1"><a class="header" href="#commit-messages-1">Commit Messages</a></h3>
<p>Follow <a href="https://www.conventionalcommits.org/">Conventional Commits</a>:</p>
<pre><code class="language-bash"># Features
git commit -m "feat: add prompt validation API"
git commit -m "feat(mcp): implement notification support"

# Bug fixes
git commit -m "fix: correct template escaping issue"
git commit -m "fix(watcher): handle symlink changes"

# Documentation
git commit -m "docs: add prompt writing guide"
git commit -m "docs(api): document PromptManager methods"

# Performance
git commit -m "perf: optimize prompt loading"
git commit -m "perf(cache): implement LRU cache"

# Refactoring
git commit -m "refactor: simplify error handling"
git commit -m "refactor(template): extract common logic"
</code></pre>
<h3 id="pull-request-process"><a class="header" href="#pull-request-process">Pull Request Process</a></h3>
<ol>
<li>
<p><strong>Update your branch</strong>:</p>
<pre><code class="language-bash">git fetch upstream
git rebase upstream/main
</code></pre>
</li>
<li>
<p><strong>Push to your fork</strong>:</p>
<pre><code class="language-bash">git push origin feature/your-feature-name
</code></pre>
</li>
<li>
<p><strong>Create pull request</strong>:</p>
<ul>
<li>Use clear, descriptive title</li>
<li>Reference any related issues</li>
<li>Describe what changes do</li>
<li>Include test results</li>
<li>Add screenshots if UI changes</li>
</ul>
</li>
</ol>
<h3 id="pr-template"><a class="header" href="#pr-template">PR Template</a></h3>
<pre><code class="language-markdown">## Description
Brief description of changes

## Related Issue
Fixes #123

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] Tests added/updated
- [ ] Breaking changes documented
</code></pre>
<h2 id="code-review-process"><a class="header" href="#code-review-process">Code Review Process</a></h2>
<h3 id="what-we-look-for"><a class="header" href="#what-we-look-for">What We Look For</a></h3>
<ol>
<li><strong>Correctness</strong> - Does it work as intended?</li>
<li><strong>Tests</strong> - Are changes adequately tested?</li>
<li><strong>Documentation</strong> - Is it documented?</li>
<li><strong>Style</strong> - Does it follow conventions?</li>
<li><strong>Performance</strong> - Any performance impacts?</li>
<li><strong>Security</strong> - Any security concerns?</li>
</ol>
<h3 id="review-timeline"><a class="header" href="#review-timeline">Review Timeline</a></h3>
<ul>
<li>Initial response: 2-3 days</li>
<li>Full review: Within a week</li>
<li>Follow-ups: As needed</li>
</ul>
<h3 id="addressing-feedback"><a class="header" href="#addressing-feedback">Addressing Feedback</a></h3>
<pre><code class="language-bash"># Make requested changes
git add -A
git commit -m "address review feedback"

# Or amend if small change
git commit --amend

# Force push to your branch
git push -f origin feature/your-feature-name
</code></pre>
<h2 id="release-process"><a class="header" href="#release-process">Release Process</a></h2>
<h3 id="version-numbering"><a class="header" href="#version-numbering">Version Numbering</a></h3>
<p>We use <a href="https://semver.org/">Semantic Versioning</a>:</p>
<ul>
<li>MAJOR: Breaking API changes</li>
<li>MINOR: New features, backward compatible</li>
<li>PATCH: Bug fixes, backward compatible</li>
</ul>
<h3 id="release-checklist"><a class="header" href="#release-checklist">Release Checklist</a></h3>
<ol>
<li>Update <code>Cargo.toml</code> version</li>
<li>Update <code>CHANGELOG.md</code></li>
<li>Run full test suite</li>
<li>Build and test binaries</li>
<li>Update documentation</li>
<li>Create release PR</li>
<li>Tag release after merge</li>
<li>Publish to crates.io</li>
</ol>
<h2 id="community-1"><a class="header" href="#community-1">Community</a></h2>
<h3 id="getting-help-2"><a class="header" href="#getting-help-2">Getting Help</a></h3>
<ul>
<li><strong>GitHub Issues</strong> - Bug reports and features</li>
<li><strong>Discussions</strong> - Questions and ideas</li>
<li><strong>Discord</strong> - Real-time chat (if available)</li>
</ul>
<h3 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h3>
<p>We follow the <a href="https://www.rust-lang.org/policies/code-of-conduct">Rust Code of Conduct</a>:</p>
<ul>
<li>Be respectful and inclusive</li>
<li>Welcome newcomers</li>
<li>Focus on whatâ€™s best for the community</li>
<li>Show empathy towards others</li>
</ul>
<h3 id="recognition"><a class="header" href="#recognition">Recognition</a></h3>
<p>Contributors are recognized in:</p>
<ul>
<li><code>CONTRIBUTORS.md</code> file</li>
<li>Release notes</li>
<li>Documentation credits</li>
</ul>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<h3 id="common-commands"><a class="header" href="#common-commands">Common Commands</a></h3>
<pre><code class="language-bash"># Development
cargo build                 # Build project
cargo test                  # Run tests
cargo fmt                   # Format code
cargo clippy                # Lint code
cargo doc                   # Build docs

# Documentation
cd doc &amp;&amp; mdbook serve      # Preview docs

# Prompts
cargo run -- list           # List prompts
cargo run -- doctor         # Validate prompts

# Release
cargo publish --dry-run     # Test publishing
</code></pre>
<h3 id="useful-resources"><a class="header" href="#useful-resources">Useful Resources</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/">Rust Book</a></li>
<li><a href="https://modelcontextprotocol.io/">MCP Specification</a></li>
<li><a href="https://shopify.github.io/liquid/">Liquid Documentation</a></li>
<li><a href="https://rust-lang.github.io/mdBook/">mdBook Documentation</a></li>
</ul>
<h2 id="thank-you"><a class="header" href="#thank-you">Thank You!</a></h2>
<p>Your contributions make SwissArmyHammer better for everyone. Whether itâ€™s fixing a typo, adding a feature, or improving documentation, every contribution is valued.</p>
<p>Happy contributing! ğŸš€</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-setup-1"><a class="header" href="#development-setup-1">Development Setup</a></h1>
<p>This guide covers setting up a development environment for working on SwissArmyHammer.</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<h3 id="required-tools"><a class="header" href="#required-tools">Required Tools</a></h3>
<ul>
<li><strong>Rust</strong> 1.70 or later</li>
<li><strong>Git</strong> 2.0 or later</li>
<li><strong>Cargo</strong> (comes with Rust)</li>
<li><strong>A code editor</strong> (VS Code recommended)</li>
</ul>
<h3 id="optional-tools"><a class="header" href="#optional-tools">Optional Tools</a></h3>
<ul>
<li><strong>Docker</strong> - For testing container builds</li>
<li><strong>mdBook</strong> - For documentation development</li>
<li><strong>Node.js</strong> - For web-based tooling</li>
<li><strong>Python</strong> - For utility scripts</li>
</ul>
<h2 id="environment-setup"><a class="header" href="#environment-setup">Environment Setup</a></h2>
<h3 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h3>
<pre><code class="language-bash"># Install Rust via rustup
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Follow the installation prompts, then:
source $HOME/.cargo/env

# Verify installation
rustc --version
cargo --version
</code></pre>
<h3 id="setting-up-the-repository"><a class="header" href="#setting-up-the-repository">Setting Up the Repository</a></h3>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/wballard/swissarmyhammer.git
cd swissarmyhammer

# Install development dependencies
cargo install cargo-watch cargo-edit cargo-outdated

# Install formatting and linting tools
rustup component add rustfmt clippy

# Install documentation tools
cargo install mdbook mdbook-linkcheck mdbook-mermaid
</code></pre>
<h3 id="vs-code-setup"><a class="header" href="#vs-code-setup">VS Code Setup</a></h3>
<p>Install recommended extensions:</p>
<pre><code class="language-json">{
  "recommendations": [
    "rust-lang.rust-analyzer",
    "vadimcn.vscode-lldb",
    "serayuzgur.crates",
    "tamasfe.even-better-toml",
    "streetsidesoftware.code-spell-checker",
    "yzhang.markdown-all-in-one"
  ]
}
</code></pre>
<p>Settings for <code>.vscode/settings.json</code>:</p>
<pre><code class="language-json">{
  "editor.formatOnSave": true,
  "rust-analyzer.cargo.features": "all",
  "rust-analyzer.checkOnSave.command": "clippy",
  "rust-analyzer.inlayHints.enable": true,
  "rust-analyzer.inlayHints.typeHints.enable": true,
  "rust-analyzer.inlayHints.parameterHints.enable": true,
  "[rust]": {
    "editor.defaultFormatter": "rust-lang.rust-analyzer"
  }
}
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<pre><code>swissarmyhammer/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs           # CLI entry point
â”‚   â”œâ”€â”€ lib.rs            # Library entry point
â”‚   â”œâ”€â”€ cli/              # CLI commands
â”‚   â”œâ”€â”€ mcp/              # MCP server implementation
â”‚   â”œâ”€â”€ prompts/          # Prompt management
â”‚   â”œâ”€â”€ template/         # Template engine
â”‚   â””â”€â”€ utils/            # Utilities
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ integration/      # Integration tests
â”‚   â””â”€â”€ fixtures/         # Test data
â”œâ”€â”€ doc/
â”‚   â””â”€â”€ src/              # Documentation source
â”œâ”€â”€ examples/             # Example code
â”œâ”€â”€ benches/              # Benchmarks
â””â”€â”€ Cargo.toml           # Project manifest
</code></pre>
<h2 id="building-the-project"><a class="header" href="#building-the-project">Building the Project</a></h2>
<h3 id="development-build"><a class="header" href="#development-build">Development Build</a></h3>
<pre><code class="language-bash"># Quick build (debug mode)
cargo build

# Run tests
cargo test

# Run with debug output
RUST_LOG=debug cargo run -- serve

# Watch for changes and rebuild
cargo watch -x build
</code></pre>
<h3 id="release-build"><a class="header" href="#release-build">Release Build</a></h3>
<pre><code class="language-bash"># Optimized build
cargo build --release

# Run release binary
./target/release/swissarmyhammer --version

# Build with all features
cargo build --release --all-features
</code></pre>
<h3 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h3>
<pre><code class="language-bash"># Install cross-compilation tools
cargo install cross

# Build for different targets
cross build --target x86_64-pc-windows-gnu
cross build --target aarch64-apple-darwin
cross build --target x86_64-unknown-linux-musl
</code></pre>
<h2 id="development-workflow-2"><a class="header" href="#development-workflow-2">Development Workflow</a></h2>
<h3 id="running-tests-1"><a class="header" href="#running-tests-1">Running Tests</a></h3>
<pre><code class="language-bash"># All tests
cargo test

# Unit tests only
cargo test --lib

# Integration tests only
cargo test --test '*'

# Specific test
cargo test test_prompt_loading

# With output
cargo test -- --show-output

# With specific features
cargo test --features "experimental"
</code></pre>
<h3 id="code-quality"><a class="header" href="#code-quality">Code Quality</a></h3>
<pre><code class="language-bash"># Format code
cargo fmt

# Check formatting
cargo fmt -- --check

# Run linter
cargo clippy

# Strict linting
cargo clippy -- -D warnings

# Check for security issues
cargo audit

# Update dependencies
cargo update
cargo outdated
</code></pre>
<h3 id="documentation-4"><a class="header" href="#documentation-4">Documentation</a></h3>
<pre><code class="language-bash"># Build API documentation
cargo doc --no-deps --open

# Build user documentation
cd doc
mdbook build
mdbook serve

# Check documentation examples
cargo test --doc
</code></pre>
<h2 id="debugging-2"><a class="header" href="#debugging-2">Debugging</a></h2>
<h3 id="vs-code-debug-configuration"><a class="header" href="#vs-code-debug-configuration">VS Code Debug Configuration</a></h3>
<p><code>.vscode/launch.json</code>:</p>
<pre><code class="language-json">{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug CLI",
      "cargo": {
        "args": ["build", "--bin=swissarmyhammer"],
        "filter": {
          "name": "swissarmyhammer",
          "kind": "bin"
        }
      },
      "args": ["serve", "--debug"],
      "cwd": "${workspaceFolder}",
      "env": {
        "RUST_LOG": "debug",
        "RUST_BACKTRACE": "1"
      }
    },
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug Tests",
      "cargo": {
        "args": ["test", "--no-run"],
        "filter": {
          "name": "swissarmyhammer",
          "kind": "lib"
        }
      },
      "args": [],
      "cwd": "${workspaceFolder}"
    }
  ]
}
</code></pre>
<h3 id="command-line-debugging"><a class="header" href="#command-line-debugging">Command Line Debugging</a></h3>
<pre><code class="language-bash"># Enable debug logging
export RUST_LOG=swissarmyhammer=debug

# Enable backtrace
export RUST_BACKTRACE=1

# Run with debugging
cargo run -- serve --debug

# Use GDB
rust-gdb target/debug/swissarmyhammer

# Use LLDB
rust-lldb target/debug/swissarmyhammer
</code></pre>
<h3 id="logging-1"><a class="header" href="#logging-1">Logging</a></h3>
<p>Add debug logging to your code:</p>
<pre><code class="language-rust">use log::{debug, info, warn, error};

fn process_prompt(name: &amp;str) -&gt; Result&lt;()&gt; {
    debug!("Processing prompt: {}", name);
    
    if let Some(prompt) = self.get_prompt(name) {
        info!("Found prompt: {}", prompt.title);
        Ok(())
    } else {
        error!("Prompt not found: {}", name);
        Err(anyhow!("Prompt not found"))
    }
}</code></pre>
<h2 id="performance-profiling"><a class="header" href="#performance-profiling">Performance Profiling</a></h2>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<p>Create benchmarks in <code>benches/</code>:</p>
<pre><code class="language-rust">use criterion::{black_box, criterion_group, criterion_main, Criterion};
use swissarmyhammer::PromptManager;

fn bench_prompt_loading(c: &amp;mut Criterion) {
    c.bench_function("load 100 prompts", |b| {
        b.iter(|| {
            let manager = PromptManager::new();
            manager.load_prompts()
        });
    });
}

criterion_group!(benches, bench_prompt_loading);
criterion_main!(benches);</code></pre>
<p>Run benchmarks:</p>
<pre><code class="language-bash">cargo bench

# Compare benchmarks
cargo bench -- --save-baseline before
# Make changes
cargo bench -- --baseline before
</code></pre>
<h3 id="cpu-profiling"><a class="header" href="#cpu-profiling">CPU Profiling</a></h3>
<pre><code class="language-bash"># Install profiling tools
cargo install flamegraph

# Generate flamegraph
cargo flamegraph --bin swissarmyhammer -- serve

# Using perf (Linux)
perf record --call-graph=dwarf cargo run --release -- serve
perf report
</code></pre>
<h3 id="memory-profiling"><a class="header" href="#memory-profiling">Memory Profiling</a></h3>
<pre><code class="language-bash"># Install valgrind (Linux/macOS)
# macOS: brew install valgrind
# Linux: apt-get install valgrind

# Run with valgrind
valgrind --leak-check=full \
         --show-leak-kinds=all \
         target/debug/swissarmyhammer serve

# Use heaptrack (Linux)
heaptrack cargo run -- serve
heaptrack_gui heaptrack.*.gz
</code></pre>
<h2 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h2>
<h3 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h3>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_prompt_parsing() {
        let content = r#"---
name: test
title: Test Prompt
---
Content"#;
        
        let prompt = Prompt::parse(content).unwrap();
        assert_eq!(prompt.name, "test");
        assert_eq!(prompt.title, "Test Prompt");
    }
}</code></pre>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<p>In <code>tests/integration/</code>:</p>
<pre><code class="language-rust">use swissarmyhammer::PromptManager;
use tempfile::tempdir;

#[test]
fn test_full_workflow() {
    let temp_dir = tempdir().unwrap();
    
    // Create test prompts
    std::fs::write(
        temp_dir.path().join("test.md"),
        "---\nname: test\n---\nContent"
    ).unwrap();
    
    // Test loading
    let mut manager = PromptManager::new();
    manager.add_directory(temp_dir.path());
    manager.load_prompts().unwrap();
    
    // Test retrieval
    assert!(manager.get_prompt("test").is_some());
}</code></pre>
<h3 id="property-testing"><a class="header" href="#property-testing">Property Testing</a></h3>
<p>Using <code>proptest</code>:</p>
<pre><code class="language-rust">use proptest::prelude::*;

proptest! {
    #[test]
    fn test_prompt_name_validation(name in "[a-z][a-z0-9-]*") {
        assert!(is_valid_prompt_name(&amp;name));
    }
}</code></pre>
<h2 id="common-development-tasks"><a class="header" href="#common-development-tasks">Common Development Tasks</a></h2>
<h3 id="adding-a-new-command"><a class="header" href="#adding-a-new-command">Adding a New Command</a></h3>
<ol>
<li>
<p>Create command module in <code>src/cli/</code>:</p>
<pre><code class="language-rust">// src/cli/new_command.rs
use clap::Args;

#[derive(Args)]
pub struct NewCommand {
    #[arg(short, long)]
    option: String,
}

impl NewCommand {
    pub fn run(&amp;self) -&gt; Result&lt;()&gt; {
        // Implementation
        Ok(())
    }
}</code></pre>
</li>
<li>
<p>Add to CLI enum:</p>
<pre><code class="language-rust">// src/cli/mod.rs
#[derive(Subcommand)]
pub enum Commands {
    NewCommand(NewCommand),
    // ...
}</code></pre>
</li>
</ol>
<h3 id="adding-a-feature"><a class="header" href="#adding-a-feature">Adding a Feature</a></h3>
<ol>
<li>
<p>Define feature in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
experimental = ["dep:experimental-lib"]
</code></pre>
</li>
<li>
<p>Conditionally compile code:</p>
<pre><code class="language-rust">#[cfg(feature = "experimental")]
pub mod experimental {
    // Experimental features
}</code></pre>
</li>
</ol>
<h3 id="updating-dependencies"><a class="header" href="#updating-dependencies">Updating Dependencies</a></h3>
<pre><code class="language-bash"># Check outdated dependencies
cargo outdated

# Update specific dependency
cargo update -p serde

# Update all dependencies
cargo update

# Edit dependency version
cargo upgrade serde --version 1.0.150
</code></pre>
<h2 id="troubleshooting-11"><a class="header" href="#troubleshooting-11">Troubleshooting</a></h2>
<h3 id="common-issues-4"><a class="header" href="#common-issues-4">Common Issues</a></h3>
<h4 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation Errors</a></h4>
<pre><code class="language-bash"># Clean build artifacts
cargo clean

# Check for missing dependencies
cargo check

# Verify toolchain
rustup show
</code></pre>
<h4 id="test-failures"><a class="header" href="#test-failures">Test Failures</a></h4>
<pre><code class="language-bash"># Run single test with output
cargo test test_name -- --nocapture

# Run tests serially
cargo test -- --test-threads=1

# Skip slow tests
cargo test --lib
</code></pre>
<h4 id="performance-issues-5"><a class="header" href="#performance-issues-5">Performance Issues</a></h4>
<pre><code class="language-bash"># Build with debug symbols in release
cargo build --release --features debug

# Check binary size
cargo bloat --release

# Analyze dependencies
cargo tree --duplicates
</code></pre>
<h2 id="cicd-integration-1"><a class="header" href="#cicd-integration-1">CI/CD Integration</a></h2>
<h3 id="github-actions-1"><a class="header" href="#github-actions-1">GitHub Actions</a></h3>
<p><code>.github/workflows/ci.yml</code>:</p>
<pre><code class="language-yaml">name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        rust: [stable, beta]
    
    steps:
    - uses: actions/checkout@v3
    - uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
        components: rustfmt, clippy
    
    - name: Cache
      uses: Swatinem/rust-cache@v2
    
    - name: Check
      run: cargo check --all-features
    
    - name: Test
      run: cargo test --all-features
    
    - name: Clippy
      run: cargo clippy -- -D warnings
    
    - name: Format
      run: cargo fmt -- --check
</code></pre>
<h3 id="pre-commit-hooks"><a class="header" href="#pre-commit-hooks">Pre-commit Hooks</a></h3>
<p><code>.pre-commit-config.yaml</code>:</p>
<pre><code class="language-yaml">repos:
  - repo: local
    hooks:
      - id: fmt
        name: Format
        entry: cargo fmt -- --check
        language: system
        types: [rust]
        pass_filenames: false
      
      - id: clippy
        name: Clippy
        entry: cargo clippy -- -D warnings
        language: system
        types: [rust]
        pass_filenames: false
      
      - id: test
        name: Test
        entry: cargo test
        language: system
        types: [rust]
        pass_filenames: false
</code></pre>
<h2 id="next-steps-16"><a class="header" href="#next-steps-16">Next Steps</a></h2>
<ul>
<li>Read <a href="./contributing.html">Contributing</a> for contribution guidelines</li>
<li>Check <a href="./testing.html">Testing</a> for detailed testing practices</li>
<li>See <a href="./release-process.html">Release Process</a> for release procedures</li>
<li>Review <a href="./architecture.html">Architecture</a> for system design</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-3"><a class="header" href="#testing-3">Testing</a></h1>
<p>This guide covers testing practices and strategies for SwissArmyHammer development.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>SwissArmyHammer uses a comprehensive testing approach:</p>
<ul>
<li><strong>Unit tests</strong> - Test individual components</li>
<li><strong>Integration tests</strong> - Test component interactions</li>
<li><strong>End-to-end tests</strong> - Test complete workflows</li>
<li><strong>Property tests</strong> - Test with generated inputs</li>
<li><strong>Benchmark tests</strong> - Test performance</li>
</ul>
<h2 id="test-organization-1"><a class="header" href="#test-organization-1">Test Organization</a></h2>
<pre><code>swissarmyhammer/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ *.rs                  # Unit tests in source files
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ integration/          # Integration test files
â”‚   â”œâ”€â”€ common/              # Shared test utilities
â”‚   â””â”€â”€ fixtures/            # Test data files
â”œâ”€â”€ benches/                 # Benchmark tests
â””â”€â”€ examples/                # Example code (also tested)
</code></pre>
<h2 id="unit-testing-1"><a class="header" href="#unit-testing-1">Unit Testing</a></h2>
<h3 id="basic-unit-tests"><a class="header" href="#basic-unit-tests">Basic Unit Tests</a></h3>
<p>Place unit tests in the same file as the code:</p>
<pre><code class="language-rust">// src/prompts/prompt.rs

pub struct Prompt {
    pub name: String,
    pub title: String,
    pub content: String,
}

impl Prompt {
    pub fn parse(content: &amp;str) -&gt; Result&lt;Self&gt; {
        // Implementation
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_valid_prompt() {
        let content = r#"---
name: test
title: Test Prompt
---
Content here"#;

        let prompt = Prompt::parse(content).unwrap();
        assert_eq!(prompt.name, "test");
        assert_eq!(prompt.title, "Test Prompt");
        assert!(prompt.content.contains("Content here"));
    }

    #[test]
    fn test_parse_missing_name() {
        let content = r#"---
title: Test Prompt
---
Content"#;

        let result = Prompt::parse(content);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("name"));
    }
}</code></pre>
<h3 id="testing-private-functions"><a class="header" href="#testing-private-functions">Testing Private Functions</a></h3>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    // Test private functions by making them pub(crate) in test mode
    #[test]
    fn test_private_helper() {
        // Can access private functions within the module
        let result = validate_prompt_name("test-name");
        assert!(result);
    }
}</code></pre>
<h3 id="mock-dependencies"><a class="header" href="#mock-dependencies">Mock Dependencies</a></h3>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;
    use mockall::*;

    #[automock]
    trait FileSystem {
        fn read_file(&amp;self, path: &amp;Path) -&gt; io::Result&lt;String&gt;;
    }

    #[test]
    fn test_with_mock_filesystem() {
        let mut mock = MockFileSystem::new();
        mock.expect_read_file()
            .returning(|_| Ok("file content".to_string()));

        let result = process_with_fs(&amp;mock, "test.md");
        assert!(result.is_ok());
    }
}</code></pre>
<h2 id="integration-testing-1"><a class="header" href="#integration-testing-1">Integration Testing</a></h2>
<h3 id="basic-integration-test"><a class="header" href="#basic-integration-test">Basic Integration Test</a></h3>
<p>Create files in <code>tests/integration/</code>:</p>
<pre><code class="language-rust">// tests/integration/prompt_loading.rs

use swissarmyhammer::{PromptManager, Config};
use tempfile::tempdir;
use std::fs;

#[test]
fn test_load_prompts_from_directory() {
    // Create temporary directory
    let temp_dir = tempdir().unwrap();
    let prompt_path = temp_dir.path().join("test.md");
    
    // Write test prompt
    fs::write(&amp;prompt_path, r#"---
name: test-prompt
title: Test Prompt
---
Test content"#).unwrap();

    // Test loading
    let mut config = Config::default();
    config.prompt_directories.push(temp_dir.path().to_path_buf());
    
    let manager = PromptManager::with_config(config).unwrap();
    manager.load_prompts().unwrap();
    
    // Verify
    let prompt = manager.get_prompt("test-prompt").unwrap();
    assert_eq!(prompt.title, "Test Prompt");
}</code></pre>
<h3 id="testing-mcp-server"><a class="header" href="#testing-mcp-server">Testing MCP Server</a></h3>
<pre><code class="language-rust">// tests/integration/mcp_server.rs

use swissarmyhammer::mcp::{MCPServer, MCPRequest, MCPResponse};
use serde_json::json;

#[tokio::test]
async fn test_mcp_initialize() {
    let server = MCPServer::new();
    
    let request = MCPRequest {
        jsonrpc: "2.0".to_string(),
        method: "initialize".to_string(),
        params: json!({}),
        id: Some(json!(1)),
    };
    
    let response = server.handle_request(request).await.unwrap();
    
    assert_eq!(response.jsonrpc, "2.0");
    assert!(response.result.is_some());
    assert!(response.result.unwrap()["serverInfo"]["name"]
        .as_str()
        .unwrap()
        .contains("swissarmyhammer"));
}

#[tokio::test]
async fn test_mcp_list_prompts() {
    let server = setup_test_server().await;
    
    let request = MCPRequest {
        jsonrpc: "2.0".to_string(),
        method: "prompts/list".to_string(),
        params: json!({}),
        id: Some(json!(2)),
    };
    
    let response = server.handle_request(request).await.unwrap();
    let prompts = &amp;response.result.unwrap()["prompts"];
    
    assert!(prompts.is_array());
    assert!(!prompts.as_array().unwrap().is_empty());
}</code></pre>
<h3 id="testing-cli-commands"><a class="header" href="#testing-cli-commands">Testing CLI Commands</a></h3>
<pre><code class="language-rust">// tests/integration/cli_commands.rs

use assert_cmd::Command;
use predicates::prelude::*;
use tempfile::tempdir;

#[test]
fn test_list_command() {
    let mut cmd = Command::cargo_bin("swissarmyhammer").unwrap();
    
    cmd.arg("list")
        .assert()
        .success()
        .stdout(predicate::str::contains("Available prompts:"));
}

#[test]
fn test_serve_command_help() {
    let mut cmd = Command::cargo_bin("swissarmyhammer").unwrap();
    
    cmd.arg("serve")
        .arg("--help")
        .assert()
        .success()
        .stdout(predicate::str::contains("Start the MCP server"));
}

#[test]
fn test_export_import_workflow() {
    let temp_dir = tempdir().unwrap();
    let export_path = temp_dir.path().join("export.tar.gz");
    
    // Export
    Command::cargo_bin("swissarmyhammer").unwrap()
        .arg("export")
        .arg(&amp;export_path)
        .assert()
        .success();
    
    // Import
    Command::cargo_bin("swissarmyhammer").unwrap()
        .arg("import")
        .arg(&amp;export_path)
        .arg("--dry-run")
        .assert()
        .success()
        .stdout(predicate::str::contains("Would import"));
}</code></pre>
<h2 id="property-testing-1"><a class="header" href="#property-testing-1">Property Testing</a></h2>
<h3 id="using-proptest"><a class="header" href="#using-proptest">Using Proptest</a></h3>
<pre><code class="language-rust">// src/validation.rs

use proptest::prelude::*;

fn is_valid_prompt_name(name: &amp;str) -&gt; bool {
    !name.is_empty() 
        &amp;&amp; name.chars().all(|c| c.is_alphanumeric() || c == '-')
        &amp;&amp; name.chars().next().unwrap().is_alphabetic()
}

#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn test_valid_names_accepted(name in "[a-z][a-z0-9-]{0,50}") {
            assert!(is_valid_prompt_name(&amp;name));
        }

        #[test]
        fn test_invalid_names_rejected(name in "[^a-z].*|.*[^a-z0-9-].*") {
            // Names starting with non-letter or containing invalid chars
            if !name.chars().next().unwrap().is_alphabetic() 
                || name.chars().any(|c| !c.is_alphanumeric() &amp;&amp; c != '-') {
                assert!(!is_valid_prompt_name(&amp;name));
            }
        }
    }
}</code></pre>
<h3 id="testing-template-rendering"><a class="header" href="#testing-template-rendering">Testing Template Rendering</a></h3>
<pre><code class="language-rust">use proptest::prelude::*;

proptest! {
    #[test]
    fn test_template_escaping(
        user_input in any::&lt;String&gt;(),
        template in "Hello {{name}}!"
    ) {
        let mut args = HashMap::new();
        args.insert("name", &amp;user_input);
        
        let result = render_template(&amp;template, &amp;args).unwrap();
        
        // Should not contain raw HTML
        if user_input.contains('&lt;') {
            assert!(!result.contains('&lt;'));
        }
    }
}</code></pre>
<h2 id="testing-async-code"><a class="header" href="#testing-async-code">Testing Async Code</a></h2>
<h3 id="basic-async-tests"><a class="header" href="#basic-async-tests">Basic Async Tests</a></h3>
<pre><code class="language-rust">#[tokio::test]
async fn test_async_prompt_loading() {
    let manager = PromptManager::new();
    
    let result = manager.load_prompts_async().await;
    assert!(result.is_ok());
    
    let prompts = manager.list_prompts().await;
    assert!(!prompts.is_empty());
}

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_concurrent_access() {
    let manager = Arc::new(PromptManager::new());
    
    let handle1 = {
        let mgr = Arc::clone(&amp;manager);
        tokio::spawn(async move {
            mgr.get_prompt("test1").await
        })
    };
    
    let handle2 = {
        let mgr = Arc::clone(&amp;manager);
        tokio::spawn(async move {
            mgr.get_prompt("test2").await
        })
    };
    
    let (result1, result2) = tokio::join!(handle1, handle2);
    assert!(result1.is_ok());
    assert!(result2.is_ok());
}</code></pre>
<h3 id="testing-timeouts"><a class="header" href="#testing-timeouts">Testing Timeouts</a></h3>
<pre><code class="language-rust">#[tokio::test]
async fn test_operation_timeout() {
    let manager = PromptManager::new();
    
    let result = tokio::time::timeout(
        Duration::from_secs(5),
        manager.slow_operation()
    ).await;
    
    assert!(result.is_ok(), "Operation should complete within timeout");
}</code></pre>
<h2 id="test-fixtures"><a class="header" href="#test-fixtures">Test Fixtures</a></h2>
<h3 id="using-test-data"><a class="header" href="#using-test-data">Using Test Data</a></h3>
<p>Create reusable test data in <code>tests/fixtures/</code>:</p>
<pre><code class="language-rust">// tests/common/mod.rs

use std::path::PathBuf;

pub fn test_prompt_content() -&gt; &amp;'static str {
    r#"---
name: test-prompt
title: Test Prompt
description: A prompt for testing
arguments:
  - name: input
    description: Test input
    required: true
---
Process this input: {{input}}"#
}

pub fn fixtures_dir() -&gt; PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures")
}

pub fn load_fixture(name: &amp;str) -&gt; String {
    std::fs::read_to_string(fixtures_dir().join(name))
        .expect("Failed to load fixture")
}</code></pre>
<h3 id="test-builders"><a class="header" href="#test-builders">Test Builders</a></h3>
<pre><code class="language-rust">// tests/common/builders.rs

pub struct PromptBuilder {
    name: String,
    title: String,
    content: String,
    arguments: Vec&lt;ArgumentSpec&gt;,
}

impl PromptBuilder {
    pub fn new(name: &amp;str) -&gt; Self {
        Self {
            name: name.to_string(),
            title: format!("{} Title", name),
            content: "Default content".to_string(),
            arguments: vec![],
        }
    }
    
    pub fn with_argument(mut self, name: &amp;str, required: bool) -&gt; Self {
        self.arguments.push(ArgumentSpec {
            name: name.to_string(),
            required,
            ..Default::default()
        });
        self
    }
    
    pub fn build(self) -&gt; String {
        // Generate YAML front matter and content
        format!(r#"---
name: {}
title: {}
arguments:
{}
---
{}"#, self.name, self.title, 
            self.arguments.iter()
                .map(|a| format!("  - name: {}\n    required: {}", a.name, a.required))
                .collect::&lt;Vec&lt;_&gt;&gt;()
                .join("\n"),
            self.content)
    }
}

// Usage in tests
#[test]
fn test_with_builder() {
    let prompt_content = PromptBuilder::new("test")
        .with_argument("input", true)
        .with_argument("format", false)
        .build();
    
    let prompt = Prompt::parse(&amp;prompt_content).unwrap();
    assert_eq!(prompt.arguments.len(), 2);
}</code></pre>
<h2 id="performance-testing-1"><a class="header" href="#performance-testing-1">Performance Testing</a></h2>
<h3 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h3>
<p>Create benchmarks in <code>benches/</code>:</p>
<pre><code class="language-rust">// benches/prompt_loading.rs

use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use swissarmyhammer::PromptManager;

fn benchmark_prompt_loading(c: &amp;mut Criterion) {
    let mut group = c.benchmark_group("prompt_loading");
    
    for size in [10, 100, 1000].iter() {
        group.bench_with_input(
            BenchmarkId::from_parameter(size),
            size,
            |b, &amp;size| {
                let temp_dir = create_test_prompts(size);
                b.iter(|| {
                    let manager = PromptManager::new();
                    manager.add_directory(temp_dir.path());
                    manager.load_prompts()
                });
            },
        );
    }
    
    group.finish();
}

fn benchmark_template_rendering(c: &amp;mut Criterion) {
    c.bench_function("render_simple_template", |b| {
        let template = "Hello {{name}}, welcome to {{place}}!";
        let mut args = HashMap::new();
        args.insert("name", "Alice");
        args.insert("place", "Wonderland");
        
        b.iter(|| {
            black_box(render_template(template, &amp;args))
        });
    });
}

criterion_group!(benches, benchmark_prompt_loading, benchmark_template_rendering);
criterion_main!(benches);</code></pre>
<h3 id="profiling-tests"><a class="header" href="#profiling-tests">Profiling Tests</a></h3>
<pre><code class="language-rust">#[test]
#[ignore] // Run with cargo test -- --ignored
fn profile_large_prompt_set() {
    let temp_dir = create_test_prompts(10000);
    
    let start = Instant::now();
    let manager = PromptManager::new();
    manager.add_directory(temp_dir.path());
    manager.load_prompts().unwrap();
    let duration = start.elapsed();
    
    println!("Loaded 10000 prompts in {:?}", duration);
    assert!(duration &lt; Duration::from_secs(5), "Loading too slow");
}</code></pre>
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<h3 id="generating-coverage-reports"><a class="header" href="#generating-coverage-reports">Generating Coverage Reports</a></h3>
<pre><code class="language-bash"># Install tarpaulin
cargo install cargo-tarpaulin

# Generate coverage report
cargo tarpaulin --out Html --output-dir coverage

# With specific features
cargo tarpaulin --features "experimental" --out Lcov

# Exclude test code from coverage
cargo tarpaulin --exclude-files "*/tests/*" --exclude-files "*/benches/*"
</code></pre>
<h3 id="coverage-configuration"><a class="header" href="#coverage-configuration">Coverage Configuration</a></h3>
<p><code>.tarpaulin.toml</code>:</p>
<pre><code class="language-toml">[default]
exclude-files = ["*/tests/*", "*/benches/*", "*/examples/*"]
ignored = false
timeout = "600s"
features = "all"

[report]
out = ["Html", "Lcov"]
output-dir = "coverage"
</code></pre>
<h2 id="test-utilities"><a class="header" href="#test-utilities">Test Utilities</a></h2>
<h3 id="custom-assertions"><a class="header" href="#custom-assertions">Custom Assertions</a></h3>
<pre><code class="language-rust">// tests/common/assertions.rs

pub trait PromptAssertions {
    fn assert_valid_prompt(&amp;self);
    fn assert_has_argument(&amp;self, name: &amp;str);
    fn assert_renders_with(&amp;self, args: &amp;HashMap&lt;String, String&gt;);
}

impl PromptAssertions for Prompt {
    fn assert_valid_prompt(&amp;self) {
        assert!(!self.name.is_empty(), "Prompt name is empty");
        assert!(!self.title.is_empty(), "Prompt title is empty");
        assert!(is_valid_prompt_name(&amp;self.name), "Invalid prompt name");
    }
    
    fn assert_has_argument(&amp;self, name: &amp;str) {
        assert!(
            self.arguments.iter().any(|a| a.name == name),
            "Prompt missing expected argument: {}", name
        );
    }
    
    fn assert_renders_with(&amp;self, args: &amp;HashMap&lt;String, String&gt;) {
        let result = self.render(args);
        assert!(result.is_ok(), "Failed to render: {:?}", result.err());
        assert!(!result.unwrap().is_empty(), "Rendered output is empty");
    }
}</code></pre>
<h3 id="test-helpers"><a class="header" href="#test-helpers">Test Helpers</a></h3>
<pre><code class="language-rust">// tests/common/helpers.rs

use std::sync::Once;

static INIT: Once = Once::new();

pub fn init_test_logging() {
    INIT.call_once(|| {
        env_logger::builder()
            .filter_level(log::LevelFilter::Debug)
            .is_test(true)
            .init();
    });
}

pub fn with_test_env&lt;F&gt;(vars: Vec&lt;(&amp;str, &amp;str)&gt;, test: F)
where
    F: FnOnce() + std::panic::UnwindSafe,
{
    let _guards: Vec&lt;_&gt; = vars.into_iter()
        .map(|(k, v)| {
            env::set_var(k, v);
            defer::defer(move || env::remove_var(k))
        })
        .collect();
    
    test();
}

// Usage
#[test]
fn test_with_env_vars() {
    with_test_env(vec![
        ("SWISSARMYHAMMER_DEBUG", "true"),
        ("SWISSARMYHAMMER_PORT", "9999"),
    ], || {
        let config = Config::from_env();
        assert!(config.debug);
        assert_eq!(config.port, 9999);
    });
}</code></pre>
<h2 id="debugging-tests"><a class="header" href="#debugging-tests">Debugging Tests</a></h2>
<h3 id="debug-output-2"><a class="header" href="#debug-output-2">Debug Output</a></h3>
<pre><code class="language-rust">#[test]
fn test_with_debug_output() {
    init_test_logging();
    
    log::debug!("Starting test");
    
    let result = some_operation();
    
    // Print debug info on failure
    if result.is_err() {
        eprintln!("Operation failed: {:?}", result);
        eprintln!("Current state: {:?}", get_debug_state());
    }
    
    assert!(result.is_ok());
}</code></pre>
<h3 id="test-isolation"><a class="header" href="#test-isolation">Test Isolation</a></h3>
<pre><code class="language-rust">#[test]
fn test_isolated_state() {
    // Use a unique test ID to avoid conflicts
    let test_id = uuid::Uuid::new_v4();
    let test_dir = temp_dir().join(format!("test-{}", test_id));
    
    // Ensure cleanup even on panic
    let _guard = defer::defer(|| {
        let _ = fs::remove_dir_all(&amp;test_dir);
    });
    
    // Run test with isolated state
    run_test_in_dir(&amp;test_dir);
}</code></pre>
<h2 id="ci-testing"><a class="header" href="#ci-testing">CI Testing</a></h2>
<h3 id="github-actions-test-matrix"><a class="header" href="#github-actions-test-matrix">GitHub Actions Test Matrix</a></h3>
<pre><code class="language-yaml">name: Test

on: [push, pull_request]

jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        rust: [stable, beta, nightly]
        features: ["", "all", "experimental"]
    
    runs-on: ${{ matrix.os }}
    
    steps:
    - uses: actions/checkout@v3
    
    - uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
    
    - name: Test
      run: cargo test --features "${{ matrix.features }}"
      
    - name: Test Examples
      run: cargo test --examples
      
    - name: Doc Tests
      run: cargo test --doc
</code></pre>
<h2 id="best-practices-18"><a class="header" href="#best-practices-18">Best Practices</a></h2>
<h3 id="1-test-organization"><a class="header" href="#1-test-organization">1. Test Organization</a></h3>
<ul>
<li>Keep unit tests with the code</li>
<li>Use integration tests for workflows</li>
<li>Group related tests</li>
<li>Share common utilities</li>
</ul>
<h3 id="2-test-naming"><a class="header" href="#2-test-naming">2. Test Naming</a></h3>
<pre><code class="language-rust">#[test]
fn test_parse_valid_prompt() { }       // Clear what's being tested

#[test]
fn test_render_with_missing_arg() { }  // Clear expected outcome

#[test]
fn test_concurrent_access_safety() { } // Clear test scenario</code></pre>
<h3 id="3-test-independence"><a class="header" href="#3-test-independence">3. Test Independence</a></h3>
<ul>
<li>Each test should be independent</li>
<li>Use temporary directories</li>
<li>Clean up resources</li>
<li>Donâ€™t rely on test order</li>
</ul>
<h3 id="4-test-coverage"><a class="header" href="#4-test-coverage">4. Test Coverage</a></h3>
<ul>
<li>Aim for &gt;80% coverage</li>
<li>Test edge cases</li>
<li>Test error paths</li>
<li>Test concurrent scenarios</li>
</ul>
<h3 id="5-performance"><a class="header" href="#5-performance">5. Performance</a></h3>
<ul>
<li>Keep tests fast (&lt;100ms each)</li>
<li>Use <code>#[ignore]</code> for slow tests</li>
<li>Run slow tests in CI only</li>
<li>Mock expensive operations</li>
</ul>
<h2 id="next-steps-17"><a class="header" href="#next-steps-17">Next Steps</a></h2>
<ul>
<li>Read <a href="./development.html">Development Setup</a> for environment setup</li>
<li>See <a href="./contributing.html">Contributing</a> for contribution guidelines</li>
<li>Check <a href="./ci-cd.html">CI/CD</a> for automated testing</li>
<li>Review <a href="./benchmarking.html">Benchmarking</a> for performance testing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-process-1"><a class="header" href="#release-process-1">Release Process</a></h1>
<p>This guide documents the release process for SwissArmyHammer, including versioning, testing, building, and publishing.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>SwissArmyHammer follows a structured release process:</p>
<ol>
<li><strong>Version Planning</strong> - Determine version number and scope</li>
<li><strong>Pre-release Testing</strong> - Comprehensive testing</li>
<li><strong>Release Preparation</strong> - Update version, changelog</li>
<li><strong>Building</strong> - Create release artifacts</li>
<li><strong>Publishing</strong> - Release to crates.io and GitHub</li>
<li><strong>Post-release</strong> - Announcements and documentation</li>
</ol>
<h2 id="versioning-1"><a class="header" href="#versioning-1">Versioning</a></h2>
<h3 id="semantic-versioning"><a class="header" href="#semantic-versioning">Semantic Versioning</a></h3>
<p>We follow <a href="https://semver.org/">Semantic Versioning</a>:</p>
<pre><code>MAJOR.MINOR.PATCH

1.0.0
â”‚ â”‚ â””â”€â”€ Patch: Bug fixes, no API changes
â”‚ â””â”€â”€â”€â”€ Minor: New features, backward compatible
â””â”€â”€â”€â”€â”€â”€ Major: Breaking changes
</code></pre>
<h3 id="version-guidelines"><a class="header" href="#version-guidelines">Version Guidelines</a></h3>
<h4 id="patch-release-00x"><a class="header" href="#patch-release-00x">Patch Release (0.0.X)</a></h4>
<ul>
<li>Bug fixes</li>
<li>Documentation improvements</li>
<li>Performance improvements (no API change)</li>
<li>Security patches</li>
</ul>
<h4 id="minor-release-0x0"><a class="header" href="#minor-release-0x0">Minor Release (0.X.0)</a></h4>
<ul>
<li>New features</li>
<li>New commands</li>
<li>New configuration options</li>
<li>Deprecations (with warnings)</li>
</ul>
<h4 id="major-release-x00"><a class="header" href="#major-release-x00">Major Release (X.0.0)</a></h4>
<ul>
<li>Breaking API changes</li>
<li>Removal of deprecated features</li>
<li>Major architectural changes</li>
<li>Incompatible configuration changes</li>
</ul>
<h2 id="release-checklist-1"><a class="header" href="#release-checklist-1">Release Checklist</a></h2>
<h3 id="pre-release-checklist"><a class="header" href="#pre-release-checklist">Pre-release Checklist</a></h3>
<pre><code class="language-markdown">## Pre-release Checklist

- [ ] All tests passing on main branch
- [ ] No outstanding security issues
- [ ] Documentation updated
- [ ] CHANGELOG.md updated
- [ ] Version numbers updated
- [ ] Release branch created
- [ ] Release PR approved
</code></pre>
<h3 id="release-build-checklist"><a class="header" href="#release-build-checklist">Release Build Checklist</a></h3>
<pre><code class="language-markdown">## Build Checklist

- [ ] Clean build on all platforms
- [ ] All features compile
- [ ] Binary size acceptable
- [ ] Performance benchmarks acceptable
- [ ] Security audit passing
</code></pre>
<h2 id="release-preparation"><a class="header" href="#release-preparation">Release Preparation</a></h2>
<h3 id="1-create-release-branch"><a class="header" href="#1-create-release-branch">1. Create Release Branch</a></h3>
<pre><code class="language-bash"># Create release branch from main
git checkout main
git pull origin main
git checkout -b release/v1.2.3

# Or for release candidates
git checkout -b release/v1.2.3-rc1
</code></pre>
<h3 id="2-update-version-numbers"><a class="header" href="#2-update-version-numbers">2. Update Version Numbers</a></h3>
<p>Update version in multiple files:</p>
<pre><code class="language-bash"># Cargo.toml
[package]
name = "swissarmyhammer"
version = "1.2.3"  # Update this

# Update lock file
cargo update -p swissarmyhammer
</code></pre>
<h3 id="3-update-changelog"><a class="header" href="#3-update-changelog">3. Update Changelog</a></h3>
<p>Edit <code>CHANGELOG.md</code>:</p>
<pre><code class="language-markdown"># Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [1.2.3] - 2024-03-15

### Added
- New `validate` command for prompt validation
- Support for YAML anchors in prompts
- Performance monitoring dashboard

### Changed
- Improved error messages for template rendering
- Updated minimum Rust version to 1.70

### Fixed
- Fixed file watcher memory leak (#123)
- Corrected prompt loading on Windows (#124)

### Security
- Updated dependencies to patch CVE-2024-XXXXX

[1.2.3]: https://github.com/wballard/swissarmyhammer/compare/v1.2.2...v1.2.3
</code></pre>
<h3 id="4-update-documentation"><a class="header" href="#4-update-documentation">4. Update Documentation</a></h3>
<pre><code class="language-bash"># Update version in documentation
find doc -name "*.md" -exec sed -i 's/0\.1\.0/1.2.3/g' {} \;

# Rebuild documentation
cd doc
mdbook build

# Update README if needed
vim README.md
</code></pre>
<h3 id="5-run-pre-release-tests"><a class="header" href="#5-run-pre-release-tests">5. Run Pre-release Tests</a></h3>
<pre><code class="language-bash"># Full test suite
cargo test --all-features

# Test on different platforms
cargo test --target x86_64-pc-windows-gnu
cargo test --target x86_64-apple-darwin

# Integration tests
cargo test --test '*' -- --test-threads=1

# Benchmarks
cargo bench

# Security audit
cargo audit

# Check for unused dependencies
cargo machete
</code></pre>
<h2 id="building-release-artifacts"><a class="header" href="#building-release-artifacts">Building Release Artifacts</a></h2>
<h3 id="local-build-script"><a class="header" href="#local-build-script">Local Build Script</a></h3>
<p>Create <code>scripts/build-release.sh</code>:</p>
<pre><code class="language-bash">#!/bin/bash
set -e

VERSION=$1
if [ -z "$VERSION" ]; then
    echo "Usage: $0 &lt;version&gt;"
    exit 1
fi

echo "Building SwissArmyHammer v$VERSION"

# Clean previous builds
cargo clean
rm -rf target/release-artifacts
mkdir -p target/release-artifacts

# Build for multiple platforms
PLATFORMS=(
    "x86_64-unknown-linux-gnu"
    "x86_64-apple-darwin"
    "aarch64-apple-darwin"
    "x86_64-pc-windows-gnu"
)

for platform in "${PLATFORMS[@]}"; do
    echo "Building for $platform..."
    
    if [[ "$platform" == *"windows"* ]]; then
        ext=".exe"
    else
        ext=""
    fi
    
    # Build
    cross build --release --target "$platform"
    
    # Package
    cp "target/$platform/release/swissarmyhammer$ext" \
       "target/release-artifacts/swissarmyhammer-$VERSION-$platform$ext"
    
    # Create tarball/zip
    if [[ "$platform" == *"windows"* ]]; then
        cd target/release-artifacts
        zip "swissarmyhammer-$VERSION-$platform.zip" \
            "swissarmyhammer-$VERSION-$platform.exe"
        rm "swissarmyhammer-$VERSION-$platform.exe"
        cd ../..
    else
        cd target/release-artifacts
        tar -czf "swissarmyhammer-$VERSION-$platform.tar.gz" \
            "swissarmyhammer-$VERSION-$platform"
        rm "swissarmyhammer-$VERSION-$platform"
        cd ../..
    fi
done

# Generate checksums
cd target/release-artifacts
shasum -a 256 * &gt; checksums.sha256
cd ../..

echo "Release artifacts built in target/release-artifacts/"
</code></pre>
<h3 id="github-actions-release"><a class="header" href="#github-actions-release">GitHub Actions Release</a></h3>
<p><code>.github/workflows/release.yml</code>:</p>
<pre><code class="language-yaml">name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    steps:
      - uses: actions/checkout@v3
      
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: true
          prerelease: false
          body_path: RELEASE_NOTES.md

  build-release:
    needs: create-release
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            artifact: swissarmyhammer
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            artifact: swissarmyhammer
          - os: macos-latest
            target: x86_64-apple-darwin
            artifact: swissarmyhammer
          - os: macos-latest
            target: aarch64-apple-darwin
            artifact: swissarmyhammer
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            artifact: swissarmyhammer.exe
    
    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v3
      
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      
      - name: Build
        run: cargo build --release --target ${{ matrix.target }}
      
      - name: Package (Unix)
        if: matrix.os != 'windows-latest'
        run: |
          cd target/${{ matrix.target }}/release
          tar -czf swissarmyhammer-${{ github.ref_name }}-${{ matrix.target }}.tar.gz swissarmyhammer
          mv *.tar.gz ../../../
      
      - name: Package (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          cd target/${{ matrix.target }}/release
          7z a swissarmyhammer-${{ github.ref_name }}-${{ matrix.target }}.zip swissarmyhammer.exe
          mv *.zip ../../../
      
      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./swissarmyhammer-${{ github.ref_name }}-${{ matrix.target }}.${{ matrix.os == 'windows-latest' &amp;&amp; 'zip' || 'tar.gz' }}
          asset_name: swissarmyhammer-${{ github.ref_name }}-${{ matrix.target }}.${{ matrix.os == 'windows-latest' &amp;&amp; 'zip' || 'tar.gz' }}
          asset_content_type: ${{ matrix.os == 'windows-latest' &amp;&amp; 'application/zip' || 'application/gzip' }}
</code></pre>
<h2 id="publishing"><a class="header" href="#publishing">Publishing</a></h2>
<h3 id="1-publish-to-cratesio"><a class="header" href="#1-publish-to-cratesio">1. Publish to crates.io</a></h3>
<pre><code class="language-bash"># Dry run first
cargo publish --dry-run

# Verify package contents
cargo package --list

# Publish
cargo publish

# Note: You need to be logged in
cargo login &lt;token&gt;
</code></pre>
<h3 id="2-create-github-release"><a class="header" href="#2-create-github-release">2. Create GitHub Release</a></h3>
<pre><code class="language-bash"># Push release branch
git push origin release/v1.2.3

# Create and merge PR
gh pr create --title "Release v1.2.3" \
  --body "Release version 1.2.3. See CHANGELOG.md for details."

# After PR merged, create tag
git checkout main
git pull origin main
git tag -a v1.2.3 -m "Release version 1.2.3"
git push origin v1.2.3
</code></pre>
<h3 id="3-update-github-release"><a class="header" href="#3-update-github-release">3. Update GitHub Release</a></h3>
<p>After CI builds artifacts:</p>
<pre><code class="language-bash"># Edit release notes
gh release edit v1.2.3 --notes-file RELEASE_NOTES.md

# Publish release (remove draft status)
gh release edit v1.2.3 --draft=false
</code></pre>
<h2 id="post-release"><a class="header" href="#post-release">Post-release</a></h2>
<h3 id="1-update-documentation"><a class="header" href="#1-update-documentation">1. Update Documentation</a></h3>
<pre><code class="language-bash"># Update stable docs
git checkout gh-pages
cp -r doc/book/* .
git add .
git commit -m "Update documentation for v1.2.3"
git push origin gh-pages
</code></pre>
<h3 id="2-announcements"><a class="header" href="#2-announcements">2. Announcements</a></h3>
<p>Create announcement template:</p>
<pre><code class="language-markdown"># SwissArmyHammer v1.2.3 Released!

We're excited to announce the release of SwissArmyHammer v1.2.3!

## Highlights

- ğŸš€ New validate command for prompt validation
- ğŸ“Š Performance monitoring dashboard
- ğŸ› Fixed file watcher memory leak
- ğŸ”’ Security updates

## Installation

```bash
# Install with cargo
cargo install swissarmyhammer

# Or download binaries
https://github.com/wballard/swissarmyhammer/releases/tag/v1.2.3
</code></pre>
<h2 id="whats-changed"><a class="header" href="#whats-changed">Whatâ€™s Changed</a></h2>
<p><a href="https://github.com/wballard/swissarmyhammer/blob/main/CHANGELOG.md">Full changelog</a></p>
<h2 id="thank-you-1"><a class="header" href="#thank-you-1">Thank You</a></h2>
<p>Thanks to all contributors who made this release possible!</p>
<pre><code>
Post to:
- GitHub Discussions
- Discord/Slack channels
- Twitter/Social media
- Dev.to/Medium article

### 3. Update Homebrew Formula

If maintaining Homebrew formula:

```ruby
class Swissarmyhammer &lt; Formula
  desc "MCP server for prompt management"
  homepage "https://github.com/wballard/swissarmyhammer"
  version "1.2.3"
  
  if OS.mac? &amp;&amp; Hardware::CPU.intel?
    url "https://github.com/wballard/swissarmyhammer/releases/download/v1.2.3/swissarmyhammer-v1.2.3-x86_64-apple-darwin.tar.gz"
    sha256 "HASH_HERE"
  elsif OS.mac? &amp;&amp; Hardware::CPU.arm?
    url "https://github.com/wballard/swissarmyhammer/releases/download/v1.2.3/swissarmyhammer-v1.2.3-aarch64-apple-darwin.tar.gz"
    sha256 "HASH_HERE"
  elsif OS.linux?
    url "https://github.com/wballard/swissarmyhammer/releases/download/v1.2.3/swissarmyhammer-v1.2.3-x86_64-unknown-linux-gnu.tar.gz"
    sha256 "HASH_HERE"
  end

  def install
    bin.install "swissarmyhammer"
  end
end
</code></pre>
<h3 id="4-monitor-release"><a class="header" href="#4-monitor-release">4. Monitor Release</a></h3>
<pre><code class="language-bash"># Check crates.io
open https://crates.io/crates/swissarmyhammer

# Monitor GitHub issues
gh issue list --label "v1.2.3"

# Check download stats
gh api repos/wballard/swissarmyhammer/releases/tags/v1.2.3
</code></pre>
<h2 id="hotfix-process"><a class="header" href="#hotfix-process">Hotfix Process</a></h2>
<p>For critical fixes:</p>
<pre><code class="language-bash"># Create hotfix branch from tag
git checkout -b hotfix/v1.2.4 v1.2.3

# Make fixes
# ...

# Update version to 1.2.4
vim Cargo.toml

# Fast-track release
cargo test
cargo publish
git tag -a v1.2.4 -m "Hotfix: Critical bug in prompt loading"
git push origin v1.2.4
</code></pre>
<h2 id="release-automation"><a class="header" href="#release-automation">Release Automation</a></h2>
<h3 id="release-script"><a class="header" href="#release-script">Release Script</a></h3>
<p><code>scripts/prepare-release.sh</code>:</p>
<pre><code class="language-bash">#!/bin/bash
set -e

VERSION=$1
TYPE=${2:-patch} # patch, minor, major

if [ -z "$VERSION" ]; then
    echo "Usage: $0 &lt;version&gt; [patch|minor|major]"
    exit 1
fi

echo "Preparing release v$VERSION ($TYPE)"

# Update version
sed -i "s/^version = .*/version = \"$VERSION\"/" Cargo.toml

# Update lock file
cargo update -p swissarmyhammer

# Run tests
echo "Running tests..."
cargo test --all-features

# Update changelog
echo "Updating CHANGELOG.md..."
# Auto-generate from commits
git log --pretty=format:"- %s (%h)" v$(cargo pkgid | cut -d# -f2)..HEAD &gt;&gt; CHANGELOG_NEW.md

# Build documentation
echo "Building documentation..."
cd doc &amp;&amp; mdbook build &amp;&amp; cd ..

# Create release notes
echo "# Release v$VERSION" &gt; RELEASE_NOTES.md
echo "" &gt;&gt; RELEASE_NOTES.md
cat CHANGELOG_NEW.md &gt;&gt; RELEASE_NOTES.md

echo "Release preparation complete!"
echo "Next steps:"
echo "1. Review and edit CHANGELOG.md and RELEASE_NOTES.md"
echo "2. Commit changes"
echo "3. Create PR for release/v$VERSION"
echo "4. After merge, tag and push"
</code></pre>
<h2 id="rollback-procedure"><a class="header" href="#rollback-procedure">Rollback Procedure</a></h2>
<p>If issues are found after release:</p>
<ol>
<li>
<p><strong>Yank from crates.io</strong> (if critical):</p>
<pre><code class="language-bash">cargo yank --vers 1.2.3
</code></pre>
</li>
<li>
<p><strong>Update GitHub Release</strong>:</p>
<pre><code class="language-bash">gh release edit v1.2.3 --prerelease
</code></pre>
</li>
<li>
<p><strong>Communicate</strong>:</p>
<ul>
<li>Post in announcements</li>
<li>Create issue for tracking</li>
<li>Prepare hotfix</li>
</ul>
</li>
<li>
<p><strong>Fix and Re-release</strong>:</p>
<pre><code class="language-bash"># Create fix
git checkout -b fix/critical-issue
# ... make fixes ...

# New version
cargo release patch
</code></pre>
</li>
</ol>
<h2 id="best-practices-19"><a class="header" href="#best-practices-19">Best Practices</a></h2>
<ol>
<li>
<p><strong>Test Thoroughly</strong></p>
<ul>
<li>Run full test suite</li>
<li>Test on all platforms</li>
<li>Manual smoke tests</li>
</ul>
</li>
<li>
<p><strong>Document Changes</strong></p>
<ul>
<li>Update CHANGELOG.md</li>
<li>Write clear release notes</li>
<li>Update migration guides</li>
</ul>
</li>
<li>
<p><strong>Communicate Clearly</strong></p>
<ul>
<li>Announce deprecations early</li>
<li>Provide migration paths</li>
<li>Respond to feedback quickly</li>
</ul>
</li>
<li>
<p><strong>Automate When Possible</strong></p>
<ul>
<li>Use CI for builds</li>
<li>Automate version updates</li>
<li>Script repetitive tasks</li>
</ul>
</li>
</ol>
<h2 id="next-steps-18"><a class="header" href="#next-steps-18">Next Steps</a></h2>
<ul>
<li>Review <a href="./contributing.html">Contributing</a> for development workflow</li>
<li>See <a href="./testing.html">Testing</a> for test requirements</li>
<li>Check <a href="./development.html">Development</a> for build setup</li>
<li>Read <a href="./changelog.html">Changelog</a> for version history</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to SwissArmyHammer will be documented in this file.</p>
<p>The format is based on <a href="https://keepachangelog.com/en/1.0.0/">Keep a Changelog</a>,
and this project adheres to <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<h2 id="unreleased"><a class="header" href="#unreleased"><a href="https://github.com/wballard/swissarmyhammer/compare/v0.2.0...HEAD">Unreleased</a></a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li>Comprehensive documentation with mdBook</li>
<li>GitHub Pages deployment for documentation</li>
<li>Enhanced error messages with context</li>
<li>Validation for prompt arguments</li>
<li>Support for YAML anchors in prompts</li>
<li>Performance benchmarks</li>
</ul>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li>Improved template rendering performance</li>
<li>Better error handling in MCP server</li>
<li>Enhanced file watching efficiency</li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li>Memory leak in file watcher</li>
<li>Prompt loading on Windows paths</li>
<li>Template escaping for special characters</li>
</ul>
<h2 id="020---2024-03-01"><a class="header" href="#020---2024-03-01"><a href="https://github.com/wballard/swissarmyhammer/compare/v0.1.0...v0.2.0">0.2.0</a> - 2024-03-01</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>MCP (Model Context Protocol) server implementation</li>
<li>File watching for automatic prompt reloading</li>
<li>Doctor command for system health checks</li>
<li>Liquid template engine integration</li>
<li>Support for prompt arguments and validation</li>
<li>Recursive directory scanning</li>
<li>YAML front matter parsing</li>
</ul>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li>Migrated from simple templates to Liquid engine</li>
<li>Improved prompt discovery algorithm</li>
<li>Enhanced CLI output formatting</li>
<li>Better error messages and diagnostics</li>
</ul>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li>Cross-platform path handling</li>
<li>Unicode support in prompts</li>
<li>Memory usage optimization</li>
</ul>
<h3 id="security"><a class="header" href="#security">Security</a></h3>
<ul>
<li>Added input sanitization for templates</li>
<li>Implemented secure file access controls</li>
</ul>
<h2 id="010---2024-01-15"><a class="header" href="#010---2024-01-15"><a href="https://github.com/wballard/swissarmyhammer/releases/tag/v0.1.0">0.1.0</a> - 2024-01-15</a></h2>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<ul>
<li>Initial release</li>
<li>Basic prompt management functionality</li>
<li>CLI interface with subcommands</li>
<li>List command to show available prompts</li>
<li>Serve command for MCP integration</li>
<li>Simple template substitution</li>
<li>Configuration file support</li>
<li>Basic documentation</li>
</ul>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<ul>
<li>N/A (initial release)</li>
</ul>
<h3 id="fixed-2"><a class="header" href="#fixed-2">Fixed</a></h3>
<ul>
<li>N/A (initial release)</li>
</ul>
<h3 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h3>
<ul>
<li>N/A (initial release)</li>
</ul>
<h3 id="removed"><a class="header" href="#removed">Removed</a></h3>
<ul>
<li>N/A (initial release)</li>
</ul>
<h3 id="security-1"><a class="header" href="#security-1">Security</a></h3>
<ul>
<li>N/A (initial release)</li>
</ul>
<h2 id="version-history"><a class="header" href="#version-history">Version History</a></h2>
<h3 id="versioning-policy"><a class="header" href="#versioning-policy">Versioning Policy</a></h3>
<p>SwissArmyHammer follows <a href="https://semver.org/">Semantic Versioning</a>:</p>
<ul>
<li><strong>MAJOR</strong> version for incompatible API changes</li>
<li><strong>MINOR</strong> version for backwards-compatible functionality additions</li>
<li><strong>PATCH</strong> version for backwards-compatible bug fixes</li>
</ul>
<h3 id="pre-10-versions"><a class="header" href="#pre-10-versions">Pre-1.0 Versions</a></h3>
<p>During the 0.x series:</p>
<ul>
<li>Minor version bumps may include breaking changes</li>
<li>The API is considered unstable</li>
<li>Features may be experimental</li>
</ul>
<h3 id="migration-guides-1"><a class="header" href="#migration-guides-1">Migration Guides</a></h3>
<h4 id="01x-to-02x"><a class="header" href="#01x-to-02x">0.1.x to 0.2.x</a></h4>
<p><strong>Breaking Changes:</strong></p>
<ol>
<li>
<p><strong>Template Engine Change</strong></p>
<ul>
<li>Old: Simple <code>{variable}</code> substitution</li>
<li>New: Liquid templates with <code>{{variable}}</code></li>
<li>Migration: Update all prompts to use double braces</li>
</ul>
</li>
<li>
<p><strong>Configuration Format</strong></p>
<ul>
<li>Old: JSON configuration</li>
<li>New: TOML configuration</li>
<li>Migration: Convert config.json to config.toml</li>
</ul>
</li>
<li>
<p><strong>Prompt Metadata</strong></p>
<ul>
<li>Old: Optional metadata</li>
<li>New: Required YAML front matter</li>
<li>Migration: Add minimal front matter to all prompts</li>
</ul>
</li>
</ol>
<p><strong>Example Migration:</strong></p>
<p>Old prompt (0.1.x):</p>
<pre><code class="language-markdown"># Code Review

Review this {language} code:
{code}
</code></pre>
<p>New prompt (0.2.x):</p>
<pre><code class="language-markdown">---
name: code-review
title: Code Review
arguments:
  - name: language
    required: true
  - name: code
    required: true
---

# Code Review

Review this {{language}} code:
{{code}}
</code></pre>
<h3 id="release-schedule"><a class="header" href="#release-schedule">Release Schedule</a></h3>
<ul>
<li><strong>Patch releases</strong>: As needed for bug fixes</li>
<li><strong>Minor releases</strong>: Monthly with new features</li>
<li><strong>Major releases</strong>: When breaking changes are necessary</li>
</ul>
<h3 id="support-policy"><a class="header" href="#support-policy">Support Policy</a></h3>
<ul>
<li>Latest version: Full support</li>
<li>Previous minor version: Security fixes only</li>
<li>Older versions: No support</li>
</ul>
<h2 id="contributing-to-changelog"><a class="header" href="#contributing-to-changelog">Contributing to Changelog</a></h2>
<p>When contributing, please:</p>
<ol>
<li>Add entries under â€œUnreleasedâ€</li>
<li>Use the appropriate section</li>
<li>Reference issue/PR numbers</li>
<li>Keep descriptions concise</li>
<li>Sort entries by importance</li>
</ol>
<p>Example entry:</p>
<pre><code class="language-markdown">### Fixed
- Fix memory leak in file watcher (#123)
</code></pre>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://github.com/wballard/swissarmyhammer/releases">GitHub Releases</a></li>
<li><a href="./release-process.html">Release Process</a></li>
<li><a href="./contributing.html">Contributing Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license-2"><a class="header" href="#license-2">License</a></h1>
<p>SwissArmyHammer is distributed under the MIT License, a permissive open-source license that allows for commercial use, modification, distribution, and private use.</p>
<h2 id="mit-license"><a class="header" href="#mit-license">MIT License</a></h2>
<pre><code>MIT License

Copyright (c) 2024 SwissArmyHammer Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>
<h2 id="what-this-means"><a class="header" href="#what-this-means">What This Means</a></h2>
<h3 id="you-can"><a class="header" href="#you-can">You CAN:</a></h3>
<p>âœ… <strong>Commercial Use</strong> - Use SwissArmyHammer in commercial projects and products</p>
<p>âœ… <strong>Modify</strong> - Make changes to the source code for your needs</p>
<p>âœ… <strong>Distribute</strong> - Share the software with others</p>
<p>âœ… <strong>Private Use</strong> - Use for private purposes without sharing modifications</p>
<p>âœ… <strong>Sublicense</strong> - Include SwissArmyHammer in software with different licensing</p>
<h3 id="you-must"><a class="header" href="#you-must">You MUST:</a></h3>
<p>ğŸ“‹ <strong>Include License</strong> - Include the copyright notice and license in copies</p>
<p>ğŸ“‹ <strong>Include Copyright</strong> - Keep the copyright notice intact</p>
<h3 id="you-cannot"><a class="header" href="#you-cannot">You CANNOT:</a></h3>
<p>âŒ <strong>Hold Liable</strong> - Hold contributors liable for damages</p>
<p>âŒ <strong>Use Trademark</strong> - Use SwissArmyHammer name/logo without permission</p>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<p>SwissArmyHammer uses various open-source dependencies, each with their own licenses:</p>
<h3 id="core-dependencies"><a class="header" href="#core-dependencies">Core Dependencies</a></h3>
<ul>
<li><strong>tokio</strong> (MIT) - Async runtime</li>
<li><strong>serde</strong> (MIT/Apache-2.0) - Serialization framework</li>
<li><strong>clap</strong> (MIT/Apache-2.0) - Command line parsing</li>
<li><strong>liquid</strong> (MIT/Apache-2.0) - Template engine</li>
<li><strong>anyhow</strong> (MIT/Apache-2.0) - Error handling</li>
</ul>
<h3 id="full-dependency-list"><a class="header" href="#full-dependency-list">Full Dependency List</a></h3>
<p>To view all dependencies and their licenses:</p>
<pre><code class="language-bash">cargo license
</code></pre>
<p>Or check the <code>Cargo.lock</code> file for a complete list.</p>
<h2 id="contributing-2"><a class="header" href="#contributing-2">Contributing</a></h2>
<p>By contributing to SwissArmyHammer, you agree that your contributions will be licensed under the MIT License. See <a href="./contributing.html">Contributing</a> for more details.</p>
<h2 id="prompt-content"><a class="header" href="#prompt-content">Prompt Content</a></h2>
<h3 id="your-prompts"><a class="header" href="#your-prompts">Your Prompts</a></h3>
<p>Prompts you create and store in SwissArmyHammer remain your intellectual property. The MIT License applies only to the SwissArmyHammer software itself, not to the content you create with it.</p>
<h3 id="built-in-prompts-1"><a class="header" href="#built-in-prompts-1">Built-in Prompts</a></h3>
<p>Built-in prompts distributed with SwissArmyHammer are covered by the same MIT License as the software.</p>
<h2 id="third-party-content"><a class="header" href="#third-party-content">Third-Party Content</a></h2>
<p>Some documentation and examples may include references to third-party services or tools. These references are for illustration only and donâ€™t imply endorsement. Third-party tools and services are subject to their own licenses and terms.</p>
<h2 id="warranty-disclaimer"><a class="header" href="#warranty-disclaimer">Warranty Disclaimer</a></h2>
<p>SwissArmyHammer is provided â€œas isâ€ without warranty of any kind. The full disclaimer is included in the license text above. In particular:</p>
<ul>
<li>No warranty of merchantability</li>
<li>No warranty of fitness for a particular purpose</li>
<li>No warranty against defects</li>
<li>Use at your own risk</li>
</ul>
<h2 id="questions"><a class="header" href="#questions">Questions</a></h2>
<p>If you have questions about the license:</p>
<ol>
<li>Read the <a href="https://opensource.org/licenses/MIT">MIT License FAQ</a></li>
<li>Consult with a legal professional for specific situations</li>
<li>Open an issue on GitHub for clarification about SwissArmyHammerâ€™s use of the license</li>
</ol>
<h2 id="license-changes"><a class="header" href="#license-changes">License Changes</a></h2>
<p>The project maintainers reserve the right to release future versions under a different license. However:</p>
<ul>
<li>Existing versions remain under their released license</li>
<li>Contributors will be notified of proposed changes</li>
<li>Significant changes require community discussion</li>
</ul>
<h2 id="compliance"><a class="header" href="#compliance">Compliance</a></h2>
<p>To comply with the MIT License when using SwissArmyHammer:</p>
<ol>
<li><strong>In Source Distribution</strong>: Include the LICENSE file</li>
<li><strong>In Binary Distribution</strong>: Include license text in documentation</li>
<li><strong>In Modified Versions</strong>: Note your changes but keep original copyright</li>
<li><strong>In Products</strong>: Include attribution in your credits/about section</li>
</ol>
<p>Example attribution:</p>
<pre><code>This product includes software developed by the SwissArmyHammer project
(https://github.com/wballard/swissarmyhammer), licensed under the MIT License.
</code></pre>
<h2 id="related-documents"><a class="header" href="#related-documents">Related Documents</a></h2>
<ul>
<li><a href="./contributing.html">Contributing Guidelines</a></li>
<li><a href="https://www.rust-lang.org/policies/code-of-conduct">Code of Conduct</a></li>
<li><a href="./security.html">Security Policy</a></li>
<li><a href="https://github.com/wballard/swissarmyhammer/blob/main/LICENSE">Full License File</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
